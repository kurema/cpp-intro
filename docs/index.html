<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="江添 亮" />
  <meta name="date" content="2018-02-27" />
  <title>江添亮のC++入門</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  
  img {
      width: 80vw;
      height: auto;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">江添亮のC++入門</h1>
<h2 class="author">江添 亮</h2>
<h3 class="date">2018-02-27</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#序">序</a></li>
<li><a href="#cの概要">C++の概要</a></li>
<li><a href="#cの実行">C++の実行</a><ul>
<li><a href="#cの実行の仕組み">C++の実行の仕組み</a></li>
<li><a href="#簡単な1つのソースファイルからなるプログラムの実行">簡単な1つのソースファイルからなるプログラムの実行</a><ul>
<li><a href="#サンプルコード">サンプルコード</a></li>
<li><a href="#コンパイル">コンパイル</a></li>
<li><a href="#実行">実行</a></li>
</ul></li>
<li><a href="#gcc-cコンパイラー">GCC: C++コンパイラー</a><ul>
<li><a href="#コンパイラーオプション">コンパイラーオプション</a></li>
<li><a href="#ヘッダーファイルの省略">ヘッダーファイルの省略</a></li>
<li><a href="#コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</a></li>
</ul></li>
<li><a href="#make-ビルドシステム">Make: ビルドシステム</a><ul>
<li><a href="#コンパイルと実行のまとめ">コンパイルと実行のまとめ</a></li>
<li><a href="#依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</a></li>
<li><a href="#依存関係を記述するルール">依存関係を記述するルール</a></li>
<li><a href="#コメント">コメント</a></li>
<li><a href="#変数">変数</a></li>
<li><a href="#自動変数">自動変数</a><ul>
<li><a href="#ターゲット"><code>$@</code> ターゲット</a></li>
<li><a href="#最初の事前要件"><code>$&lt;</code> 最初の事前要件</a></li>
<li><a href="#すべての事前要件"><code>$^</code> すべての事前要件</a></li>
<li><a href="#自動変数の組み合わせ">自動変数の組み合わせ</a></li>
</ul></li>
<li><a href="#phonyターゲット">PHONYターゲット</a></li>
</ul></li>
<li><a href="#入門用の環境構築">入門用の環境構築</a></li>
</ul></li>
<li><a href="#cヒッチハイクガイド">C++ヒッチハイクガイド</a><ul>
<li><a href="#最小のコード">最小のコード</a></li>
<li><a href="#標準出力">標準出力</a></li>
<li><a href="#文字列">文字列</a></li>
<li><a href="#整数と浮動小数点数">整数と浮動小数点数</a></li>
<li><a href="#変数variable">変数(variable)</a></li>
<li><a href="#関数function">関数(function)</a></li>
<li><a href="#本当の関数">本当の関数</a></li>
</ul></li>
<li><a href="#デバッグコンパイルエラーメッセージの読み方">デバッグ：コンパイルエラーメッセージの読み方</a><ul>
<li><a href="#文法エラー">文法エラー</a></li>
<li><a href="#意味エラー">意味エラー</a></li>
<li><a href="#コンパイラーのバグ">コンパイラーのバグ</a></li>
</ul></li>
<li><a href="#条件分岐の果てのレストラン">条件分岐の果てのレストラン</a><ul>
<li><a href="#複合文">複合文</a></li>
<li><a href="#条件分岐">条件分岐</a></li>
<li><a href="#条件式">条件式</a><ul>
<li><a href="#条件とは何だろう">条件とは何だろう</a></li>
</ul></li>
<li><a href="#bool型">bool型</a></li>
<li><a href="#bool型の演算">bool型の演算</a><ul>
<li><a href="#論理否定-operator">論理否定: operator !</a></li>
<li><a href="#同値比較-operator">同値比較: operator ==, !=</a></li>
<li><a href="#論理積-operator">論理積: operator &amp;&amp;</a></li>
<li><a href="#論理和-operator">論理和: operator ||</a></li>
<li><a href="#短絡評価">短絡評価</a></li>
</ul></li>
<li><a href="#boolの変換">boolの変換</a></li>
</ul></li>
<li><a href="#デバッグ-コンパイル警告メッセージ">デバッグ: コンパイル警告メッセージ</a></li>
<li><a href="#最近体重が気になるあなたのための標準入力">最近体重が気になるあなたのための標準入力</a><ul>
<li><a href="#これまでのおさらい">これまでのおさらい</a></li>
<li><a href="#標準入力">標準入力</a></li>
<li><a href="#リダイレクト">リダイレクト</a></li>
<li><a href="#パイプ">パイプ</a></li>
<li><a href="#プログラムの組み合わせ">プログラムの組み合わせ</a></li>
</ul></li>
<li><a href="#ループ">ループ</a><ul>
<li><a href="#これまでのおさらい-1">これまでのおさらい</a></li>
<li><a href="#goto文">goto文</a><ul>
<li><a href="#無限ループ">無限ループ</a></li>
<li><a href="#終了条件付きループ">終了条件付きループ</a></li>
<li><a href="#インデックスループ">インデックスループ</a></li>
</ul></li>
<li><a href="#while文">while文</a><ul>
<li><a href="#無限ループ-1">無限ループ</a></li>
<li><a href="#終了条件付きループ-1">終了条件付きループ</a></li>
<li><a href="#インデックスループ-1">インデックスループ</a></li>
</ul></li>
<li><a href="#for文">for文</a></li>
<li><a href="#do文">do文</a></li>
<li><a href="#break文">break文</a></li>
<li><a href="#continue文">continue文</a></li>
<li><a href="#再帰関数">再帰関数</a></li>
</ul></li>
<li><a href="#メモリーを無限に確保する">メモリーを無限に確保する</a><ul>
<li><a href="#これまでのまとめ">これまでのまとめ</a></li>
<li><a href="#vector">vector</a></li>
</ul></li>
<li><a href="#デバッグprintfデバッグ">デバッグ：printfデバッグ</a><ul>
<li><a href="#実践例">実践例</a></li>
<li><a href="#stdcerr"><code>std::cerr</code></a></li>
<li><a href="#まとめ">まとめ</a></li>
</ul></li>
<li><a href="#整数">整数</a><ul>
<li><a href="#整数リテラル">整数リテラル</a><ul>
<li><a href="#進数リテラル">10進数リテラル</a></li>
<li><a href="#進数リテラル-1">2進数リテラル</a></li>
<li><a href="#進数リテラル-2">8進数リテラル</a></li>
<li><a href="#進数リテラル-3">16進数リテラル</a></li>
<li><a href="#数値区切り">数値区切り</a></li>
</ul></li>
<li><a href="#整数の仕組み">整数の仕組み</a><ul>
<li><a href="#情報の単位">情報の単位</a></li>
<li><a href="#バイトで表現された整数">1バイトで表現された整数</a><ul>
<li><a href="#符号ビット">符号ビット</a></li>
<li><a href="#の補数">1の補数</a></li>
<li><a href="#の補数-1">2の補数</a></li>
</ul></li>
</ul></li>
<li><a href="#整数型">整数型</a><ul>
<li><a href="#int型">int型</a></li>
<li><a href="#long-int型">long int型</a></li>
<li><a href="#long-long-int型">long long int型</a></li>
<li><a href="#short-int型">short int型</a></li>
<li><a href="#char型">char型</a></li>
</ul></li>
<li><a href="#整数型のサイズ">整数型のサイズ</a></li>
<li><a href="#整数型の表現できる値の範囲">整数型の表現できる値の範囲</a></li>
<li><a href="#整数型の変換">整数型の変換</a></li>
</ul></li>
<li><a href="#浮動小数点数">浮動小数点数</a><ul>
<li><a href="#浮動小数点数リテラル">浮動小数点数リテラル</a><ul>
<li><a href="#進浮動小数点数リテラル">10進浮動小数点数リテラル</a></li>
<li><a href="#進数の仮数と指数による表記">10進数の仮数と指数による表記</a></li>
<li><a href="#進数の仮数と指数による表記-1">16進数の仮数と指数による表記</a></li>
</ul></li>
<li><a href="#浮動小数点数の表現と特性">浮動小数点数の表現と特性</a><ul>
<li><a href="#と-0.0"><span class="math inline">\(+0.0\)</span>と<span class="math inline">\(-0.0\)</span></a></li>
<li><a href="#と-無限大"><span class="math inline">\(+∞\)</span>と<span class="math inline">\(-∞\)</span>(無限大)</a></li>
<li><a href="#nannot-a-number">NaN(Not a Number)</a></li>
<li><a href="#有効桁数">有効桁数</a></li>
</ul></li>
<li><a href="#浮動小数点数同士の変換">浮動小数点数同士の変換</a></li>
<li><a href="#浮動小数点数と整数の変換">浮動小数点数と整数の変換</a></li>
</ul></li>
<li><a href="#名前">名前</a><ul>
<li><a href="#キーワード">キーワード</a></li>
<li><a href="#名前に使える文字">名前に使える文字</a></li>
<li><a href="#宣言と定義">宣言と定義</a></li>
<li><a href="#名前空間">名前空間</a><ul>
<li><a href="#グローバル名前空間">グローバル名前空間</a></li>
<li><a href="#名前空間のネスト">名前空間のネスト</a></li>
<li><a href="#名前空間名の別名を宣言する名前空間エイリアス">名前空間名の別名を宣言する名前空間エイリアス</a></li>
<li><a href="#名前空間名の指定を省略するusingディレクティブ">名前空間名の指定を省略するusingディレクティブ</a></li>
<li><a href="#名前空間を指定しなくてもよいinline名前空間">名前空間を指定しなくてもよいinline名前空間</a></li>
</ul></li>
<li><a href="#型名">型名</a><ul>
<li><a href="#型名の別名を宣言するエイリアス宣言">型名の別名を宣言するエイリアス宣言</a></li>
</ul></li>
<li><a href="#スコープ">スコープ</a></li>
</ul></li>
<li><a href="#イテレーターの基礎">イテレーターの基礎</a><ul>
<li><a href="#イテレーターの取得方法">イテレーターの取得方法</a></li>
<li><a href="#イテレーターの参照する要素に対する読み書き">イテレーターの参照する要素に対する読み書き</a></li>
<li><a href="#イテレーターの参照する要素を変更">イテレーターの参照する要素を変更</a></li>
<li><a href="#イテレーターの比較">イテレーターの比較</a></li>
<li><a href="#最後の次の要素へのイテレーター">最後の次の要素へのイテレーター</a></li>
<li><a href="#なんでもイテレーター">なんでもイテレーター</a></li>
<li><a href="#イテレーターと添字の範囲">イテレーターと添字の範囲</a></li>
</ul></li>
<li><a href="#lvalueリファレンスとconst">lvalueリファレンスとconst</a><ul>
<li><a href="#lvalueリファレンス">lvalueリファレンス</a></li>
<li><a href="#const">const</a></li>
</ul></li>
<li><a href="#アルゴリズム">アルゴリズム</a><ul>
<li><a href="#for_each">for_each</a></li>
<li><a href="#all_ofany_ofnone_of">all_of/any_of/none_of</a></li>
<li><a href="#findfind_if">find/find_if</a></li>
<li><a href="#countcount_if">count/count_if</a></li>
<li><a href="#equal">equal</a></li>
<li><a href="#search">search</a></li>
<li><a href="#copy">copy</a></li>
<li><a href="#transform">transform</a></li>
<li><a href="#replace">replace</a></li>
<li><a href="#fill">fill</a></li>
<li><a href="#generate">generate</a></li>
<li><a href="#remove">remove</a></li>
</ul></li>
<li><a href="#ラムダ式">ラムダ式</a><ul>
<li><a href="#基本">基本</a></li>
<li><a href="#キャプチャー">キャプチャー</a><ul>
<li><a href="#コピーキャプチャー">コピーキャプチャー</a></li>
<li><a href="#リファレンスキャプチャー">リファレンスキャプチャー</a></li>
</ul></li>
</ul></li>
<li><a href="#クラスの基本">クラスの基本</a><ul>
<li><a href="#変数をまとめる">変数をまとめる</a></li>
<li><a href="#まとめた変数に関数を提供する">まとめた変数に関数を提供する</a></li>
</ul></li>
<li><a href="#より自然に振る舞うクラス">より自然に振る舞うクラス</a><ul>
<li><a href="#より自然な初期化">より自然な初期化</a></li>
<li><a href="#自然な演算子">自然な演算子</a></li>
<li><a href="#演算子のオーバーロード">演算子のオーバーロード</a><ul>
<li><a href="#二項演算子">二項演算子</a></li>
<li><a href="#単項演算子">単項演算子</a></li>
<li><a href="#インクリメントデクリメント">インクリメント/デクリメント</a></li>
<li><a href="#メンバー関数での演算子のオーバーロード">メンバー関数での演算子のオーバーロード</a></li>
</ul></li>
</ul></li>
<li><a href="#stdarray">std::array</a></li>
<li><a href="#プログラマーの三大美徳">プログラマーの三大美徳</a></li>
<li><a href="#配列">配列</a><ul>
<li><a href="#ナイーブなarray実装">ナイーブなarray実装</a></li>
<li><a href="#配列-1">配列</a></li>
</ul></li>
<li><a href="#テンプレート">テンプレート</a><ul>
<li><a href="#問題点">問題点</a></li>
<li><a href="#関数の引数">関数の引数</a></li>
<li><a href="#関数のテンプレート引数">関数のテンプレート引数</a></li>
<li><a href="#テンプレート-1">テンプレート</a></li>
<li><a href="#クラステンプレート">クラステンプレート</a></li>
</ul></li>
<li><a href="#arrayをさらに実装">arrayをさらに実装</a><ul>
<li><a href="#ネストされた型名">ネストされた型名</a></li>
<li><a href="#要素数の取得-size">要素数の取得: size()</a></li>
<li><a href="#メンバー関数のconst修飾">メンバー関数のconst修飾</a></li>
<li><a href="#先頭と末尾の要素frontback">先頭と末尾の要素：front/back</a></li>
<li><a href="#全要素に値を代入-fill">全要素に値を代入: fill</a></li>
</ul></li>
<li><a href="#arrayのイテレーター">arrayのイテレーター</a><ul>
<li><a href="#イテレーターの中身">イテレーターの中身</a></li>
<li><a href="#残りのイテレーターの実装">残りのイテレーターの実装</a></li>
<li><a href="#constなイテレーター-const_iterator">constなイテレーター: const_iterator</a></li>
</ul></li>
<li><a href="#傲慢なエラー処理-例外">傲慢なエラー処理: 例外</a><ul>
<li><a href="#例外を投げる">例外を投げる</a></li>
<li><a href="#例外を捕まえる">例外を捕まえる</a></li>
<li><a href="#例外による巻き戻し">例外による巻き戻し</a></li>
</ul></li>
<li><a href="#ポインター">ポインター</a><ul>
<li><a href="#意味上のポインター">意味上のポインター</a><ul>
<li><a href="#リファレンスと同じ機能">リファレンスと同じ機能</a></li>
<li><a href="#リファレンスと違う機能">リファレンスと違う機能</a></li>
<li><a href="#代入">代入</a></li>
<li><a href="#何も参照しない状態">何も参照しない状態</a></li>
<li><a href="#明示的に何も参照しないポインター-nullptr">明示的に何も参照しないポインター: nullptr</a></li>
<li><a href="#無効な参照先の作り方">無効な参照先の作り方</a></li>
</ul></li>
<li><a href="#文法上のポインター">文法上のポインター</a><ul>
<li><a href="#ポインターとconstの関係">ポインターとconstの関係</a></li>
<li><a href="#ポインターのポインター">ポインターのポインター</a></li>
<li><a href="#関数へのポインター">関数へのポインター</a></li>
<li><a href="#配列へのポインター">配列へのポインター</a></li>
<li><a href="#ポインター型の作り方">ポインター型の作り方</a></li>
<li><a href="#クラスへのポインター">クラスへのポインター</a></li>
<li><a href="#thisポインター">thisポインター</a></li>
<li><a href="#メンバーへのポインター">メンバーへのポインター</a></li>
</ul></li>
<li><a href="#ポインターの内部実装">ポインターの内部実装</a><ul>
<li><a href="#キロバイトとキビバイト">キロバイトとキビバイト</a></li>
<li><a href="#メモリーとアドレス">メモリーとアドレス</a></li>
<li><a href="#ポインターのサイズ">ポインターのサイズ</a></li>
<li><a href="#ポインターの値">ポインターの値</a></li>
<li><a href="#stdbit_castの実装"><code>std::bit_cast</code>の実装</a></li>
<li><a href="#stdmemcpyの実装"><code>std::memcpy</code>の実装</a><ul>
<li><a href="#void型">void型</a></li>
<li><a href="#void-型">void *型</a></li>
<li><a href="#stdbyte型">std::byte型</a></li>
<li><a href="#配列のメモリー上での表現">配列のメモリー上での表現</a></li>
<li><a href="#ポインターと整数の演算">ポインターと整数の演算</a></li>
<li><a href="#いよいよmemcpyの実装">いよいよmemcpyの実装</a></li>
<li><a href="#memcpyの別の実装">memcpyの別の実装</a></li>
</ul></li>
<li><a href="#データメンバーへのポインターの内部実装">データメンバーへのポインターの内部実装</a></li>
</ul></li>
</ul></li>
<li><a href="#イテレーター詳細">イテレーター詳細</a><ul>
<li><a href="#イテレーターとポインターの関係">イテレーターとポインターの関係</a></li>
<li><a href="#イテレーターカテゴリー">イテレーターカテゴリー</a><ul>
<li><a href="#ランダムアクセスイテレーター">ランダムアクセスイテレーター</a></li>
<li><a href="#双方向イテレーター">双方向イテレーター</a></li>
<li><a href="#前方イテレーター">前方イテレーター</a></li>
<li><a href="#入力イテレーター">入力イテレーター</a></li>
<li><a href="#出力イテレーター">出力イテレーター</a></li>
</ul></li>
<li><a href="#iterator_traits">iterator_traits</a></li>
<li><a href="#イテレーターカテゴリーの実例">イテレーターカテゴリーの実例</a><ul>
<li><a href="#出力イテレーター-1">出力イテレーター</a></li>
<li><a href="#入力イテレーター-1">入力イテレーター</a></li>
<li><a href="#前方イテレーター-1">前方イテレーター</a></li>
<li><a href="#双方向イテレーター-1">双方向イテレーター</a></li>
<li><a href="#ランダムアクセスイテレーター-1">ランダムアクセスイテレーター</a></li>
</ul></li>
<li><a href="#イテレーター操作">イテレーター操作</a><ul>
<li><a href="#advance-i-n-n移動する"><code>advance( i, n )</code>: n移動する</a></li>
<li><a href="#distance-first-last-firstからlastまでの距離"><code>distance( first, last )</code>: firstからlastまでの距離</a></li>
<li><a href="#nextprev-移動したイテレーターを返す">next/prev : 移動したイテレーターを返す</a></li>
</ul></li>
<li><a href="#リバースイテレーター">リバースイテレーター</a></li>
</ul></li>
<li><a href="#動的メモリー確保">動的メモリー確保</a><ul>
<li><a href="#概要">概要</a></li>
<li><a href="#mallocfree">malloc/free</a></li>
<li><a href="#operator-newoperator-delete">operator new/operator delete</a></li>
<li><a href="#生のバイト列を基本的な型の値として使う方法">生のバイト列を基本的な型の値として使う方法</a></li>
<li><a href="#メモリー確保の失敗">メモリー確保の失敗</a></li>
<li><a href="#クラス型の値の構築">クラス型の値の構築</a></li>
<li><a href="#newdelete">new/delete</a></li>
<li><a href="#配列版newdelete">配列版new/delete</a></li>
<li><a href="#スマートポインター">スマートポインター</a></li>
</ul></li>
<li><a href="#vectorの実装-基礎">vectorの実装 : 基礎</a><ul>
<li><a href="#stdallocatortの概要"><code>std::allocator&lt;T&gt;</code>の概要</a></li>
<li><a href="#stdallocatortの使い方"><code>std::allocator&lt;T&gt;</code>の使い方</a></li>
<li><a href="#stdallocator_traitsalloc"><code>std::allocator_traits&lt;Alloc&gt;</code></a></li>
<li><a href="#簡易vectorの概要">簡易vectorの概要</a></li>
<li><a href="#classとアクセス指定">classとアクセス指定</a></li>
<li><a href="#ネストされた型名-1">ネストされた型名</a></li>
<li><a href="#簡易vectorのデータメンバー">簡易vectorのデータメンバー</a></li>
<li><a href="#簡単なメンバー関数の実装">簡単なメンバー関数の実装</a><ul>
<li><a href="#イテレーター">イテレーター</a></li>
<li><a href="#容量確認">容量確認</a></li>
<li><a href="#要素アクセス">要素アクセス</a><ul>
<li><a href="#operator">operator []</a></li>
<li><a href="#at">at</a></li>
<li><a href="#frontback">front/back</a></li>
<li><a href="#data">data</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#vectorの実装-メモリー確保">vectorの実装 : メモリー確保</a><ul>
<li><a href="#メモリー確保と解放の起こるタイミング">メモリー確保と解放の起こるタイミング</a></li>
<li><a href="#デフォルトコンストラクター">デフォルトコンストラクター</a></li>
<li><a href="#アロケーターを取るコンストラクター">アロケーターを取るコンストラクター</a></li>
<li><a href="#要素数と初期値を取るコンストラクターの実装">要素数と初期値を取るコンストラクターの実装</a></li>
<li><a href="#ヘルパー関数">ヘルパー関数</a><ul>
<li><a href="#ネストされた型名traits">ネストされた型名traits</a></li>
<li><a href="#allocatedeallocate">allocate/deallocate</a></li>
<li><a href="#constructdestroy">construct/destroy</a></li>
<li><a href="#destroy_until"><code>destroy_until</code></a></li>
</ul></li>
<li><a href="#clear">clear</a></li>
<li><a href="#デストラクター">デストラクター</a></li>
<li><a href="#reserveの実装">reserveの実装</a></li>
<li><a href="#resize">resize</a></li>
<li><a href="#push_back">push_back</a><ul>
<li><a href="#shrink_to_fit"><code>shrink_to_fit</code></a></li>
</ul></li>
</ul></li>
<li><a href="#vectorのその他のコンストラクター">vectorのその他のコンストラクター</a><ul>
<li><a href="#イテレーターのペア">イテレーターのペア</a></li>
<li><a href="#初期化リスト">初期化リスト</a></li>
</ul></li>
<li><a href="#コピー">コピー</a><ul>
<li><a href="#普通のコピー">普通のコピー</a></li>
<li><a href="#コピーコンストラクター">コピーコンストラクター</a></li>
<li><a href="#コピー代入演算子">コピー代入演算子</a></li>
<li><a href="#コピーの挙動">コピーの挙動</a></li>
<li><a href="#所有するクラス">所有するクラス</a></li>
<li><a href="#ownuからowntへの変換"><code>own&lt;U&gt;</code>から<code>own&lt;T&gt;</code>への変換</a></li>
<li><a href="#もう少し複雑な所有するクラス">もう少し複雑な所有するクラス</a></li>
<li><a href="#vectorのコピー">vectorのコピー</a><ul>
<li><a href="#コピーコンストラクター-1">コピーコンストラクター</a></li>
<li><a href="#コピー代入演算子-1">コピー代入演算子</a></li>
</ul></li>
</ul></li>
<li><a href="#ムーブ">ムーブ</a><ul>
<li><a href="#ムーブの使い方">ムーブの使い方</a></li>
<li><a href="#ムーブの中身">ムーブの中身</a></li>
</ul></li>
<li><a href="#rvalueリファレンス">rvalueリファレンス</a><ul>
<li><a href="#概要-1">概要</a></li>
<li><a href="#rvalueリファレンスの宣言">rvalueリファレンスの宣言</a></li>
<li><a href="#値カテゴリー">値カテゴリー</a><ul>
<li><a href="#lvalue">lvalue</a></li>
<li><a href="#prvalue">prvalue</a></li>
<li><a href="#xvalue">xvalue</a></li>
<li><a href="#rvalue">rvalue</a></li>
<li><a href="#glvalue">glvalue</a></li>
</ul></li>
<li><a href="#rvalueリファレンスのライブラリ">rvalueリファレンスのライブラリ</a><ul>
<li><a href="#stdmove">std::move</a></li>
<li><a href="#stdmoveの実装">std::moveの実装</a></li>
<li><a href="#フォワーディングリファレンス">フォワーディングリファレンス</a></li>
<li><a href="#stdremove_reference_t">std::remove_reference_t<T></a></li>
<li><a href="#stdmoveの正しい実装">std::moveの正しい実装</a></li>
<li><a href="#stdforward">std::forward</a></li>
</ul></li>
</ul></li>
<li><a href="#ムーブの実装">ムーブの実装</a><ul>
<li><a href="#コピーとムーブの判別">コピーとムーブの判別</a></li>
<li><a href="#ムーブの実装-1">ムーブの実装</a><ul>
<li><a href="#ムーブコンストラクター">ムーブコンストラクター</a></li>
<li><a href="#ムーブ代入演算子">ムーブ代入演算子</a></li>
</ul></li>
<li><a href="#デフォルトのムーブ">デフォルトのムーブ</a></li>
<li><a href="#コピーの禁止">コピーの禁止</a></li>
<li><a href="#原則">5原則</a></li>
</ul></li>
<li><a href="#スマートポインター-1">スマートポインター</a><ul>
<li><a href="#unique_ptr">unique_ptr</a></li>
<li><a href="#shared_ptr">shared_ptr</a></li>
</ul></li>
<li><a href="#自作の数値クラスで演算をムーブに対応する方法">自作の数値クラスで演算をムーブに対応する方法</a><ul>
<li><a href="#基本の実装">基本の実装</a></li>
<li><a href="#複合代入演算子">複合代入演算子</a></li>
<li><a href="#単項演算子-1">単項演算子</a></li>
<li><a href="#二項演算子-1">二項演算子</a><ul>
<li><a href="#ムーブしない実装">ムーブしない実装</a></li>
<li><a href="#ムーブをしたくなる状況">ムーブをしたくなる状況</a></li>
</ul></li>
</ul></li>
<li><a href="#文字列-1">文字列</a><ul>
<li><a href="#はじめに">はじめに</a></li>
<li><a href="#基本ソース文字セット">基本ソース文字セット</a></li>
<li><a href="#基本実行文字セット">基本実行文字セット</a></li>
<li><a href="#文字を表現する方法">文字を表現する方法</a><ul>
<li><a href="#ascii">ASCII</a></li>
<li><a href="#unicode">Unicode</a><ul>
<li><a href="#utf-16">UTF-16</a></li>
<li><a href="#utf-32">UTF-32</a></li>
<li><a href="#エンディアンの問題">エンディアンの問題</a></li>
<li><a href="#utf-8">UTF-8</a></li>
</ul></li>
</ul></li>
<li><a href="#os">OS</a></li>
<li><a href="#リテラル">リテラル</a><ul>
<li><a href="#通常の文字リテラル">通常の文字リテラル</a></li>
<li><a href="#ユニバーサルキャラクター名">ユニバーサルキャラクター名</a></li>
<li><a href="#通常の文字列リテラル">通常の文字列リテラル</a></li>
</ul></li>
<li><a href="#ワイド文字">ワイド文字</a></li>
<li><a href="#utf-8utf-16utf-32">UTF-8/UTF-16/UTF-32</a></li>
<li><a href="#生文字列リテラル">生文字列リテラル</a></li>
<li><a href="#文字列の表現方法">文字列の表現方法</a><ul>
<li><a href="#null終端文字列">null終端文字列</a></li>
<li><a href="#stdbasic_string">std::basic_string<CharT></a></li>
<li><a href="#stdbasic_string_view">std::basic_string_view<CharT></a></li>
</ul></li>
<li><a href="#文字列の操作">文字列の操作</a><ul>
<li><a href="#null終端文字列の操作">null終端文字列の操作</a></li>
<li><a href="#basic_stringの操作">basic_stringの操作</a><ul>
<li><a href="#初期化">初期化</a></li>
<li><a href="#結合">結合</a></li>
<li><a href="#イテレーター-1">イテレーター</a></li>
<li><a href="#部分文字列の検索">部分文字列の検索</a></li>
<li><a href="#その他のメンバー関数">その他のメンバー関数</a></li>
<li><a href="#文字列の挿入">文字列の挿入</a></li>
<li><a href="#部分文字列の削除">部分文字列の削除</a></li>
<li><a href="#部分文字列の置換">部分文字列の置換</a></li>
<li><a href="#その他の推奨できない操作">その他の推奨できない操作</a></li>
</ul></li>
<li><a href="#basic_string_viewの操作">basic_string_viewの操作</a></li>
</ul></li>
</ul></li>
<li><a href="#乱数">乱数</a><ul>
<li><a href="#疑似乱数">疑似乱数</a></li>
<li><a href="#乱数エンジン">乱数エンジン</a></li>
<li><a href="#乱数分布">乱数分布</a></li>
<li><a href="#シード">シード</a></li>
<li><a href="#予測不可能な乱数">予測不可能な乱数</a></li>
<li><a href="#十分なシード値の量">十分なシード値の量</a></li>
<li><a href="#乱数分布ライブラリ">乱数分布ライブラリ</a></li>
<li><a href="#分布クラス">分布クラス</a></li>
<li><a href="#一様分布uniform-distribution">一様分布(Uniform Distribution)</a><ul>
<li><a href="#整数の一様分布stduniform_int_distributioninttype">整数の一様分布(<code>std::uniform_int_distribution&lt;IntType&gt;</code>)</a></li>
<li><a href="#浮動小数点数の一様分布uniform_real_distributionrealtype">浮動小数点数の一様分布(<code>uniform_real_distribution&lt;RealType&gt;</code>)</a></li>
</ul></li>
<li><a href="#ベルヌーイ分布bernoulli-distributions">ベルヌーイ分布(Bernoulli distributions)</a><ul>
<li><a href="#ベルヌーイ試行">ベルヌーイ試行</a></li>
<li><a href="#ベルヌーイ分布stdbernoulli_distribution">ベルヌーイ分布(std::bernoulli_distribution)</a></li>
<li><a href="#二項分布stdbinomial_distributioninttype">二項分布(<code>std::binomial_distribution&lt;IntType&gt;</code>)</a></li>
<li><a href="#幾何分布stdgeometric_distribution">幾何分布(std::geometric_distribution<IntType>)</a></li>
<li><a href="#負の二項分布stdnegative_binomial_distribution">負の二項分布(std::negative_binomial_distribution<IntType>)</a></li>
</ul></li>
<li><a href="#ポアソン分布">ポアソン分布</a><ul>
<li><a href="#ポアソン分布poisson_distribution">ポアソン分布(poisson_distribution<T>)</a></li>
<li><a href="#指数分布stdexponential_distributionrealtype">指数分布(<code>std::exponential_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#ガンマ分布stdgamma_distributionrealtype">ガンマ分布(<code>std::gamma_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#ウェイブル分布stdweibull_distributionrealtype">ウェイブル分布(<code>std::weibull_distribution&lt;RealType&gt;</code>)</a></li>
</ul></li>
<li><a href="#極値分布stdextreme_value_distributionrealtype">極値分布(<code>std::extreme_value_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#正規分布">正規分布</a><ul>
<li><a href="#正規分布stdnormal_distributionrealtype">正規分布(<code>std::normal_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#対数正規分布stdlognormal_distributionrealtype">対数正規分布(<code>std::lognormal_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#カイ二乗分布stdchi_squared_distributionrealtype">カイ二乗分布(<code>std::chi_squared_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#コーシー分布stdcauchy_distributionrealtype">コーシー分布(<code>std::cauchy_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#フィッシャーのf分布stdfisher_f_distributionrealtype">フィッシャーの<span class="math inline">\(F\)</span>分布(<code>std::fisher_f_distribution&lt;RealType&gt;</code>)</a></li>
<li><a href="#スチューデントのt分布stdstudent_t_distributionrealtype">スチューデントの<span class="math inline">\(t\)</span>分布(<code>std::student_t_distribution&lt;RealType&gt;</code>)</a></li>
</ul></li>
<li><a href="#サンプリング分布sampling-distributions">サンプリング分布(sampling distributions)</a><ul>
<li><a href="#離散分布stddiscrete_distributioninttype">離散分布(<code>std::discrete_distribution&lt;IntType&gt;</code>)</a><ul>
<li><a href="#簡単な説明">簡単な説明</a></li>
<li><a href="#数学的な説明">数学的な説明</a></li>
<li><a href="#変数の宣言">変数の宣言</a><ul>
<li><a href="#イテレーターのペア-1">イテレーターのペア</a></li>
<li><a href="#初期化リスト-1">初期化リスト</a></li>
<li><a href="#個数デルタ関数">個数、デルタ、関数</a></li>
</ul></li>
<li><a href="#初期化パラメーターの確認">初期化パラメーターの確認</a></li>
<li><a href="#応用例">応用例</a></li>
</ul></li>
<li><a href="#区分定数分布stdpiecewise_constant_distributionrealtype">区分定数分布(<code>std::piecewise_constant_distribution&lt;RealType&gt;</code>)</a><ul>
<li><a href="#簡単な説明-1">簡単な説明</a></li>
<li><a href="#数学的な説明-1">数学的な説明</a></li>
<li><a href="#変数の宣言-1">変数の宣言</a><ul>
<li><a href="#イテレーターによる指定">イテレーターによる指定</a></li>
<li><a href="#初期化リストと関数オブジェクトによる指定">初期化リストと関数オブジェクトによる指定</a></li>
<li><a href="#区間数最小最大関数オブジェクトによる指定">区間数、最小、最大、関数オブジェクトによる指定</a></li>
</ul></li>
<li><a href="#内部状態の取得">内部状態の取得</a></li>
</ul></li>
<li><a href="#区分線形分布stdpiecewise_linear_distributionrealtype">区分線形分布(<code>std::piecewise_linear_distribution&lt;RealType&gt;</code>)</a><ul>
<li><a href="#簡単な説明-2">簡単な説明</a></li>
<li><a href="#数学的な説明-2">数学的な説明</a></li>
<li><a href="#変数の宣言-2">変数の宣言</a><ul>
<li><a href="#イテレーターによる指定-1">イテレーターによる指定</a></li>
<li><a href="#初期化リストと関数オブジェクトによる指定-1">初期化リストと関数オブジェクトによる指定</a></li>
<li><a href="#個数最小値最大値関数オブジェクトによる指定">個数、最小値、最大値、関数オブジェクトによる指定</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#cプリプロセッサー">Cプリプロセッサー</a><ul>
<li><a href="#includeディレクティブ">#includeディレクティブ</a></li>
<li><a href="#define">#define</a><ul>
<li><a href="#オブジェクト風マクロ">オブジェクト風マクロ</a></li>
<li><a href="#関数風マクロ">関数風マクロ</a></li>
<li><a href="#va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</a></li>
<li><a href="#va_opt__"><code>__VA_OPT__</code></a></li>
<li><a href="#演算子">#演算子</a></li>
<li><a href="#演算子-1">##演算子</a></li>
<li><a href="#複数行の置換リスト">複数行の置換リスト</a></li>
<li><a href="#undefディレクティブ">#undefディレクティブ</a></li>
</ul></li>
<li><a href="#条件付きソースファイル選択">条件付きソースファイル選択</a><ul>
<li><a href="#プリプロセッサーの定数式">プリプロセッサーの定数式</a></li>
<li><a href="#ifディレクティブ">#ifディレクティブ</a></li>
<li><a href="#elifディレクティブ">#elifディレクティブ</a></li>
<li><a href="#elseディレクティブ">#elseディレクティブ</a></li>
<li><a href="#ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</a></li>
</ul></li>
<li><a href="#lineディレクティブ">#lineディレクティブ</a></li>
<li><a href="#errorディレクティブ">#errorディレクティブ</a></li>
<li><a href="#pragma">#pragma</a></li>
<li><a href="#nullディレクティブ">Nullディレクティブ</a></li>
<li><a href="#定義済みマクロ名">定義済みマクロ名</a></li>
</ul></li>
<li><a href="#分割コンパイル">分割コンパイル</a><ul>
<li><a href="#ソースファイルとコンパイル">ソースファイルとコンパイル</a></li>
<li><a href="#単一のソースファイルのコンパイル">単一のソースファイルのコンパイル</a></li>
<li><a href="#ヘッダーファイルはコピペ">ヘッダーファイルはコピペ</a></li>
<li><a href="#複数のソースファイルのコンパイル">複数のソースファイルのコンパイル</a></li>
<li><a href="#オブジェクトファイル">オブジェクトファイル</a></li>
<li><a href="#複数のソースファイルの書き方">複数のソースファイルの書き方</a><ul>
<li><a href="#関数">関数</a></li>
<li><a href="#変数-1">変数</a></li>
<li><a href="#インライン関数インライン変数">インライン関数/インライン変数</a></li>
<li><a href="#クラス">クラス</a><ul>
<li><a href="#staticメンバー">staticメンバー</a></li>
</ul></li>
<li><a href="#テンプレート-2">テンプレート</a></li>
</ul></li>
</ul></li>
<li><a href="#デバッガー">デバッガー</a><ul>
<li><a href="#gdbのチュートリアル">GDBのチュートリアル</a></li>
<li><a href="#プログラムの実行">プログラムの実行</a></li>
<li><a href="#プログラムの停止方法">プログラムの停止方法</a><ul>
<li><a href="#ブレイクポイント">ブレイクポイント</a><ul>
<li><a href="#行番号へのブレイクポイント">行番号へのブレイクポイント</a></li>
<li><a href="#ブレイクポイントの確認">ブレイクポイントの確認</a></li>
<li><a href="#ブレイクポイントの削除">ブレイクポイントの削除</a></li>
<li><a href="#ブレイクポイントの有効無効">ブレイクポイントの有効/無効</a></li>
<li><a href="#関数名へのブレイクポイント">関数名へのブレイクポイント</a></li>
</ul></li>
<li><a href="#条件付きブレイクポイント">条件付きブレイクポイント</a></li>
</ul></li>
<li><a href="#プログラムの実行再開とステップ実行">プログラムの実行再開とステップ実行</a><ul>
<li><a href="#実行再開continue">実行再開(continue)</a></li>
<li><a href="#ステップ実行step">ステップ実行(step)</a></li>
<li><a href="#ネクスト実行next">ネクスト実行(next)</a></li>
<li><a href="#関数から抜けるまで実行finish">関数から抜けるまで実行(finish)</a></li>
</ul></li>
<li><a href="#バックトレース">バックトレース</a></li>
<li><a href="#変数の値を確認">変数の値を確認</a></li>
<li><a href="#シグナルによるプログラムの中断">シグナルによるプログラムの中断</a></li>
<li><a href="#コアダンプを使ったプログラムの状態の確認">コアダンプを使ったプログラムの状態の確認</a></li>
</ul></li>
</ul>
</div>
<h1 id="序">序</h1>
<p>本書はプログラミングの経験はあるがC++は知らない読者を対象にしたC++を学ぶための本である。本書はすでに学んだことのみを使って次の知識を説明する手法で書かれた。C++コンパイラーをC++で書く場合、C++コンパイラーのソースコードをコンパイルする最初のC++コンパイラーをどうするかというブートストラップ問題がある。本書はいわばC++における知識のブートストラップを目指した本だ。これにより読者は本を先頭から読んでいけば、まだ学んでいない概念が突如として無説明のまま使われて混乱することなく読み進むことができるだろう。</p>
<p>C++知識のブートストラップを意識した入門書の執筆はなかなかに難しかった。ある機能Xを教えたいが、そのためには機能Yを知っていなければならず、機能Yを理解するためには機能Zの理解が必要といった具合に、C++の機能の依存関係の解決をしなければならなかったからだ。著者自身も苦しい思いをしながらできるだけ今までに説明した知識のみを使って次の知識を教えるように書き進めていった結果、意外な再発見をした。ポインターを教えた後はC++のほとんどの機能を教えることに苦労しなくなったのだ。けっきょくC++ではいまだにポインターの機能はさまざまな機能の土台になっているのだろう。</p>
<p>本書の執筆時点でC++は現在、C++20の規格制定に向けて大詰めを迎えている。C++20では<code>#include</code>に変わるモジュール、軽量な実行媒体であるコルーチン、高級なassert機能としてのコントラクトに加え、とうとうコンセプトが入る。ライブラリとしてもコンセプトを活用したレンジ、<code>span</code>、<code>flat_map</code>などさまざまなライブラリが追加される。その詳細は、次に本を出す機会があるならば『江添亮の詳説C++17』と似たようなC++20の参考書を書くことになるだろう。C++はまだまだ時代に合わせて進化する言語だ。</p>
<p>本書の執筆はGitHub上で公開した状態で行われた。</p>
<p><a href="https://github.com/EzoeRyou/cpp-intro" class="uri">https://github.com/EzoeRyou/cpp-intro</a></p>
<p>本書のライセンスはGPLv3である。ただし、本書の著者近影はGPLv3ではなく撮影者が著作権を保持している。</p>
<p>本書の著者近影の撮影は、著者の古くからの友人でありプロのカメラマンである三浦大に撮影してもらった。</p>
<p>三浦大のWebサイト: <a href="http://www.masarumiura.jp/" class="uri">http://www.masarumiura.jp/</a></p>
<div style="text-align: right;">
<p>江添亮</p>
</div>
<h1 id="cの概要">C++の概要</h1>
<p>C++とは何か。C++の原作者にして最初の実装者であるBjarne Stroustrupは、以下のように簡潔にまとめている。</p>
<blockquote>
<p>C++は、Simulaのプログラム構造化のための機構と、Cのシステムプログラミング用の効率性と柔軟性を提供するために設計された。C++は半年ほどで現場で使えることを見込んでいた。結果として成功した。</p>
<p>Bjarne Stroustrup, A History of C++: 1979-1991, HOPL2</p>
</blockquote>
<p>プログラミング言語史に詳しくない読者は、Simulaというプログラミング言語について知らないことだろう。Simulaというのは、初めてオブジェクト指向プログラミングを取り入れたプログラミング言語だ。当時と言えばまだ高級なプログラミング言語はほとんどなく、<code>if else</code>, <code>while</code>などのIBMの提唱した構造化プログラミングを可能にする文法を提供しているプログラミング言語すら、多くは研究段階であった。いわんやオブジェクト指向など、当時はまだアカデミックにおいて可能性の1つとして研究されている程度の地に足のついていない夢の機能であった。そのような粗野な時代において、Simulaは先進的なオブジェクト指向プログラミングを実現していた。</p>
<p>オブジェクト指向は現代のプログラミング言語ではすっかり普通になった。データの集合とそのデータに適用する関数を関連付けることができる便利なシンタックスシュガー、つまりプログラミング言語の文法上の機能として定着した。しかし、当時のオブジェクト指向というのはもっと抽象度の高い概念であった。本来のオブジェクト指向をプログラミング言語に落とし込んだ最初の言語として、SimulaとSmalltalkがある。</p>
<p>Simulaではクラスのオブジェクト1つ1つが、あたかも並列実行しているかのように振る舞った。Smalltalkでは同一プログラム内のオブジェクトごとのデータのやり取りですらあたかもネットワーク越しに通信をするかのようなメッセージパッシングで行われた。</p>
<p>問題は、そのような抽象度の高すぎるSimulaやSmalltalkのようなプログラミング言語の設計と実装では実行速度が遅く、大規模なプログラムを開発するには適さなかった。</p>
<p>Cの効率性と柔軟性というのは、要するに実行速度が速いとかメモリー消費量が少ないということだ。ではなぜCはほかの言語に比べて効率と柔軟に優れているのか。これには2つの理由がある。</p>
<p>1つ、Cのコードは直接ハードウェアがサポートする命令にまでマッピング可能であるということ。現実のハードウェアにはストレージがあり、メモリーがあり、キャッシュがあり、レジスターがあり、命令は投機的に並列実行される泥臭い計算機能を提供している。</p>
<p>1つ、使わない機能のコストを支払う必要がないというゼロオーバーヘッドの原則。例えばあらゆるメモリー利用がGC(ガベージコレクション)によって管理されている言語では、たとえメモリーをすべて明示的に管理していたとしても、GCのコストを支払わなければならない。GCではプログラマーは確保したメモリーの解放処理を明示的に書く必要はない。定期的に全メモリーを調べて、どこからも使われていないメモリーを解放する。この処理には余計なコストがかかる。しかし、いつメモリーを解放すべきかがコンパイル時に決定できる場合では、GCは必要ない。GCが存在する言語では、たとえGCが必要なかったとしても、そのコストを支払う必要がある。また実行時にメモリーレイアウトを判定して実行時に分岐処理ができる言語では、たとえコンパイル時にメモリーレイアウトが決定されていたとしても、実行時にメモリーレイアウトを判定して条件分岐するコストを支払わなければならない。</p>
<p>C++は、「アセンブリ言語をおいて、C++より下に言語を置かない」と宣言するほど、ハードウェア機能への直接マッピングとゼロオーバーヘッドの原則を重視している。</p>
<p>C++のほかの特徴としては、委員会方式による国際標準規格を定めていることがある。特定の一個人や一法人が所有する言語は、個人や法人の意思で簡単に仕様が変わってしまう。短期的な利益を追求するために長期的に問題となる変更をしたり、単一の実装が仕様だと言わんばかりの振る舞いをする。特定の個人や法人に所有されていないこと、実装が従うべき標準規格があること、独立した実装が複数あること、言語に利害関係を持つ関係者が議論して投票で変更を可決すること、これがC++が長期に渡って使われてきた理由でもある。</p>
<p>委員会方式の規格制定では、下位互換性の破壊は忌避される。なぜならば、既存の動いているコードを壊すということは、それまで存在していた資産の価値を毀損することであり、利害関係を持つ委員が反対するからだ。</p>
<p>下位互換性を壊した結果何が起こるかというと、単に言語が新旧2つに分断される。Python 2とPython 3がその最たる例だ。</p>
<p>C++には今日の最新で高級な言語からみれば古風な制約が数多く残っているが、いずれも理由がある。下位互換性を壊すことができないという理由。効率的な実装方法が存在しないという理由。仮に効率的な実装が存在するにしても、さまざまな環境で実装可能でなければ規格化はできないという理由。</p>
<p>C++には善しあしがある。Bjarne StroustrupはC++への批判にこう答えている。</p>
<blockquote>
<p>言語には2種類ある。文句を言われる言語と、誰も使わない言語。</p>
</blockquote>
<p>C++は文句を言われる方の言語だ。</p>
<h1 id="cの実行">C++の実行</h1>
<p>プログラミング言語を学ぶには、まず書いたソースコードをプログラムとして実行できるようになることが重要だ。自分が正しく理解しているかどうかを確認するために書いたコードが期待どおりに動くことを確かめてこそ、正しい理解が確認できる。</p>
<h2 id="cの実行の仕組み">C++の実行の仕組み</h2>
<p>C++は慣習的に、ソースファイルをコンパイルしてオブジェクトファイルを生成し、オブジェクトファイルをリンクして実行可能ファイルを生成し、実行可能ファイルを直接実行することで実行する言語だ。</p>
<p>ほかの言語では、ソースファイルをそのままパースし、解釈して実行するインタープリター形式の言語が多い。もっとも、いまとなってはソースファイルから中間言語に変換して、VM(Virtual Machine)と呼ばれる中間言語を解釈して実行するソフトウェア上で実行するとか、JIT(Just-In-Time)コンパイルしてネイティブコードを生成して実行するといった実装もあるため、昔のように単純にインタープリター型の言語ということはできなくなっている事情はある。ただし、最終的にJITコンパイルされてネイティブコードが実行される言語でも、コンパイルやコード生成はプログラマーが意識しない形で行われるため、プログラマーはコンパイラーを直接使う必要のない言語も多い。</p>
<p>C++はプログラマーが直接コンパイラーを使い、ソースファイルをプログラムに変換する言語だ。</p>
<h2 id="簡単な1つのソースファイルからなるプログラムの実行">簡単な1つのソースファイルからなるプログラムの実行</h2>
<p>ここでは、典型的なC++のソースファイルをどのようにコンパイルし実行するか、一連の流れを学ぶ。</p>
<h3 id="サンプルコード">サンプルコード</h3>
<p>以下のC++のソースファイルは標準出力に<code>hello</code>と出力するものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>コードの詳細な意味はさておくとして、このサンプルコードを使ってC++の実行までの流れを見ていこう。</p>
<p>まずは端末から作業用の適当な名前のディレクトリーを作る。ここでは<code>cpp</code>としておこう。ディレクトリーの作成は<code>mkdir</code>コマンドで行える。</p>
<pre><code>$ mkdir cpp
$ cd cpp</code></pre>
<p>好きなテキストエディターを使って上のサンプルコードをテキストファイルとして記述する。ファイル名は<code>hello.cpp</code>としておこう。</p>
<pre><code>$ vim hello.cpp</code></pre>
<p>C++のソースファイルの名前は何でもよいが、慣習で使われている拡張子がいくつかある。本書では<code>.cpp</code>を使う。</p>
<p>無事にソースファイルが作成できたかどうか確認してみよう。現在のカレントディレクトリー下のファイルの一覧を表示するには<code>ls</code>、ファイルの内容を表示するには<code>cat</code>を使う。</p>
<pre><code>$ ls
hello.cpp
$ cat hello.cpp
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;hello&quot; ;
}</code></pre>
<h3 id="コンパイル">コンパイル</h3>
<p>さて、ソースファイルが用意できたならば、いよいよコンパイルだ。</p>
<p>C++のソースファイルから、実行可能ファイルを生成するソフトウェアをC++コンパイラーという。C++コンパイラーとしては、GCC(GNU Compiler Collection)とClang(クラン)がある。使い方はどちらもほぼ同じだ。</p>
<p>GCCを使って先ほどの<code>hello.cpp</code>をコンパイルするには以下のようにする。</p>
<pre><code>$ g++ -o hello hello.cpp</code></pre>
<p>GCCという名前のC++コンパイラーなのに<code>g++</code>なのは、<code>gcc</code>はC言語コンパイラーの名前としてすでに使われているからだ。この慣習はClangも引き継いでいて、ClangのC++コンパイラーは<code>clang++</code>だ。</p>
<p>サンプルコードを間違いなくタイプしていれば、カレントディレクトリーに<code>hello</code>という実行可能ファイルが作成されるはずだ。確認してみよう。</p>
<pre><code>$ ls
hello hello.cpp</code></pre>
<h3 id="実行">実行</h3>
<p>さて、いよいよ実行だ。通常のOSではカレントディレクトリーが<code>PATH</code>に含まれていないため、実行するにはカレントディレクトリーからパスを指定する必要がある。</p>
<pre><code>$ ./hello
hello</code></pre>
<p>上出来だ。初めてのC++プログラムが実行できた。さっそくC++を学んでいきたいところだが、その前にC++プログラミングに必要なツールの使い方を学ぶ必要がある。</p>
<h2 id="gcc-cコンパイラー">GCC: C++コンパイラー</h2>
<p>GCCはC++のソースファイルからプログラムを生成するC++コンパイラーだ。</p>
<p>GCCの基本的な使い方は以下のとおり。</p>
<pre><code>g++ その他のオプション -o 出力するファイル名 ソースファイル名</code></pre>
<p>ソースファイル名は複数指定することができる。</p>
<pre><code>$ g++ -o abc a.cpp b.cpp c.cpp</code></pre>
<p>これについては分割コンパイルの章で詳しく解説する。</p>
<p>コンパイラーはメッセージを出力することがある。コンパイルメッセージには、エラーメッセージと警告メッセージとがある。</p>
<p>エラーメッセージというのは、ソースコードに文法上、意味上の誤りがあるため、コンパイルできない場合に生成される。エラーメッセージはエラーの箇所も教えてくれる。ただし、文法エラーは往々にして適切な誤りの箇所を指摘できないこともある。これは、C++の文法としては正しくないテキストファイルから、妥当なC++であればどういう間違いなのかを推測する必要があるためだ。</p>
<p>警告メッセージというのは、ソースコードにコンパイルを妨げる文法上、意味上の誤りは存在しないが、誤りの可能性が疑われる場合に出力される。</p>
<h3 id="コンパイラーオプション">コンパイラーオプション</h3>
<p>GCCのコンパイラーオプションをいくつか学んでいこう。</p>
<p><code>-std=</code>はC++の規格を選択するオプションだ。C++17に準拠したいのであれば<code>-std=c++17</code>を指定する。読者が本書を読むころには、C++20や、あるいはもっと未来の規格が発行されているかもしれない。常に最新のC++規格を選択するオプションを指定するべきだ。</p>
<p><code>-Wall</code>はコンパイラーの便利な警告メッセージのほとんどすべてを有効にするオプションだ。コンパイラーによる警告メッセージはプログラムの不具合を未然に発見できるので、このオプションは指定すべきだ。</p>
<p><code>--pedantic-errors</code>はC++の規格を厳格に守るオプションだ。規格に違反しているコードがコンパイルエラー扱いになる。</p>
<p>これをまとめると、GCCは以下のように使う。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-errors -o 出力ファイル名 入力ファイル名</code></pre>
<p>ところで、GCCのオプションはとても多い。すべてを知りたい読者は、以下のようにしてGCCのマニュアルを読むとよい。</p>
<pre><code>$ man gcc</code></pre>
<p>手元にマニュアルがない場合、GCCのWebサイトにあるオンラインマニュアルも閲覧できる。</p>
<ul>
<li><a href="https://gcc.gnu.org/" class="uri">https://gcc.gnu.org/</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/" class="uri">https://gcc.gnu.org/onlinedocs/</a></li>
</ul>
<h3 id="ヘッダーファイルの省略">ヘッダーファイルの省略</h3>
<p>先ほどのソースコードをもう一度見てみよう。冒頭に以下のような行がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span></code></pre></div>
<p>これは<code>#includeディレクティブ</code>(#include directive)といい、プリプロセッサー(preprocessor)の一部だ。プリプロセッサーについて詳しくは煩雑になるので巻末資料を参照してもらうとして、このコードは<code>iostream</code>ライブラリを使うために必要で、その意味としてはヘッダーファイル<code>iostream</code>の取り込みだ。</p>
<p>C++の標準ライブラリを使うには、ライブラリごとに対応した<code>#includeディレクティブ</code>を書かなければならない。それはあまりにも煩雑なので、本書では標準ライブラリのヘッダーファイルをすべて<code>#include</code>した<code>ヘッダーファイル</code>(header file)を作成し、それを<code>#include</code>することで、<code>#include</code>を書かなくて済むようにする。</p>
<p>そのためにはまず標準ライブラリのヘッダーファイルのほとんどすべてを<code>#include</code>したヘッダーファイル、<code>all.h</code>を作成する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstddef&gt;</span>
<span class="ot">#include &lt;limits&gt;</span>
<span class="ot">#include &lt;climits&gt;</span>
<span class="ot">#include &lt;cfloat&gt;</span>
<span class="ot">#include &lt;cstdint&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>
<span class="ot">#include &lt;new&gt;</span>
<span class="ot">#include &lt;typeinfo&gt;</span>
<span class="ot">#include &lt;exception&gt;</span>
<span class="ot">#include &lt;initializer_list&gt;</span>
<span class="ot">#include &lt;cstdalign&gt;</span>
<span class="ot">#include &lt;stdexcept&gt;</span>
<span class="ot">#include &lt;cassert&gt;</span>
<span class="ot">#include &lt;cerrno&gt;</span>
<span class="ot">#include &lt;system_error&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="ot">#if __has_include(&lt;string_view&gt;)</span>
<span class="ot">#   include &lt;string_view&gt;</span>
<span class="ot">#endif</span>

<span class="ot">#include &lt;array&gt;</span>
<span class="ot">#include &lt;deque&gt;</span>
<span class="ot">#include &lt;forward_list&gt;</span>
<span class="ot">#include &lt;list&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;map&gt;</span>
<span class="ot">#include &lt;set&gt;</span>
<span class="ot">#include &lt;unordered_map&gt;</span>
<span class="ot">#include &lt;unordered_set&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>
<span class="ot">#include &lt;iterator&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>
<span class="ot">#include &lt;cfenv&gt;</span>
<span class="ot">#include &lt;random&gt;</span>
<span class="ot">#include &lt;numeric&gt;</span>
<span class="ot">#include &lt;cmath&gt;</span>
<span class="ot">#include &lt;iosfwd&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;ios&gt;</span>
<span class="ot">#include &lt;streambuf&gt;</span>
<span class="ot">#include &lt;istream&gt;</span>
<span class="ot">#include &lt;ostream&gt;</span>
<span class="ot">#include &lt;iomanip&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>
<span class="ot">#include &lt;fstream&gt;</span>

<span class="ot">#if __has_include(&lt;filesystem&gt;)</span>
<span class="ot">#   include &lt;filesystem&gt;</span>
<span class="ot">#endif</span>

<span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;cinttypes&gt;</span>


<span class="ot">#include &lt;regex&gt;</span>
<span class="ot">#include &lt;atomic&gt;</span>
<span class="ot">#include &lt;thread&gt;</span>
<span class="ot">#include &lt;mutex&gt;</span>
<span class="ot">#include &lt;shared_mutex&gt;</span>
<span class="ot">#include &lt;condition_variable&gt;</span>
<span class="ot">#include &lt;future&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std::literals ;</code></pre></div>
<p>このようなヘッダーファイル<code>all.h</code>を作成したあとに、ソースファイルで以下のように書けば、ほかのヘッダーファイルを<code>#include</code>する必要がなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;all.h&quot;</span>

<span class="co">// その他のコード</span></code></pre></div>
<p><code>//</code>から行末まではコメントで、好きなテキストを書くことができる。</p>
<p>しかし、この最初の1行の<code>#include</code>も面倒だ。そこでGCCのオプション<code>-include</code>を使い、<code>all.h</code>を常に<code>#include</code>した扱いにする。</p>
<pre><code>$ g++ -include all.h -o program main.cpp</code></pre>
<p>このようにすると、<code>main.cpp</code>が以下のコードでもコンパイルできるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>
<span class="co">// 面倒な#includeなどなし</span>

<span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>これでヘッダーファイルが省略できるようになった。</p>
<h3 id="コンパイル済みヘッダーprecompiled-header">コンパイル済みヘッダー(precompiled header)</h3>
<p>C++はソースファイルをコンパイルする必要がある言語だ。コンパイルには時間がかかる。コンパイルにどれだけ時間がかかっているかを計測するには、以下のようにするとよい。</p>
<pre><code>$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>どうだろうか。読者の環境にもよるが、知覚できるぐらいの時間がかかっているのではないだろうか。プログラミングの習得にはコードを書いてから実行までの時間が短い方がよい。そこで本格的にC++を学ぶ前に、コンパイル時間を短縮する方法を学ぶ。</p>
<p>プログラムで変更しないファイルを事前にコンパイルしておくと、変更した部分だけコンパイルすればよいので、コンパイル時間の短縮になる。GCCでは、ヘッダーファイルを事前にコンパイルする特別な機能がある。標準ライブラリのヘッダーファイルは変更しないので、事前にコンパイルしておけばコンパイル時間の短縮になる。</p>
<p>事前にコンパイルしたヘッダーファイルのことをコンパイル済みヘッダー(precompiled header)という。</p>
<p>すでに作成した<code>all.h</code>はコンパイル済みヘッダーとするのに適切なヘッダーファイルだ。</p>
<p>コンパイル済みヘッダーファイルを作成するには、ヘッダーファイル単体をGCCに与え、出力するファイルを<code>ヘッダーファイル名.gch</code>とする。ヘッダーファイル名が<code>all.h</code>の場合、<code>all.h.gch</code>となる。</p>
<p>GCCのオプションにはほかのソースファイルをコンパイルするときと同じオプションを与えるほか、ヘッダーファイルがC++で書かれていることを示すオプション<code>-x c++-header</code>を与える。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h</code></pre>
<p>こうすると、コンパイル済みヘッダーファイル<code>all.h.gch</code>が生成できる。</p>
<p>GCCはヘッダーファイルを使うときに、同名の<code>.gch</code>ファイルが存在する場合は、そちらをコンパイル済みヘッダーファイルとして使うことで、ヘッダーファイルの処理を省略する。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<p>コンパイル済みヘッダーは1回のコンパイルにつき1つしか使うことができない。そのため、コンパイル済みヘッダーとするヘッダーファイルを定め、そのヘッダーファイル内にほかのヘッダーをすべて記述する。本書ではコンパイル済みヘッダーファイルとする元のヘッダーファイルの名前を<code>all.h</code>とする。</p>
<p>さっそくコンパイル時間の短縮効果を確かめてみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp
$ time g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp</code></pre>
<h2 id="make-ビルドシステム">Make: ビルドシステム</h2>
<h3 id="コンパイルと実行のまとめ">コンパイルと実行のまとめ</h3>
<p>ここまで、我々はソースファイルをコンパイルして実行可能ファイルを生成し、プログラムを実行する方法について学んできた。これまでに学んできたことを一連のコマンドで振り返ってみよう。</p>
<pre><code>$ ls
all.h main.cpp
$ cat all.h
#include &lt;iostream&gt;
$ cat main.cpp
int main() { std::cout &lt;&lt; &quot;hello&quot;s ; }</code></pre>
<p>まず、カレントディレクトリーには<code>all.h</code>と<code>main.cpp</code>がある。この2つのファイルは実行可能ファイルを生成するために必要なファイルだ。今回、その中身は最小限にしてある。本当の<code>all.h</code>は、実際には前回書いたように長い内容になる。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -x c++-header -o all.h.gch all.h
$ ls
all.h all.h.gch main.cpp</code></pre>
<p>次に、ソースファイルのコンパイルを高速化するために、ヘッダーファイル<code>all.h</code>から、コンパイル済みヘッダーファイル<code>all.h.gch</code>を生成する。</p>
<pre><code>$ g++ -std=c++17 -Wall --pedantic-errors -include all.h -o program main.cpp
$ ls
all.h all.h.gch main.cpp program</code></pre>
<p>プリコンパイル済みヘッダーファイル<code>all.h.gch</code>とC++ソースファイル<code>main.cpp</code>から、実行可能ファイル<code>program</code>を生成する。</p>
<pre><code>$ ./program
hello</code></pre>
<p>実行可能ファイル<code>program</code>を実行する。</p>
<p>これで読者はC++のプログラミングを学び始めるにあたって必要なことはすべて学んだ。さっそくC++を学んでいきたいところだが、その前にもう1つ、ビルドシステムを学ぶ必要がある。</p>
<h3 id="依存関係を解決するビルドシステム">依存関係を解決するビルドシステム</h3>
<p>以上のC++のソースファイルからプログラムを実行するまでの流れは、C++のプログラムとしてはとても単純なものだが、それでも依存関係が複雑だ。</p>
<p>プログラムの実行にあたって最終的に必要なのはファイル<code>program</code>だが、このファイルはGCCで生成しなければならない。ところでGCCでファイル<code>program</code>を生成するには、事前に<code>all.h</code>, <code>all.h.gch</code>, <code>main.cpp</code>が必要だ。<code>all.h.gch</code>は<code>all.h</code>からGCCで生成しなければならない。</p>
<p>一度コンパイルしたプログラムのソースファイルを書き換えて再びコンパイルする場合はどうすればいいだろう。<code>main.cpp</code>だけを書き換えた場合、<code>all.h</code>は何も変更されていないので、コンパイル済みヘッダーファイル<code>all.h.gch</code>の再生成は必要ない。<code>all.h</code>だけを書き換えた場合は、<code>all.h.gch</code>を生成するだけでなく、<code>program</code>も再生成しなければならない。</p>
<p>プログラムのコンパイルには、このような複雑な依存関係の解決が必要になる。依存関係の解決を人間の手で行うのはたいへんだ。例えば読者が他人によって書かれた何千ものソースファイルと、プログラムをコンパイルする手順書だけを渡されたとしよう。手順書に従ってコンパイルをしたとして、ソースファイルの一部だけを変更した場合、いったいどの手順は省略できるのか、手順書から導き出すのは難しい。するとコンパイルを最初からやり直すべきだろうか。しかし、1つのソースファイルのコンパイルに1秒かかるとして、何千ものソースファイルがある場合、何千秒もかかってしまう。たった1つのソースファイルを変更しただけですべてをコンパイルし直すのは時間と計算資源の無駄だ。</p>
<p>この依存関係の問題は、ビルドシステムによって解決できる。本書ではGNU Makeというビルドシステムを学ぶ。読者がこれから学ぶビルドシステムによって、以下のような簡単なコマンドだけで、他人の書いた何千ものソースファイルからなるプログラムがコンパイル可能になる。</p>
<p>何千ものソースファイルから実行可能ファイルを生成したい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド1つでプログラムのコンパイルは自動的に行われる。</p>
<p>何千ものソースファイルのうち、1つのソースファイルだけを変更し、必要な部分だけを効率よく再コンパイルしたい。</p>
<pre><code>$ make</code></pre>
<p>これだけだ。<code>make</code>というコマンド1つでプログラムの再コンパイルは自動的に行われる。</p>
<p>ところで、生成される実行可能ファイルの名前はプログラムごとにさまざまだ。プログラムの開発中は、共通の方法でプログラムを実行したい。</p>
<pre><code>$ make run</code></pre>
<p>これでどんなプログラム名でも共通の方法で実行できる。</p>
<p>ソースファイルから生成されたプログラムなどのファイルをすべて削除したい。</p>
<pre><code>$ make clean</code></pre>
<p>これで生成されたファイルをすべて削除できる。</p>
<p>テキストエディターにはVimを使っているがわざわざVimからターミナルに戻るのが面倒だ。</p>
<pre><code>:make</code></pre>
<p>VimはノーマルモードからMakeを呼び出すことができる。もちろん、<code>:make run</code>や<code>:make clean</code>もできる。</p>
<h3 id="依存関係を記述するルール">依存関係を記述するルール</h3>
<p>依存関係はどのように表現したらいいのだろうか。GNU Makeでは<code>Makefile</code>という名前のファイルの中に、<code>ターゲット</code>(targets)、<code>事前要件</code>(prerequisites)、<code>レシピ</code>(recipes)という3つの概念で依存関係を<code>ルール</code>(rules)として記述する。<code>ルール</code>は以下の文法だ。</p>
<pre><code>ターゲット : 事前要件
[TAB文字]レシピ</code></pre>
<p>レシピは必ず<code>TAB文字</code>を直前に書かなければならない。スペース文字ではだめだ。これは<code>make</code>の初心者を混乱させる落とし穴の1つとなっている。忘れずに<code>TAB文字</code>を打とう。</p>
<p>問題を簡単に理解するために、以下のような状況を考えよう。</p>
<pre><code>$ ls
source
$ cat source &gt; program</code></pre>
<p>この例では、ファイル<code>program</code>を生成するためにはファイル<code>source</code>が必要だ。ファイル<code>source</code>はすでに存在している。</p>
<p><code>ターゲット</code>は生成されるファイル名だ。この場合<code>program</code>となる。</p>
<pre><code>program : 事前要件
    レシピ</code></pre>
<p><code>事前要件</code>は<code>ターゲット</code>を生成するために必要なファイル名だ。この場合<code>source</code>となる。</p>
<pre><code>program : source
    レシピ</code></pre>
<p><code>レシピ</code>は<code>ターゲット</code>を生成するために必要な動作だ。この場合、<code>cat source &gt; program</code>となる</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program</code></pre></div>
<p>さっそくこのルールを、ファイル<code>Makefile</code>に書き込み、<code>make</code>を呼び出してみよう。</p>
<pre><code>$ ls
Makefile source 
$ cat Makefile
program : source
    cat source &gt; program
$ make
cat source &gt; program
$ ls
Makefile program source</code></pre>
<p>これがMakeの仕組みだ。<code>ターゲット</code>の生成に必要な<code>事前要件</code>と、<code>ターゲット</code>を生成する<code>レシピ</code>を組み合わせた<code>ルール</code>で依存関係を記述する。<code>make</code>を実行すると、実行した<code>レシピ</code>が表示される。</p>
<p>もう少しMakeの<code>ルール</code>を追加してみよう。例えばファイル<code>source</code>はあらかじめ存在するのではなく、ファイル<code>source01</code>, <code>source02</code>, <code>source03</code>の中身をこの順番で連結して生成するとしよう。以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<p>GNU Makeはカレントディレクトリーにあるファイル<code>Makefile</code>の一番上に書かれたルールを実行しようとする。<code>program</code>を生成するには<code>source</code>が必要だが、<code>source</code>の生成には別のルールの実行が必要だ。<code>Makefile</code>はこの依存関係を自動で解決してくれる。</p>
<pre><code>$ touch source01 source02 source03
$ ls
Makefile source01 source02 source03
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program
$ ls
Makefile program source source01 source02 source03</code></pre>
<p>すでに<code>make</code>を実行したあとで、もう一度<code>make</code>を実行するとどうなるだろうか。</p>
<pre><code>$ make
make: &#39;program&#39; is up to date.</code></pre>
<p>このメッセージの意味は「<code>program</code>は最新だ」という意味だ。<code>make</code>はファイルのタイムスタンプを調べ、もしファイル<code>program</code>より<code>source</code>のタイムスタンプの方が若い場合、つまり<code>program</code>が変更されたよりもあとに<code>source</code>が変更された場合、<code>ルール</code>を実行する。</p>
<p>試しにファイル<code>source02</code>のタイムスタンプを更新してみよう。</p>
<pre><code>$ touch source02
$ make
cat source01 source02 source03 &gt; source
cat source &gt; program</code></pre>
<p>ファイル<code>source</code>は<code>事前要件</code>に<code>source02</code>を含む。<code>source02</code>のタイムスタンプが<code>source</code>より若いので、<code>source</code>が再び生成される。すると、<code>source</code>のタイムスタンプが<code>program</code>のタイムスタンプよりも若くなったので、<code>program</code>も生成される。</p>
<p>もう1つ例を見てみよう。</p>
<pre><code>$ touch a b c
$ ls
a b c Makefile</code></pre>
<p>あるディレクトリーにファイル<code>a</code>, <code>b</code>, <code>c</code>がある。</p>
<p><code>Makefile</code>は以下の内容になっている。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">D :</span><span class="dt"> A B C</span>
    cat A B C &gt; D

<span class="dv">A :</span><span class="dt"> a</span>
    cat a &gt; A

<span class="dv">B :</span><span class="dt"> b</span>
    cat b &gt; B

<span class="dv">C :</span><span class="dt"> c</span>
    cat c &gt; C</code></pre></div>
<p>この<code>Makefile</code>を呼び出したときに作られるのはファイル<code>D</code>だ。ファイル<code>D</code>を作るにはファイル<code>A</code>, <code>B</code>, <code>C</code>が必要だ。このファイルはそれぞれファイル<code>a</code>, <code>b</code>, <code>c</code>から生成されるルールが記述してある。</p>
<p>これを<code>make</code>すると以下のようにファイル<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>が作られる。</p>
<pre><code>$ ls
a b c Makefile
$ make
cat a &gt; A
cat b &gt; B
cat c &gt; C
cat A B C &gt; D</code></pre>
<p>ここで、ファイル<code>b</code>のタイムスタンプだけを更新して<code>make</code>してみよう。</p>
<pre><code>$ touch b
$ make
cat b &gt; B
cat A B C &gt; D</code></pre>
<p>ファイル<code>b</code>のタイムスタンプがファイル<code>B</code>より若くなったので、ファイル<code>B</code>がターゲットとなったルールが再び実行される。ファイル<code>A</code>, <code>C</code>のルールは実行されない。そしてファイル<code>B</code>のタイムスタンプがファイル<code>D</code>より若くなったので、ファイル<code>D</code>がターゲットとなったルールが再び実行される。</p>
<p><code>make</code>により、処理する必要のあるルールだけが部分的に処理されていることがわかる。</p>
<p><code>make</code>は適切な<code>ルール</code>さえ書けば、依存関係の解決を自動的に行ってくれる。</p>
<h3 id="コメント">コメント</h3>
<p><code>Makefile</code>にはコメントを書くことができる。<code>#</code>で始まる行はコメント扱いされる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="co"># programを生成するルール</span>
<span class="dv">program :</span><span class="dt"> source</span>
    cat source &gt; program

<span class="co"># sourceを生成するルール</span>
<span class="dv">source :</span><span class="dt"> source01 source02 source03</span>
    cat source01 source02 source03 &gt; source</code></pre></div>
<h3 id="変数">変数</h3>
<p><code>Makefile</code>には<code>変数</code>を書くことができる。</p>
<p>変数の文法は以下のとおり。</p>
<pre><code>variable = foobar

target : $(variable)</code></pre>
<p>これは、</p>
<pre><code>target : foobar</code></pre>
<p>と書いたものと同じように扱われる。</p>
<p>変数は<code>=</code>の左側に変数名、右側に変数の内容を書く。</p>
<p>変数を使うときは、<code>$(変数名)</code>のように、<code>$()</code>で変数名を包む。</p>
<h3 id="自動変数">自動変数</h3>
<p>GNU Makeは便利なことに、いくつかの変数を自動で作ってくれる。</p>
<h4 id="ターゲット"><code>$@</code> ターゲット</h4>
<p><code>$@</code>はルールのターゲットのファイル名になる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span>
    echo <span class="ch">$@</span></code></pre></div>
<p>この<code>Makefile</code>を実行すると以下のように出力される。</p>
<pre><code>$ make
echo target</code></pre>
<h4 id="最初の事前要件"><code>$&lt;</code> 最初の事前要件</h4>
<p><code>$&lt;</code>はルールの最初の事前要件のファイル名になる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> A B C</span>
    echo <span class="ch">$&lt;</span></code></pre></div>
<p>この<code>Makefile</code>を実行すると以下のように出力される。</p>
<pre><code>$ make
echo A</code></pre>
<h4 id="すべての事前要件"><code>$^</code> すべての事前要件</h4>
<p><code>$^</code>はすべての事前要件のファイル名が空白区切りされたものになる</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> A B C</span>
    echo <span class="ch">$^</span></code></pre></div>
<p>この<code>Makefile</code>を実行すると以下のように出力される。</p>
<pre><code>$ make
echo A B C</code></pre>
<h4 id="自動変数の組み合わせ">自動変数の組み合わせ</h4>
<p>例えば<code>ターゲット</code>を生成するために<code>事前要件</code>と<code>ターゲット</code>のファイル名をレシピに書く場合、</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> prerequisite</span>
    cat prerequisite &gt; target</code></pre></div>
<p>と書く代わりに、</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">target :</span><span class="dt"> prerequisite</span>
    cat <span class="ch">$&lt;</span> &gt; <span class="ch">$@</span></code></pre></div>
<p>と書ける。</p>
<h3 id="phonyターゲット">PHONYターゲット</h3>
<p>PHONYターゲットとは、ファイル名を意味せず、単にレシピを実行するターゲット名としてのみ機能するターゲットのことだ。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hi :</span>
    echo hi

<span class="dv">hello :</span>
    echo hello</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
echo hi
hi
$ make hi
echo hi
hi
$ make hello
echo hello
hello</code></pre>
<p><code>make</code>を引数を付けずに実行すると、一番上に書かれたルールが実行される。引数としてターゲットを指定すると、そのターゲットのルールと、依存するルールが実行される。</p>
<p>ただし、ターゲットと同じファイル名が存在すると、ルールは実行されない。</p>
<pre><code>$ touch hello
$ make hello
make: &#39;hello&#39; is up to date.</code></pre>
<p>GNU Makeはこの問題に対処するため、<code>.PHONY</code>ターゲットという特殊な機能がある。これはPHONYターゲットを<code>.PHONY</code>ターゲットの事前要件とすることで、ターゲットと同じファイル名の存在の有無にかかわらずルールを実行させられる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hello :</span>
    echo hello

<span class="ot">.PHONY :</span><span class="dt"> hello</span></code></pre></div>
<p>PHONYターゲットはコンパイルしたプログラムの実行や削除に使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">hello :</span><span class="dt"> hello.cpp</span>
    g++ -o <span class="ch">$@</span> <span class="ch">$&lt;</span>

<span class="dv">run :</span><span class="dt"> hello</span>
    ./hello

<span class="dv">clean :</span>
    rm -rf ./hello

<span class="ot">.PHONY :</span><span class="dt"> run clean</span></code></pre></div>
<h2 id="入門用の環境構築">入門用の環境構築</h2>
<p>以上を踏まえて、C++入門用の環境構築をしてこの章のまとめとする。</p>
<p>今回構築する環境のファイル名とその意味は以下のとおり。</p>
<dl>
<dt><code>main.cpp</code></dt>
<dd>C++のコードを書く <code>all.h</code>
</dd>
<dd>標準ライブラリのヘッダーファイルを書く <code>all.h.gch</code>
</dd>
<dd>コンパイル済みヘッダー <code>program</code>
</dd>
<dd>実行可能ファイル <code>Makefile</code>
</dd>
<dd>GNU Makeのルールを書く
</dd>
</dl>
<p>使い方は以下のとおり。</p>
<dl>
<dt><code>make</code></dt>
<dd>コンパイルする <code>make run</code>
</dd>
<dd>コンパイルして実行 <code>make clean</code>
</dd>
<dd>コンパイル結果を削除
</dd>
</dl>
<p>GCCに与えるコンパイラーオプションを変数にまとめる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dt">gcc_options </span><span class="ch">=</span><span class="st"> -std=c++17 -Wall --pedantic-error</span></code></pre></div>
<p>言語はC++17、すべての警告を有効にし、規格準拠ではないコードはエラーとする。</p>
<p>プログラムをコンパイルする部分は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program :</span><span class="dt"> main.cpp all.h all.h.gch</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -include all.h <span class="ch">$&lt;</span> -o <span class="ch">$@</span>

<span class="dv">all.h.gch :</span><span class="dt"> all.h</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -x c++-header -o <span class="ch">$@</span> <span class="ch">$&lt;</span></code></pre></div>
<p>実行可能ファイル<code>program</code>と、コンパイル済みヘッダー<code>all.h.gch</code>をコンパイルするルールだ。</p>
<p>PHONYターゲットは以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">run :</span><span class="dt"> program</span>
    ./program

<span class="dv">clean :</span>
    rm -f ./program
    rm -f ./all.h.gch

<span class="ot">.PHONY :</span><span class="dt"> run clean</span></code></pre></div>
<p><code>make</code>でコンパイル。<code>make run</code>で実行。<code>make clean</code>でコンパイル結果の削除。</p>
<p><code>Makefile</code>全体は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dt">gcc_options </span><span class="ch">=</span><span class="st"> -std=c++17 -Wall --pedantic-errors</span>

<span class="dv">program :</span><span class="dt"> main.cpp all.h all.h.gch</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -include all.h <span class="ch">$&lt;</span> -o <span class="ch">$@</span>

<span class="dv">all.h.gch :</span><span class="dt"> all.h</span>
    g++ <span class="ch">$(</span><span class="dt">gcc_options</span><span class="ch">)</span> -x c++-header -o <span class="ch">$@</span> <span class="ch">$&lt;</span>

<span class="dv">run :</span><span class="dt"> program</span>
    ./program

<span class="dv">clean :</span>
    rm -f ./program
    rm -f ./all.h.gch

<span class="ot">.PHONY :</span><span class="dt"> run clean</span></code></pre></div>
<h1 id="cヒッチハイクガイド">C++ヒッチハイクガイド</h1>
<p>プログラミング言語の個々の機能の解説を理解するためには、まず言語の全体像を掴まなければならない。この章ではC++のさまざまなコードをひと通り観光していく。ここではコードの詳細な解説はしない。</p>
<h2 id="最小のコード">最小のコード</h2>
<p>以下はC++の最小のコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){}</code></pre></div>
<p>暗号のようなコードで訳がわからないが、これが最小のコードだ。<code>main</code>というのは<code>main関数</code>のことだ。C++ではプログラムの実行は<code>main</code>関数から始まる。</p>
<p>ソースコードにコメントを記述して、もう少しわかりやすく書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>     <span class="co">// 関数の戻り値の型</span>
main    <span class="co">// 関数名</span>
()      <span class="co">// 関数の引数</span>
{       <span class="co">// 関数の始まり</span>
        <span class="co">// 実行される処理</span>
}       <span class="co">// 関数の終わり</span></code></pre></div>
<p><code>//</code>から行末まではコメントだ。コメントには好きなことを書くことができる。</p>
<p>このコードと1つ前のコードは、コメントの有無を別にすれば何の違いもない。このコードで使っている、<code>int</code>とか<code>main</code>とか記号文字の1つ1つをトークン(token)と呼ぶ。C++ではトークンの間に空白文字や改行文字をいくら使ってもよい。</p>
<p>なので、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){ }</code></pre></div>
<p>と書くこともできるし、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>    main    (    )    {   }</code></pre></div>
<p>と書くこともできるし、紙に印刷する都合上とても読みづらくなるかもしれないが</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>
main
(
)
{
}</code></pre></div>
<p>と書くこともできる。</p>
<p>ただし、トークンの途中で空白文字や改行文字を使うことはできない。以下のコードは間違っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i
nt ma in(){}</code></pre></div>
<h2 id="標準出力">標準出力</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// helloと改行を出力するプログラム</span>
<span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
}</code></pre></div>
<p>標準出力はプログラムの基本だ。C++で標準出力する方法はいくつもあるが、<code>&lt;iostream&gt;</code>ライブラリを利用するものが最も簡単だ。</p>
<p><code>std::cout</code>は標準出力を使うためのライブラリだ。</p>
<p><code>&lt;&lt;</code>は<code>operator &lt;&lt;</code>という演算子だ。C++では演算子にも名前が付いていて、例えば<code>+</code>は<code>operator +</code>となる。<code>&lt;&lt;</code>も演算子の一種だ。</p>
<p><code>&quot;hello&quot;s</code>というのは文字列で、二重引用符で囲まれた中の文字列が標準出力に出力される。</p>
<p>セミコロン<code>;</code>は文の区切り文字だ。C++では文の区切りは明示的にセミコロンを書く必要がある。ほかの言語では改行文字を文脈から判断して文の区切りとみなすこともあるが、C++では明示的に文の区切り文字としてセミコロンを書かなければならない。</p>
<p>セミコロンを書き忘れるとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー！　セミコロンがない</span>
    std::cout &lt;&lt; <span class="st">&quot;error&quot;</span>s
}</code></pre></div>
<p>複数の文を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;one &quot;</span>s ;
    std::cout &lt;&lt; <span class="st">&quot;two &quot;</span>s ;
    std::cout &lt;&lt; <span class="st">&quot;three &quot;</span>s ;
}</code></pre></div>
<p>C++はほかの多くの言語と同じように、逐次実行される。つまり、コードは書いた順番に実行される。そして標準出力のような外部への副作用は、実行された順番で出力される。このコードを実行した結果は以下のとおり。</p>
<pre><code>one two three </code></pre>
<p><code>&quot;three two one &quot;</code>や<code>&quot;two one three &quot;</code>のような出力結果にはならない。</p>
<p>C++を含む多くの言語で<code>a + b + c</code>と書けるように、<code>operator &lt;&lt;</code>も<code>a &lt;&lt; b &lt;&lt; c</code>と書ける。<code>operator &lt;&lt;</code>で標準出力をするには、左端は<code>std::cout</code>でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;aaa&quot;</span>s &lt;&lt; <span class="st">&quot;bbb&quot;</span>s &lt;&lt; <span class="st">&quot;ccc&quot;</span>s ;
}</code></pre></div>
<p>出力は<code>aaabbbccc</code>となる。</p>
<h2 id="文字列">文字列</h2>
<p>二重引用符で囲まれた文字列を、文字どおり<code>文字列</code>という。文字列には末尾に<code>s</code>が付くものと付かないものがある。これには違いがあるのだが、わからないうちは<code>s</code>を付けておいた方が便利だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// これは文字列</span>
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
    <span class="co">// これも文字列、ただし不便</span>
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>文字列リテラルの中にバックスラッシュを書くと、エスケープシーケンスとして扱われる。最もよく使われるのは改行文字を表す<code>\n</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;aaa</span><span class="ch">\n</span><span class="st">bbb</span><span class="ch">\n</span><span class="st">ccc&quot;</span>s ;
}</code></pre></div>
<p>これは以下のように出力される。</p>
<pre><code>aaa
bbb
ccc</code></pre>
<p>バックスラッシュを文字列で使いたい場合は<code>\\</code>と書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\\</span><span class="st">n is a new-line.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>文字列は演算子<code>operator +</code>で「足す」ことができる。「文字列を足す」というのは、「文字列を結合する」という意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s + <span class="st">&quot;world&quot;</span>s ;
}</code></pre></div>
<h2 id="整数と浮動小数点数">整数と浮動小数点数</h2>
<p><code>iostream</code>は文字列のほかにも、整数や浮動小数点数を出力できる。さっそく試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; <span class="st">&quot;Integer: &quot;</span>s &lt;&lt; <span class="dv">42</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;Floating Point: &quot;</span>s &lt;&lt; <span class="fl">3.14</span> ;
}</code></pre></div>
<p><code>-123</code>や<code>0</code>や<code>123</code>といった数値を整数という。<code>3.14</code>のような数値を浮動小数点数という。</p>
<p>数値を扱えるのだから、計算をしてみたいところだ。C++は整数同士の演算子として、四則演算(<code>+-*/</code>)や剰余(<code>%</code>)をサポートしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; <span class="dv">3</span> + <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> - <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="dv">3</span> * <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="dv">3</span> / <span class="dv">5</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="dv">3</span> % <span class="dv">5</span> ;
}</code></pre></div>
<p>演算子は組み合わせて使うこともできる。その場合、演算子<code>*/%</code>は演算子<code>+-</code>よりも優先される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 7</span>
    std::cout &lt;&lt; <span class="dv">1</span> + <span class="dv">2</span> * <span class="dv">3</span> ;
}</code></pre></div>
<p>この場合、まず<code>2*3</code>が計算され6となり、<code>1+6</code>が計算され<code>7</code>となる。</p>
<p><code>1+2</code>の方を先に計算したい場合、括弧<code>()</code>で囲むことにより、計算の優先度を変えることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 9</span>
    std::cout &lt;&lt; (<span class="dv">1</span> + <span class="dv">2</span>) * <span class="dv">3</span> ;
}</code></pre></div>
<p>これは<code>1+2</code>が先に計算され<code>3</code>となり、<code>3*3</code>が計算され<code>9</code>となる。</p>
<p>浮動小数点数同士でも四則演算ができる。剰余はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; <span class="fl">3.5</span> + <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> - <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s
        &lt;&lt; <span class="fl">3.5</span> * <span class="fl">7.11</span> &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; <span class="fl">3.5</span> / <span class="fl">7.11</span> ;
}</code></pre></div>
<p>では整数と浮動小数点数を演算した場合どうなるのだろう。さっそく試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="dv">1</span> + <span class="fl">0.1</span> ;
}</code></pre></div>
<p>結果は<code>1.1</code>だ。整数と浮動小数点数を演算した結果は浮動小数点数になる。</p>
<p>そういえばC++には文字列もあるのだった。文字列と文字列は足すことができる。数値と数値も足すことができる。では数値と文字列を足すとどうなるのだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span>s ;
}</code></pre></div>
<p>この結果はエラーになる。</p>
<p>いや待て、C++には末尾に<code>s</code>を付けない文字列もあるのだった。これも試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="dv">1</span> + <span class="st">&quot;234&quot;</span> ;
}</code></pre></div>
<p>結果はなんと<code>34</code>になるではないか。C++では謎の数学により<code>1 + &quot;234&quot; = &quot;34&quot;</code>であることが判明した。この謎はいずれ解き明かすとして、いまは文字列には必ず末尾に<code>s</code>を付けることにしよう。その方が安全だ。</p>
<h2 id="変数variable">変数(variable)</h2>
<p>さあどんどんプログラミング言語によくある機能を見ていこう。次は変数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数の変数</span>
    <span class="kw">auto</span> answer = <span class="dv">42</span> ;
    std::cout &lt;&lt; answer &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="co">// 浮動小数点数の変数</span>
    <span class="kw">auto</span> pi = <span class="fl">3.14</span> ;
    std::cout &lt;&lt; pi &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 文字列の変数</span>
    <span class="kw">auto</span> question = <span class="st">&quot;Life, The Universe, and Everything.&quot;</span>s ;
    std::cout &lt;&lt; question ;
}</code></pre></div>
<p>変数はキーワード<code>auto</code>に続いて変数名を書き、<code>=</code>に続いて値を書くことで宣言できる。変数の宣言は文なので、文末にはセミコロンが必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> 変数名 = 値 ;</code></pre></div>
<p><code>変数名</code>はキーワード、アンダースコア(<code>_</code>)で始まる名前、アンダースコア2つ(<code>__</code>)を含む名前以外は自由に名付けることができる。</p>
<p>変数の最初の値は、<code>= 値</code>の代わりに<code>(値)</code>や<code>{値}</code>と書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">1</span> ;
    <span class="kw">auto</span> b(<span class="dv">2</span>) ;
    <span class="kw">auto</span> c{<span class="dv">3</span>} ;
}</code></pre></div>
<p>この<code>=</code>, <code>()</code>, <code>{}</code>による変数の初期値の指定を、<code>初期化</code>という。</p>
<p>変数は使う前に宣言しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、名前xは宣言されていない</span>
    std::cout &lt;&lt; x ;
    <span class="kw">auto</span> x = <span class="dv">123</span> ;
}</code></pre></div>
<p>変数の値は初期化したあとにも演算子<code>=</code>で変更できる。これを<code>代入</code>という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 変数の宣言</span>
    <span class="kw">auto</span> x
    <span class="co">// 初期化</span>
    = <span class="dv">123</span> ;

    <span class="co">// 123</span>
    std::cout &lt;&lt; x ;

    <span class="co">// 代入</span>
    x = <span class="dv">456</span> ;

    <span class="co">// 456</span>
    std::cout &lt;&lt; x ;

    <span class="co">// もう一度代入</span>
    x = <span class="dv">789</span> ;
    <span class="co">// 789</span>
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p>代入演算子<code>operator =</code>は左辺に変数名を、右辺に代入する値を書く。面白いこととして、右辺には代入する変数名そのものを書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">10</span> ;
    x = x + <span class="dv">5</span> ;

    <span class="co">// 15</span>
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p><code>operator =</code>は「代入」という意味で、「等号」という意味ではないからだ。<code>x=x+5</code>は、「<code>x</code>と<code>x+5</code>は等しい」という独創的な数学上の定義ではなく、「変数<code>x</code>に代入前の変数<code>x</code>の値に5を加えた数を代入する」という意味だ。</p>
<p>変数のいまの値に対して演算した結果を変数に代入するという処理はとてもよく使うので、C++には<code>x = x + a</code>と同じ意味で使える演算子、<code>operator +=</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="co">// x = x + 5と同じ</span>
    x += <span class="dv">5</span> ;
}</code></pre></div>
<p><code>operator +=</code>と同様に、<code>operator -=</code>, <code>operator *=</code>, <code>operator /=</code>, <code>operator %=</code>もある。</p>
<p>C++の変数は、専門用語を使うと「静的型付け」になる。静的型付けと対比されるのが「動的型付け」だ。もっと難しく書くと、動的型付け言語の変数は、C++で言えば型情報付きの<code>void *</code>型の変数のような扱いを受ける。</p>
<p>C++の変数には<code>型</code>がある。<code>型</code>というのは値の種類を表す情報のことだ。</p>
<p>例えば、以下は変数が動的型付けの言語JavaScriptのコードだ。</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> x <span class="op">=</span> <span class="dv">1</span> <span class="op">;</span>
x <span class="op">=</span> <span class="st">&quot;hello&quot;</span> <span class="op">;</span>
x <span class="op">=</span> <span class="dv">2</span> <span class="op">;</span></code></pre></div>
<p>JavaScriptではこのコードは正しい。変数<code>x</code>は数値型であり、文字列型に代わり、また数値型に戻る。</p>
<p>C++ではこのようなコードは書けない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="co">// エラー</span>
    x = <span class="st">&quot;hello&quot;</span>s ;
    x = <span class="dv">2</span> ;
}</code></pre></div>
<p>C++では、変数<code>x</code>は整数型であり、文字列型に変わることはない。整数型の変数に文字列型を代入しようとするとエラーとなる。</p>
<p>C++では型に名前が付いている。整数型は<code>int</code>、浮動小数点数型は<code>double</code>、文字列型は<code>std::string</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// iはint型</span>
    <span class="kw">auto</span> i = <span class="dv">123</span> ;
    <span class="co">// dはdouble型</span>
    <span class="kw">auto</span> d = <span class="fl">1.23</span> ;
    <span class="co">// sはstd::string型</span>
    <span class="kw">auto</span> s = <span class="st">&quot;123&quot;</span>s ;
}</code></pre></div>
<p>実は変数の宣言で<code>auto</code>と書く代わりに、具体的な型を書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i           = <span class="dv">123</span> ;
    <span class="dt">double</span> d        = <span class="fl">1.23</span> ;
    std::string s   = <span class="st">&quot;123&quot;</span>s ;
}</code></pre></div>
<p>整数型(<code>int</code>)と浮動小数点数型(<code>double</code>)はそれぞれお互いの型の変数に代入できる。ただし、変数の型は変わらない。単に一方の型の値がもう一方の型の値に変換されるだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 浮動小数点数型を整数型に変換</span>
    <span class="dt">int</span> a = <span class="fl">3.14</span> ;
    <span class="co">// 3</span>
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 整数型を浮動小数点数型に変換</span>
    <span class="dt">double</span> d = <span class="dv">123</span> ;
    <span class="co">// 123</span>
    std::cout &lt;&lt; d ;
}</code></pre></div>
<p>浮動小数点数型を整数型に変換すると、小数部が切り捨てられる。この場合、<code>3.14</code>の小数部<code>0.14</code>が切り捨てられ<code>3</code>となる。<code>0.9999</code>も小数部が切り捨てられ<code>0</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="fl">0.9999</span> ;
    <span class="co">// 0</span>
    std::cout &lt;&lt; i ;
}</code></pre></div>
<p>整数型を浮動小数点数型に変換すると、値を正確に表現できる場合はその値になる。正確に表現できない場合は近い値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> d = <span class="dv">1234567890</span> ;
    <span class="co">// 正確に表現できるかどうかわからない</span>
    std::cout &lt;&lt; d ;
}</code></pre></div>
<p>整数型と浮動小数点数型の挙動についてはあとの章で詳しく解説する。また、これ以外にも型はいくらでもあるし、読者が新しい型を作り出すこともできる。これもあとの章で詳しく解説する。</p>
<h2 id="関数function">関数(function)</h2>
<p>「変数ぐらい知っている。さっさと教えてもらいたい。どうせC++の関数は書きづらいのだろう」と考える読者の皆さん、お待たせしました。こちらがC++の関数でございます。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 関数</span>
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> x)
    {
        std::cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    } ;

    <span class="co">// 関数呼び出し</span>
    print(<span class="dv">123</span>) ;
    print(<span class="fl">3.14</span>) ;
    print(<span class="st">&quot;hello&quot;</span>) ;
}</code></pre></div>
<p>C++では関数も変数として扱える。<code>auto print =</code>までは変数だ。変数の初期化として関数を書いている。より正確にはラムダ式と呼ばれる関数を値として書くための文法だ。</p>
<p>ラムダ式は以下のような文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[] <span class="co">// ラムダ式導入部</span>
() <span class="co">// 引数</span>
{} <span class="co">// 本体</span></code></pre></div>
<p>ラムダ式は<code>[]</code>で始まり、<code>()</code>の中に引数を書き、<code>{}</code>の中の文が実行される。</p>
<p>例えば以下は引数を2回標準出力する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> twice = [](<span class="kw">auto</span> x)
    {
        std::cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    } ;

    twice(<span class="dv">5</span>) ;
}</code></pre></div>
<p>引数は<code>auto 引数名</code>で受け取れる。引数を複数取る場合は、カンマ<code>,</code>で区切る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print_two = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )
    {
        std::cout &lt;&lt; x &lt;&lt; <span class="st">&quot; &quot;</span>s &lt;&lt; y &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    } ;

    print_two( <span class="dv">1</span>, <span class="dv">2</span> ) ;
    print_two( <span class="st">&quot;Pi is&quot;</span>, <span class="fl">3.14</span> ) ;
}</code></pre></div>
<p>引数を取らないラムダ式を書く場合は、単に<code>()</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> no_args = []()
    {
        std::cout &lt;&lt; <span class="st">&quot;Nothing.</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    } ;

    no_args() ;
}</code></pre></div>
<p>関数は演算子<code>operator ()</code>を関数の直後に書いて呼び出す。これが演算子であるというのは少し不思議な感じがするが、C++では紛れもなく演算子だ。<code>operator +</code>とか<code>operator -</code>などと同じ演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 何もしない関数</span>
    <span class="kw">auto</span> func = [](){} ;

    <span class="co">// operator ()の適用</span>
    func() ;
    <span class="co">// これもoperator ()</span>
    func    (   ) ;
}</code></pre></div>
<p>演算子<code>operator ()</code>は、ラムダ式そのものに対して適用することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 変数fをラムダ式で初期化</span>
    <span class="kw">auto</span> f = [](){} ;
    <span class="co">// 変数fを関数呼び出し</span>
    f() ;

    <span class="co">// ラムダ式を関数呼び出し</span>
    [](){}() ;
}</code></pre></div>
<p>このコードを見ると、<code>operator ()</code>が単なる演算子であることがよくわかるだろう。<code>[](){}</code>がラムダ式でその直後の<code>()</code>が関数呼び出し演算子だ。</p>
<p>関数は値を返すことができる。関数から値を返すには、<code>return文</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> plus = []( <span class="kw">auto</span> x, <span class="kw">auto</span> y )
        { <span class="kw">return</span> x + y ; } ;

    std::cout
        &lt;&lt; plus( <span class="dv">1</span>, <span class="dv">2</span> ) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; plus( <span class="fl">1.5</span>, <span class="fl">0.5</span> ) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; plus( <span class="st">&quot;123&quot;</span>s, <span class="st">&quot;456&quot;</span>s) ;
}</code></pre></div>
<p>関数は<code>return</code>文を実行すると処理を関数の呼び出し元に返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []()
    {
        std::cout &lt;&lt; <span class="st">&quot;f is called.</span><span class="ch">\n</span><span class="st">&quot;</span> ;
        <span class="kw">return</span> <span class="dv">0</span> ; <span class="co">// ここで処理が戻る</span>
        std::cout &lt;&lt; <span class="st">&quot;f returned zero.</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    } ;

    <span class="kw">auto</span> result = f() ;
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make
f is called.</code></pre>
<p><code>return</code>文以降の文が実行されていないことがわかる。</p>
<h2 id="本当の関数">本当の関数</h2>
<p>実はラムダ式は本当のC++の<code>関数</code>ではない。本当の<code>関数</code>はとても書きづらいので心して読むべきだ。</p>
<p>読者は本書の冒頭で使った<code>main関数</code>という言葉を覚えているだろうか。覚えていないとしても、サンプルコードに必ずと言っていいほど出てくる<code>main</code>という名前は気になっていたことだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main(){}</code></pre></div>
<p>これを見ると、聡明な読者はラムダ式と似通ったところがあることに気付くだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[](){}</code></pre></div>
<p>末尾の<code>(){}</code>が同じだ。これは同じ意味だ。<code>()</code>は関数の引数で、<code>{}</code>は関数の本体だ。</p>
<p>では残りの部分はどうだろうか。<code>int</code>は関数の戻り値の型、<code>main</code>は関数の名前だ。</p>
<p>C++の本当の関数は以下のような文法で定義される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>     <span class="co">// 戻り値の型</span>
main    <span class="co">// 関数名</span>
()      <span class="co">// 関数の引数</span>
{}      <span class="co">// 関数の本体</span></code></pre></div>
<p>試しに、<code>int</code>型の引数を2つ取り足して返す関数<code>plus</code>を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> plus( <span class="dt">int</span> x, <span class="dt">int</span> y )
{
    <span class="kw">return</span> x + y ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = plus( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<p>では次に、<code>double</code>型の引数を2つ取り足して返す関数<code>plus</code>を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> plus( <span class="dt">double</span> x, <span class="dt">double</span> y )
{
    <span class="kw">return</span> x + y ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = plus( <span class="fl">1.0</span>, <span class="fl">2.0</span> ) ;
}</code></pre></div>
<p>最後の<code>std::string</code>型の引数を2つ取り足して返す関数<code>plus</code>は読者への課題とする。</p>
<p>これがC++の本当の関数だ。C++の関数では、型をすべて明示的に書かなければならない。型を間違えるとエラーだ。</p>
<p>しかも、C++の関数は、戻り値の型を正しく返さなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f()
{
    <span class="co">// エラー、return文がない</span>
}</code></pre></div>
<p>もし、何も値を返さない関数を書く場合は、どの値でもないという特別な型、<code>void</code>型を関数の戻り値の型として書かなければならないという特別なルールまである。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="co">// OK</span>
}</code></pre></div>
<p>ただし、戻り値の型については、具体的な型の代わりに<code>auto</code>を書くこともできる。その場合、<code>return</code>文で同じ型さえ返していれば、気にする必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// void</span>
<span class="kw">auto</span> a() { }
<span class="co">// int</span>
<span class="kw">auto</span> b() { <span class="kw">return</span> <span class="dv">0</span> ; }
<span class="co">// double</span>
<span class="kw">auto</span> c() { <span class="kw">return</span> <span class="fl">0.0</span> ; }
<span class="co">// std::string</span>
<span class="kw">auto</span> d() { <span class="kw">return</span> <span class="st">&quot;&quot;</span>s ; }

<span class="co">// エラー</span>
<span class="co">// return文の型が一致しない。</span>
<span class="kw">auto</span> e()
{
    <span class="kw">return</span> <span class="dv">0</span> ;
    <span class="kw">return</span> <span class="fl">0.0</span> ;
}</code></pre></div>
<h1 id="デバッグコンパイルエラーメッセージの読み方">デバッグ：コンパイルエラーメッセージの読み方</h1>
<p>やれやれ疲れた。この辺でひと休みして、デバッグについて考えよう。まずはコンパイルエラーについてだ。</p>
<p>プログラムにはさまざまなバグがあるが、コンパイルエラーは最も簡単なバグだ。というのも、プログラムのバグの存在が実行前に発覚したわけだから、手間が省ける。もしコンパイルエラーにならない場合、実行した結果から、バグがあるかどうかを判断しなければならない。</p>
<p>読者の中には、せっかく書いたソースコードをコンパイルしたらコンパイルエラーが出たので、運が悪かったとか、失敗したとか、怒られてつらい気持ちになったなどと感じることがあるかもしれない。しかしそれは大違いだ。コンパイラーによって読者はプログラムを実行することなくバグが発見できたのだから、読者は運が良かった、大成功した、褒められて最高の気持ちになったと感じるべきなのだ。</p>
<p>さあ皆さんご一緒に、</p>
<ul>
<li>コンパイルエラーは普通</li>
<li>コンパイルエラーが出たらありがとう</li>
<li>コンパイルエラーが出たら大喜び</li>
</ul>
<p>熟練のプログラマーは自分の書いたコードがコンパイルエラーを出さずに一発でコンパイルが通った場合、逆に不安になるくらいだ。</p>
<p>もしバグがあるのにコンパイルエラーが出なければ、バグの存在に気が付かないまま、読者の書いたソフトウェアは広く世の中に使われ、10年後、20年後に最もバグが発見されてほしくない方法で発見されてしまうかもしれない。すなわち、セキュリティ上問題となる脆弱性という形での発覚だ。しかし安心してほしい。いま読者が出したコンパイルエラーによって、そのような悲しい未来の可能性は永久に排除されたのだ。コンパイルエラーはどんどん出すとよい。</p>
<p>コンパイルエラーの原因は2つ。</p>
<ol style="list-style-type: decimal">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
</ol>
<p>3つだった。コンパイルエラーの原因は3つ。</p>
<ol style="list-style-type: decimal">
<li>文法エラー</li>
<li>意味エラー</li>
<li>コンパイラーのバグ</li>
<li>コンピューターの故障</li>
</ol>
<p>4つだった。ただ、3.と4.はめったにないから無視してよい。</p>
<h2 id="文法エラー">文法エラー</h2>
<p>文法エラーとは、C++というプログラミング言語の文法に従っていないエラーのことだ。これはC++として解釈できないので、当然エラーになる。</p>
<p>よくある文法エラーとしては、文末のセミコロンを打ち忘れたものがある。例えば以下のコードには間違いがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> + <span class="dv">1</span> 
    <span class="kw">auto</span> y = x + <span class="dv">1</span> ;
}</code></pre></div>
<p>これをコンパイルすると以下のようにコンパイルエラーメッセージが出力される。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~
main.cpp:3:10: warning: unused variable ‘x’ [-Wunused-variable]
     auto x = 1 + 1
          ^
Makefile:4: recipe for target &#39;program&#39; failed
make: *** [program] Error 1</code></pre>
<p>コンパイラーのメッセージを読み慣れていない読者はここで考えることを放棄してコンピューターの電源を落とし家を出て街を徘徊し夕日を見つめて人生、宇宙、すべてについての究極の質問への答えを模索してしまうことだろう。</p>
<p>しかし恐れるなかれ。コンパイラーのエラーメッセージを読み解くのは難しくない。</p>
<p>まず最初の2行を見てみよう。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program</code></pre>
<p>1行目はシェルに<code>make</code>を実行させるためのコマンド、2行目は<code>make</code>が実行したレシピの中身だ。これはコンパイラーによるメッセージではない。</p>
<p>3行目からはコンパイラーによる出力だ。</p>
<pre><code>main.cpp: In function ‘int main()’:</code></pre>
<p>コンパイラーはソースファイル<code>main.cpp</code>の中の、<code>int main()</code>という関数について、特に言うべきことがあると主張している。</p>
<p>言うべきこととは以下だ。</p>
<pre><code>main.cpp:4:5: error: expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~~</code></pre>
<p>GCCというコンパイラーのエラーメッセージは、以下のフォーマットを採用している。</p>
<pre><code>ソースファイル名:行番号:列番号: メッセージの種類: メッセージの内容</code></pre>
<p>ここでのメッセージの種類は<code>error</code>、つまりこのメッセージはエラーを伝えるものだ。</p>
<p>ソースファイル名は<code>main.cpp</code>、つまりエラーは<code>main.cpp</code>の中にあるということだ。</p>
<p>行番号というのは、最初の行を1行目とし、改行ごとにインクリメントされていく。今回のソースファイルの場合、以下のようになる。</p>
<pre><code>1 int main()
2 {
3     auto x = 1 + 1 
4     auto y = x + 1 ;
5 }</code></pre>
<p>もし読者が素晴らしいテキストエディターであるVimを使っている場合、<code>:set nu</code>すると行番号を表示できる。</p>
<p>その上でエラーメッセージの行番号を確認すると<code>4</code>とある。つまりコンパイラーは4行目に問題があると考えているわけだ。</p>
<p>4行目を確認してみよう。</p>
<pre><code>    auto y = x + 1 ;</code></pre>
<p>何の問題もないように見える。さらにエラーメッセージを読んでみよう。</p>
<p>列番号が<code>5</code>となっている。列番号というのは、行頭からの文字数だ。最初の文字を1文字目とし、文字ごとにインクリメントされていく。</p>
<pre><code>123456789...
    auto y = x + 1 ;</code></pre>
<p>4行目は空白文字を4つ使ってインデントしているので、<code>auto</code>の<code>a</code>の列番号は<code>5</code>だ。ここに問題があるのだろうか。何も問題がないように見える。</p>
<p>この謎を解くためには、メッセージの内容を読まなければならない。</p>
<pre><code>expected ‘,’ or ‘;’ before ‘auto’
     auto y = x + 1 ;
     ^~~</code></pre>
<p>これは日本語に翻訳すると以下のようになる。</p>
<pre><code>‘auto’の前に&#39;,&#39;か&#39;;&#39;があるべき
     auto y = x + 1 ;
     ^~~</code></pre>
<p>1行目はエラー内容をテキストで表現したものだ。これによると、<code>'auto'</code>の前に<code>','</code>か<code>';'</code>があるべきとあるが、やはりまだわからない。</p>
<p>2行目は問題のある箇所のソースコードを部分的に抜粋したもので、3行目はそのソースコードの問題のある文字を視覚的にわかりやすく示しているものだ。</p>
<p>ともかく、コンパイラーの指示に従って<code>'auto'</code>の前に<code>','</code>を付けてみよう。</p>
<pre><code>    ,auto y = x + 1 ;</code></pre>
<p>これをコンパイルすると、また違ったエラーメッセージが表示される。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:4:6: error: expected unqualified-id before ‘auto’
     ,auto y = x + 1 ;
      ^~~~</code></pre>
<p>では<code>';'</code>ならばどうか。</p>
<pre><code>    ;auto y = x + 1 ;</code></pre>
<p>これはコンパイルが通るようだ。</p>
<p>しかしなぜこれでコンパイルが通るのだろう。そのためには、コンパイラーが問題だとした行の1つ上の行を見る必要がある。</p>
<pre><code>    auto x = 1 + 1
    auto y = x + 1 ;</code></pre>
<p>コンパイラーにとって、改行は空白文字と同じくソースファイル中の意味のあるトークン(キーワードや名前や記号)を区切る文字でしかない。コンパイラーにとって、このコードは実質以下のように見えている。</p>
<pre><code>auto x=1+1 auto y=x+1;</code></pre>
<p><code>&quot;1 auto&quot;</code>というのは文法エラーだ。なのでコンパイラーは文法エラーが発覚する最初の文字である<code>'auto'</code>の<code>'a'</code>を指摘したのだ。</p>
<p>人間にとって自然になるように修正すると、コンパイラーが指摘した行の1つ上の行の行末に<code>';'</code>を追加すべきだ。</p>
<pre><code>    auto x = 1 + 1 ;
    auto y = x + 1 ;</code></pre>
<p>さて、問題自体は解決したわけだが、残りのメッセージも見ていこう。</p>
<pre><code>main.cpp:3:10: warning: unused variable ‘x’ [-Wunused-variable]
     auto x = 1 + 1</code></pre>
<p>これはコンパイラーによる警告メッセージだ。警告メッセージについて詳しくは、デバッグ：警告メッセージの章で解説する。</p>
<pre><code>Makefile:4: recipe for target &#39;program&#39; failed
make: *** [program] Error 1</code></pre>
<p>これはGNU Makeによるメッセージだ。GCCがソースファイルを正しくコンパイルできず、実行が失敗したとエラーを返したので、レシピの実行が失敗したことを伝えるメッセージだ。</p>
<p>プログラムはどうやってエラーを通知するのか。<code>main</code>関数の戻り値によってだ。<code>main</code>関数は関数であるので、戻り値がある。<code>main</code>関数の戻り値は<code>int</code>型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 戻り値の型</span>
<span class="dt">int</span>
<span class="co">// main関数の残りの部分</span>
main() { }</code></pre></div>
<p><code>main</code>関数が何も値を返さない場合、<code>return 0</code>したものとみなされる。<code>main</code>関数が<code>0</code>もしくは<code>EXIT_SUCCESS</code>を返した場合、プログラムの実行の成功を通知したことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 必ず実行が成功したと通知するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="kw">return</span> <span class="dv">0</span> ;
}</code></pre></div>
<p>プログラムの実行が失敗した場合、<code>main</code>関数は<code>EXIT_FAILURE</code>を返すことでエラーを通知できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 必ず実行が失敗したと通知するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="kw">return</span> EXIT_FAILURE ;
}</code></pre></div>
<p><code>EXIT_SUCCESS</code>と<code>EXIT_FAILURE</code>はマクロだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define EXIT_SUCCESS</span>
<span class="ot">#define EXIT_FAILURE</span></code></pre></div>
<p>その中身はC++標準規格では規定されていない。どうしても値を知りたい場合は以下のプログラムを実行してみるとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; <span class="st">&quot;EXIT_SUCCESS: &quot;</span>s &lt;&lt; EXIT_SUCCESS &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;EXIT_FAILURE: &quot;</span>s   &lt;&lt; EXIT_FAILURE ;  
}</code></pre></div>
<p>文法エラーというのは厄介なバグだ。というのも、コンパイラーというのは正しい文法のソースファイルを処理するように作られている。文法を間違えた場合、ソースファイル全体が正しくないということになる。コンパイラーは文法違反に遭遇した場合、なるべく人間がよく間違えそうなパターンをヒューリスティックに指摘することもしている。そのため、エラーメッセージに指摘された行番号と列番号は、必ずしも人間にとっての問題の箇所と一致しない。</p>
<p>もう1つ例を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 引数を3つ取って足して返す関数</span>
    <span class="kw">auto</span> f = [](<span class="kw">auto</span> a, <span class="kw">auto</span> b, <span class="kw">auto</span> c)
    { <span class="kw">return</span> a + b + c ; } ;

    std::cout &lt;&lt; f(<span class="dv">1</span>+(<span class="dv">2</span>*<span class="dv">3</span>),<span class="dv">4-5</span>,<span class="dv">6</span>/(<span class="dv">7-8</span>))) ;
}</code></pre></div>
<p>GCCによるコンパイルエラーメッセージだけ抜粋すると以下のとおり。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:7:40: error: expected ‘;’ before ‘)’ token
     std::cout &lt;&lt; f(1+(2*3),4-5,6/(7-8))) ;
                                        ^</code></pre>
<p>さてさっそく読んでみよう。すでに学んだように、GCCのメッセージのフォーマットは以下のとおりだ。</p>
<pre><code>ソースファイル名:行番号:列番号: メッセージの種類: メッセージの内容</code></pre>
<p>これに当てはめると、問題はソースファイル<code>main.cpp</code>の7行目の40列目にある。</p>
<p>エラーメッセージは、「<code>';'</code>がトークン<code>')'</code>の前にあるべき」だ。</p>
<p>トークン(token)というのは<code>'std'</code>とか<code>'::'</code>とか<code>'cout'</code>といったソースファイルの空白文字で区切られた最小の文字列の単位のことだ。</p>
<p>抜粋されたソースコードに示された問題の箇所、つまり7行目40列目にあるトークンは<code>')'</code>だ。この前に<code>';'</code>が必要とはどういうことだろう。</p>
<p>問題を探るため、7行目のトークンを詳しく分解してみよう。以下は7行目と同じソースコードだが、トークンをわかりやすく分解してある。</p>
<pre><code>std::cout &lt;&lt; // 標準出力
f // 関数名
    ( // 開き括弧
        1+(2*3),    // 第1引数
        4-5,        // 第2引数
        6/(7-8)     // 第3引数
    ) // 開き括弧に対応する閉じ括弧
    ) // ???
    ; // 終端文字</code></pre>
<p>これを見ると、閉じ括弧が1つ多いことがわかる。</p>
<h2 id="意味エラー">意味エラー</h2>
<p>意味エラーとは、ソースファイルは文法的に正しいが、意味的に間違っているコンパイルエラーのことだ。</p>
<p>さっそく例を見ていこう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="fl">1.0</span> % <span class="fl">1.0</span> ;
}</code></pre></div>
<p>このコードをコンパイルすると出力されるエラーメッセージは以下のとおり。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:3:18: error: invalid operands of types ‘double’ and ‘double’ to binary ‘operator%’
     auto x = 1.0 % 1.0 ;
              ~~~~^~~~~</code></pre>
<p>問題の箇所は3行目の18列目、<code>'%'</code>だ。</p>
<p>エラーメッセージは、「二項 <code>'operator%'</code>に対して不適切なオペランドである型<code>'double'</code>と<code>'double'</code>」とある。</p>
<p>前の章を読み直すとわかるとおり、<code>operator %</code>は剰余を計算する演算子だが、この演算子には<code>double</code>型を渡すことはできない。</p>
<p>このコードはどうだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 引数を1つ取る関数</span>
<span class="dt">void</span> f( <span class="dt">int</span> x ) { }

<span class="dt">int</span> main()
{
    <span class="co">// 引数を2つ渡す</span>
    f( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<p>このようなエラーメッセージになる。</p>
<pre><code>main.cpp: In function ‘int main()’:
main.cpp:7:13: error: too many arguments to function ‘void f(int)’
     f( 1, 2 ) ;
             ^
main.cpp:2:6: note: declared here
 void f( int x ) { }
      ^</code></pre>
<p>問題の箇所は7行目。「関数<code>'void f(int)'</code>に対して実引数が多すぎる」とある。<code>関数f</code>は引数を1つしか取らないのに、2つの引数を渡しているのがエラーの原因だ。</p>
<p>2つ目のメッセージはエラーではなくて、エラーを補足説明するための注記(note)メッセージだ。ここで言及している<code>関数f</code>とは、2行目に宣言されていることを説明してくれている。</p>
<p>意味エラーはときとしておぞましいほどのエラーメッセージを生成することがある。例えば以下の一見無害そうなコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="st">&quot;hello&quot;</span>s &lt;&lt; <span class="dv">1</span> ;
}</code></pre></div>
<p>このコードは文法的に正しいが、意味的に間違っているコードだ。このコードをコンパイルすると膨大なエラーメッセージが出力される。しかも問題の行番号特定以外、大して役に立たない。</p>
<h2 id="コンパイラーのバグ">コンパイラーのバグ</h2>
<p>C++コンパイラーもソフトウェアであり、バグがある。コンパイラーにバグがある場合、正しいC++のソースファイルがコンパイルできないことがある。</p>
<p>読者がそのようなコンパイラーの秘孔を突くコードを書くことはまれだ。しかし、もしそのようなコードを偶然にも書いてしまった場合、GCCは、</p>
<pre><code>gcc: internal compiler error: エラー内容
Please submit a full bug report,
with preprocessed source if appropriate.
See &lt;ドキュメントへのファイルパス&gt; for instructions.</code></pre>
<p>のようなメッセージを出力する。</p>
<p>これはGCCのバグなので、見つけた読者は適切な方法でバグ報告をしよう。</p>
<h1 id="条件分岐の果てのレストラン">条件分岐の果てのレストラン</h1>
<p>さてC++の勉強に戻ろう。この章では条件分岐について学ぶ。</p>
<h2 id="複合文">複合文</h2>
<p>条件分岐とループについて学ぶ前に、まず<code>複合文</code>(compound statement)や<code>ブロック</code>(block)と呼ばれている、複数の文をひとまとめにする文について学ばなければならない。</p>
<p>C++では<code>文</code>(statement)が実行される。<code>文</code>については詳しく説明すると長くなるが、<code>';'</code>で区切られたものが<code>文</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 文</span>
    <span class="kw">auto</span> x = <span class="dv">1</span> + <span class="dv">1</span> ;
    <span class="co">// 文</span>
    std::cout &lt;&lt; x ;

    <span class="co">// 空文</span>
    <span class="co">// 実は空っぽの文も書ける。</span>
    ;
}</code></pre></div>
<p>複数の<code>文</code>を<code>{}</code>で囲むことで、1つの文として扱うことができる。これを<code>複合文</code>という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 複合文開始</span>
    {
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    } <span class="co">// 複合文終了</span>

    <span class="co">// 別の複合文</span>
    { std::cout &lt;&lt; <span class="st">&quot;world</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }

    <span class="co">// 空の複合文</span>
    { }
}</code></pre></div>
<p><code>複合文</code>には<code>';'</code>はいらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// ;はいらない</span>
    { }

    <span class="co">// これは空の複合文に続いて</span>
    <span class="co">// 空文があるだけのコード</span>
    { } ;
}</code></pre></div>
<p><code>複合文</code>の中に<code>複合文</code>を書くこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    {{{}}} ;
}</code></pre></div>
<p><code>関数の本体</code>としての一番外側<code>'{}'</code>はこの<code>複合文</code>とは別のものだが、読者はまだ気にする必要はない。</p>
<p><code>複合文</code>は複数の<code>文</code>をひとまとめにして、1つの<code>文</code>として扱えるようにするぐらいの意味しか持っていない。ただし、変数の見え方に影響する。変数は宣言された最も内側の複合文の中でしか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">0</span> ;

    {
        <span class="kw">auto</span> b = <span class="dv">0</span> ;
        {
            <span class="kw">auto</span> c = <span class="dv">0</span> ;
            <span class="co">// cはここまで使える</span>
        }
        <span class="co">// bはここまで使える</span>
    }
    <span class="co">// aはここまで使える</span>
}</code></pre></div>
<p>これを専門用語では<code>変数</code>の<code>寿命</code>とか<code>ブロックスコープ</code>(block-scope)という。</p>
<p>内側のブロックスコープの変数が、外側のブロックスコープの変数と同じ名前を持っていた場合はエラーではない。外側の変数が内側の変数で隠される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;
    {
        <span class="kw">auto</span> x = <span class="dv">1</span> ;
        {
            <span class="kw">auto</span> x = <span class="dv">2</span> ;
            <span class="co">// 2</span>
            std::cout &lt;&lt; x ;
        }
        <span class="co">// 1</span>
        std::cout &lt;&lt; x ;
        x = <span class="dv">42</span> ;
        <span class="co">// 42</span>
        std::cout &lt;&lt; x ;
    }
    <span class="co">// 0</span>
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p>慣れないうちは驚くかもしれないが、多くのプログラミング言語はこのような挙動になっているものだ。</p>
<h2 id="条件分岐">条件分岐</h2>
<p>すでに読者はさまざまな数値計算を学んだ。読者は<code>12345 + 6789</code>の答えや、<code>8073 * 132 / 5</code>の答えを計算できる上、この2つの答えをさらに掛け合わせた結果だって計算できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">12345</span> + <span class="dv">6789</span> ;
    <span class="kw">auto</span> b = <span class="dv">8073</span> * <span class="dv">132</span> / <span class="dv">5</span> ;
    <span class="kw">auto</span> sum = a + b ;

    std::cout
        &lt;&lt; <span class="st">&quot;a=12345 + 6789=&quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;b=8073 * 132 / 5=&quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;a+b=&quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>なるほど、答えがわかった。ところで変数<code>a</code>と変数<code>b</code>はどちらが大きいのだろうか。大きい変数だけ出力したい。この場合は条件分岐を使う。</p>
<p>C++では条件分岐に<code>if文</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">12345</span> + <span class="dv">6789</span> ;
    <span class="kw">auto</span> b = <span class="dv">8073</span> * <span class="dv">132</span> / <span class="dv">5</span> ;


    <span class="kw">if</span> ( a &lt; b )
    {
        <span class="co">// bが大きい</span>
        std::cout &lt;&lt; b ;
    }
    <span class="kw">else</span>
    {
        <span class="co">// aが大きい</span>
        std::cout &lt;&lt; a ;
    }
}</code></pre></div>
<p><code>if文</code>は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> ( 条件 )
文1
<span class="kw">else</span>
文2</code></pre></div>
<p><code>条件</code>が真(<code>true</code>)のときは<code>文1</code>が実行され、偽(<code>false</code>)のときは<code>文2</code>が実行される。</p>
<p><code>else</code>の部分は書かなくてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> ( 条件 )
文1
文2</code></pre></div>
<p>その場合、<code>条件</code>が真のときだけ<code>文1</code>が実行される。条件の真偽にかかわらず<code>文2</code>は実行される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">if</span> ( <span class="dv">2</span> &lt; <span class="dv">1</span> )
        std::cout &lt;&lt; <span class="st">&quot;sentence 1.</span><span class="ch">\n</span><span class="st">&quot;</span> ; <span class="co">// 文1</span>
    std::cout &lt;&lt; <span class="st">&quot;sentence 2.</span><span class="ch">\n</span><span class="st">&quot;</span> ; <span class="co">// 文2</span>
}</code></pre></div>
<p>この例では、<code>2</code>が<code>1</code>より小さい場合は<code>文1</code>が実行される。<code>文2</code>は必ず実行される。</p>
<p>条件次第で複数の文を実行したい場合、<code>複合文</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">if</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )
    {
        std::cout &lt;&lt; <span class="st">&quot;yes!</span><span class="ch">\n</span><span class="st">&quot;</span> ;
        std::cout &lt;&lt; <span class="st">&quot;yes!</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    }
}</code></pre></div>
<p><code>条件</code>とか<code>真偽</code>についてはとてもとても深い話があるのだが、その解説はあとの章に回すとして、まずは以下の比較演算子を覚えよう。</p>
<table>
<thead>
<tr class="header">
<th align="left">演算子</th>
<th align="center">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>a == b</code></td>
<td align="center"><code>a</code>は<code>b</code>と等しい</td>
</tr>
<tr class="even">
<td align="left"><code>a != b</code></td>
<td align="center"><code>a</code>は<code>b</code>と等しくない</td>
</tr>
<tr class="odd">
<td align="left"><code>a &lt;  b</code></td>
<td align="center"><code>a</code>は<code>b</code>より小さい</td>
</tr>
<tr class="even">
<td align="left"><code>a &lt;= b</code></td>
<td align="center"><code>a</code>は<code>b</code>より小さい、もしくは等しい</td>
</tr>
<tr class="odd">
<td align="left"><code>a &gt;  b</code></td>
<td align="center"><code>a</code>は<code>b</code>より大きい</td>
</tr>
<tr class="even">
<td align="left"><code>a &gt;= b</code></td>
<td align="center"><code>a</code>は<code>b</code>より大きい、もしくは等しい</td>
</tr>
</tbody>
</table>
<p>真(<code>true</code>)というのは、意味が真であるときだ。正しい、成り立つ、正解などと言い換えてもよい。それ以外の場合はすべて偽(<code>false</code>)だ。正しくない、成り立たない、不正解などと言い換えてもいい。</p>
<p>整数や浮動小数点数の場合、話は簡単だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1は2より小さいか？</span>
    <span class="kw">if</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )
    {   <span class="co">// 真、お使いのコンピューターは正常です</span>
        std::cout &lt;&lt; <span class="st">&quot;Your computer works just fine.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
    <span class="kw">else</span>
    {
        <span class="co">// 偽、お使いのコンピューターには深刻な問題があります</span>
        std::cout &lt;&lt; <span class="st">&quot;Your computer has serious issues.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>文字列の場合、内容が同じであれば等しい。違うのであれば等しくない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="st">&quot;dog&quot;</span>s ;
    <span class="kw">auto</span> b = <span class="st">&quot;dog&quot;</span>s ;
    <span class="kw">auto</span> c = <span class="st">&quot;cat&quot;</span>s ;

    <span class="kw">if</span> ( a == b )
    {
        std::cout &lt;&lt; <span class="st">&quot;a == b</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
    <span class="kw">else</span>
    {
        std::cout &lt;&lt; <span class="st">&quot;a != b</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    }

    <span class="kw">if</span> ( a == c )
    {
        std::cout &lt;&lt; <span class="st">&quot;a == c</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    }
    <span class="kw">else</span>
    {
        std::cout &lt;&lt; <span class="st">&quot;a != c</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    }
}</code></pre></div>
<p>では文字列に大小はあるのだろうか。文字列に大小はある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> cat = <span class="st">&quot;cat&quot;</span>s ;
    <span class="kw">auto</span> dog = <span class="st">&quot;dog&quot;</span>s ;

    <span class="kw">if</span> ( cat &lt; dog )
    {   <span class="co">// 猫は小さい</span>
        std::cout &lt;&lt; <span class="st">&quot;cat is smaller.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
    <span class="kw">else</span>
    {   <span class="co">// 犬は小さい</span>
        std::cout &lt;&lt; <span class="st">&quot;dog is smaller.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }

    <span class="kw">auto</span> longcat = <span class="st">&quot;longcat&quot;</span>s ;

    <span class="kw">if</span> ( longcat &gt; cat )
    {   <span class="co">// longcatは長い</span>
        std::cout &lt;&lt; <span class="st">&quot;Longcat is Looong.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
    <span class="kw">else</span>
    {
        std::cout &lt;&lt; <span class="st">&quot;Longcat isn&#39;t that long. Sigh.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>実行して確かめてみよう。ほとんどの読者の実行環境では以下のようになるはずだ。ほとんどの、というのは、そうではない環境も存在するからだ。読者がそのような稀有な環境を使っている可能性はまずないだろうが。</p>
<pre><code>cat is smaller.
Longcat is Looong.</code></pre>
<p>なるほど。<code>&quot;cat&quot;s</code>は<code>&quot;dog&quot;s</code>よりも小さく(？)、<code>&quot;longcat&quot;s</code>は<code>&quot;cat&quot;s</code>よりも長い(大きい？)ようだ。なんだかよくわからない結果になった。</p>
<p>これはどういうことなのか。もっと簡単な文字列で試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="st">&quot;&quot;</span>s ;

    <span class="co">// aとbはどちらが小さいのだろうか？</span>
    <span class="kw">if</span> ( <span class="st">&quot;a&quot;</span>s &lt; <span class="st">&quot;b&quot;</span>s )
    {   x = <span class="st">&quot;a&quot;</span>s ; }
    <span class="kw">else</span>
    {   x = <span class="st">&quot;b&quot;</span>s ; }
 
    <span class="co">// 小さい方の文字が出力される</span>
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p>これを実行すると<code>a</code>と出力される。すると<code>&quot;a&quot;s</code>は<code>&quot;b&quot;s</code>より小さいようだ。</p>
<p>もっと試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="st">&quot;&quot;</span>s ;
    <span class="kw">if</span> ( <span class="st">&quot;aa&quot;</span>s &lt; <span class="st">&quot;ab&quot;</span>s )
    { x = <span class="st">&quot;aa&quot;</span>s ; }
    <span class="kw">else</span>
    { x = <span class="st">&quot;ab&quot;</span>s ; }

    <span class="co">// 小さい文字列が出力される</span>
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p>これを実行すると、<code>aa</code>と出力される。すると<code>&quot;aa&quot;s</code>は<code>&quot;ab&quot;s</code>より小さいことになる。</p>
<p>文字列の大小比較は文字単位で行われる。まず最初の文字が大小比較される。もし等しい場合は、次の文字が大小比較される。等しくない最初の文字の結果が、文字列の大小比較の結果となる。</p>
<h2 id="条件式">条件式</h2>
<h3 id="条件とは何だろう">条件とは何だろう</h3>
<p><code>if文</code>の中で書く<code>条件</code>(condition)は、<code>条件式</code>(conditional expression)とも呼ばれている<code>式</code>(expression)の一種だ。<code>式</code>というのは例えば<code>&quot;1+1&quot;</code>のようなものだ。<code>式</code>は<code>文</code>の中に書くことができ、これを<code>式文</code>(expression statement)という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dv">1</span> + <span class="dv">1</span> ; <span class="co">// 式文</span>
}</code></pre></div>
<p><code>&quot;a==b&quot;</code>や<code>&quot;a\&lt;b&quot;</code>のような<code>条件</code>も<code>式</code>なので、<code>文</code>として書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dv">1</span> == <span class="dv">1</span> ;
    <span class="dv">1</span> &lt; <span class="dv">2</span> ;
}</code></pre></div>
<p>C++では多くの式には型がある。たとえば<code>&quot;123&quot;</code>は<code>int</code>型で、<code>&quot;123+4&quot;</code>も<code>int</code>型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">123</span> ; <span class="co">// int</span>
    <span class="kw">auto</span> b = a + <span class="dv">4</span> ; <span class="co">// int</span>
    <span class="kw">auto</span> c = <span class="fl">1.0</span> ; <span class="co">// double</span>
    <span class="kw">auto</span> d = <span class="st">&quot;hello&quot;</span>s ; <span class="co">// std::string</span>
}</code></pre></div>
<p>とすると、<code>&quot;1==2&quot;</code>や<code>&quot;3!=3&quot;</code>のような条件式にも型があるのではないか。型があるのであれば変数に入れられるはずだ。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">if</span> (  <span class="dv">1</span> == <span class="dv">1</span> )
    { std::cout &lt;&lt; <span class="st">&quot;1 == 1 is true.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
    <span class="kw">else</span>
    { std::cout &lt;&lt; <span class="st">&quot;1 == 1 is false.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }

    <span class="kw">auto</span> x = <span class="dv">1</span> == <span class="dv">1</span> ;
    <span class="kw">if</span> ( x )
    { std::cout &lt;&lt; <span class="st">&quot;1 == 1 is true.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
    <span class="kw">else</span>
    { std::cout &lt;&lt; <span class="st">&quot;1 == 1 is false.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
}</code></pre></div>
<p><code>&quot;if(x)&quot;</code>は<code>&quot;if(1==1)&quot;</code>と書いた場合と同じように動く。</p>
<p>変数に入れられるのであれば出力もできるのではないだろうか。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// 正しい</span>
    <span class="kw">auto</span> b = <span class="dv">1</span> != <span class="dv">1</span> ; <span class="co">// 間違い</span>
    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; b ;
}</code></pre></div>
<pre><code>1
0</code></pre>
<p>なるほど、条件が正しい場合<code>&quot;1&quot;</code>になり、条件が間違っている場合<code>&quot;0&quot;</code>になるようだ。</p>
<p>では<code>if文</code>の中に<code>1</code>や<code>0</code>を入れたらどうなるのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 条件が正しい値だけ出力される。</span>
<span class="dt">int</span> main()
{
    <span class="kw">if</span> ( <span class="dv">1</span> ) std::cout &lt;&lt; <span class="st">&quot;1</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">if</span> ( <span class="dv">0</span> ) std::cout &lt;&lt; <span class="st">&quot;0</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">if</span> ( <span class="dv">123</span> ) std::cout &lt;&lt; <span class="st">&quot;123</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">if</span> ( <span class="dv">-1</span> ) std::cout &lt;&lt; <span class="st">&quot;-1</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>実行結果は以下のようになる。</p>
<pre><code>1
123
-1</code></pre>
<p>この結果を見ると、条件として<code>1</code>, <code>123</code>, <code>-1</code>は正しく、<code>0</code>は間違っているということになる。ますます訳がわからなくなってきた。</p>
<h2 id="bool型">bool型</h2>
<p>そろそろ種明かしをしよう。条件式の結果は、<code>bool型</code>という特別な型を持っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// bool型</span>
    <span class="dt">bool</span> A = <span class="dv">1</span> == <span class="dv">1</span> ; <span class="co">// 型を書いてもよい</span>
}</code></pre></div>
<p><code>int</code>型の変数には整数の値が入る。<code>double</code>型の変数には浮動小数点数の値が入る。<code>std::string</code>型の変数には文字列の値が入る。</p>
<p>すると、<code>bool</code>型の変数には<code>bool</code>型の値が入る。</p>
<p><code>bool</code>型には2つの値がある。条件が正しいことを意味する<code>true</code>と、条件が間違っていることを意味する<code>false</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> correct = <span class="kw">true</span> ;
    <span class="dt">bool</span> wrong = <span class="kw">false</span> ;
}</code></pre></div>
<p><code>bool</code>型にこれ以外の値は存在しない。</p>
<p><code>bool</code>型の値を正しく出力するには、<code>std::boolalpha</code>を出力する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;
    std::cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; <span class="kw">false</span> ;
}</code></pre></div>
<pre><code>true
false</code></pre>
<p><code>std::boolalpha</code>自体は何も出力をしない。一度<code>std::boolalpha</code>を出力すると、それ以降の<code>bool</code>値が<code>true</code>/<code>false</code>で出力されるようになる。</p>
<p>元に戻すには<code>std::noboolalpha</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;
    std::cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;
    std::cout &lt;&lt; std::noboolalpha ;
    std::cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;
}</code></pre></div>
<p>以下のように出力される。</p>
<pre><code>truefalse10</code></pre>
<p>すでに学んだ比較演算子は、正しい場合に<code>bool</code>型の値<code>true</code>を、間違っている場合に<code>bool</code>型の値<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// true</span>
    <span class="dt">bool</span> a = <span class="dv">1</span> == <span class="dv">1</span> ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b = <span class="dv">1</span> != <span class="dv">1</span> ;

    <span class="co">// true</span>
    <span class="dt">bool</span> c = <span class="dv">1</span> &lt; <span class="dv">2</span> ;
    <span class="co">// false</span>
    <span class="dt">bool</span> d = <span class="dv">1</span> &gt; <span class="dv">2</span> ;
}</code></pre></div>
<p>先に説明した<code>if文</code>の<code>条件</code>が「正しい」というのは<code>true</code>のことで、「間違っている」というのは<code>false</code>のことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 出力される</span>
    <span class="kw">if</span> ( <span class="kw">true</span> )
        std::cout &lt;&lt; <span class="st">&quot;true</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 出力されない。</span>
    <span class="kw">if</span> ( <span class="kw">false</span> )
        std::cout &lt;&lt; <span class="st">&quot;false</span><span class="ch">\n</span><span class="st">&quot;</span>s ; 
}</code></pre></div>
<h2 id="bool型の演算">bool型の演算</h2>
<p><code>bool</code>型にはいくつかの演算が用意されている。</p>
<h3 id="論理否定-operator">論理否定: operator !</h3>
<p><code>&quot;!a&quot;</code>は<code>a</code>が<code>true</code>の場合<code>false</code>に、<code>false</code>の場合<code>true</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;

    <span class="co">// false</span>
    std::cout &lt;&lt; !<span class="kw">true</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// true</span>
    std::cout &lt;&lt; !<span class="kw">false</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>論理否定演算子を使うと、<code>false</code>のときのみ実行されてほしい条件分岐が書きやすくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ロケットが発射可能かどうかを返す関数</span>
<span class="dt">bool</span> is_rocket_ready_to_launch()
{
    <span class="co">// まだだよ</span>
    <span class="kw">return</span> <span class="kw">false</span> ;
}

<span class="dt">int</span> main()
{

    <span class="co">// ロケットが発射可能ではないときに実行される</span>
    <span class="kw">if</span> ( !is_rocket_ready_to_launch() )
    {   <span class="co">// もうしばらくそのままでお待ちください</span>
        std::cout &lt;&lt; <span class="st">&quot;Standby...</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    }
}</code></pre></div>
<p>この例では、ロケットが発射可能でない場合のみ、待つようにアナウンスする。</p>
<p>同じように、<code>true</code>のときに実行されてほしくない条件分岐も書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ロケットが発射可能かどうかを返す関数</span>
<span class="dt">bool</span> is_rocket_ready_to_launch()
{
    <span class="co">// もういいよ</span>
    <span class="kw">return</span> <span class="kw">true</span> ;
}

<span class="dt">int</span> main()
{
    <span class="co">// ロケットが発射可能なときに実行される</span>
    <span class="kw">if</span> ( !is_rocket_ready_to_launch() )
    {   <span class="co">// カウントダウン</span>
        std::cout &lt;&lt; <span class="st">&quot;3...2...1...Hallelujah!</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }

}</code></pre></div>
<p>この2つの例では、ロケットの状態が実行すべき条件ではないので、正しく何も出力されない。</p>
<h3 id="同値比較-operator">同値比較: operator ==, !=</h3>
<p><code>bool</code>型の値の同値比較はわかりやすい。<code>true</code>は<code>true</code>と等しく、<code>false</code>は<code>false</code>と等しく、<code>true</code>と<code>false</code>は等しくない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> b)
    { std::cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">true</span>  == <span class="kw">true</span>  ) ; <span class="co">// true</span>
    print( <span class="kw">true</span>  == <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> == <span class="kw">true</span>  ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> == <span class="kw">false</span> ) ; <span class="co">// true</span>

    print( <span class="kw">true</span>  != <span class="kw">true</span>  ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  != <span class="kw">false</span> ) ; <span class="co">// true</span>
    print( <span class="kw">false</span> != <span class="kw">true</span>  ) ; <span class="co">// true</span>
    print( <span class="kw">false</span> != <span class="kw">false</span> ) ; <span class="co">// false</span>
}</code></pre></div>
<p>比較演算子の結果は<code>bool</code>値になるということを覚えているだろうか。<code>&quot;1 \&lt; 2&quot;</code>は<code>true</code>になり、<code>&quot;1 \&gt; 2&quot;</code>は<code>false</code>になる。</p>
<p><code>bool</code>値同士も同値比較ができるということは、<code>&quot;(1 \&lt; 2) == true&quot;</code>のように書くことも可能だということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b = (<span class="dv">1</span> &lt; <span class="dv">2</span>) == <span class="kw">true</span> ;
}</code></pre></div>
<p><code>&quot;(1\&lt;2)&quot;</code>は<code>true</code>なので、<code>&quot;(1\&lt;2)==true&quot;</code>は<code>&quot;true==true&quot;</code>と同じ意味になる。この結果はもちろん<code>&quot;true&quot;</code>だ。</p>
<h3 id="論理積-operator">論理積: operator &amp;&amp;</h3>
<p><code>&quot;a &amp;&amp; b&quot;</code>は<code>a</code>と<code>b</code>がともに<code>true</code>のときに<code>true</code>となる。それ以外の場合は<code>false</code>となる。これを論理積という。</p>
<p>表にまとめると以下のようになる。</p>
<table>
<thead>
<tr class="header">
<th align="left">式</th>
<th align="left">結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>false &amp;&amp; false</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr class="even">
<td align="left"><code>false &amp;&amp; true</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr class="odd">
<td align="left"><code>true  &amp;&amp; false</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr class="even">
<td align="left"><code>true  &amp;&amp; true</code></td>
<td align="left"><code>true</code></td>
</tr>
</tbody>
</table>
<p>さっそく確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;
    <span class="kw">auto</span> print = []( <span class="kw">auto</span> b )
    { std::cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">false</span> &amp;&amp; <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> &amp;&amp; <span class="kw">true</span>  ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  &amp;&amp; <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">true</span>  &amp;&amp; <span class="kw">true</span>  ) ; <span class="co">// true</span>
}</code></pre></div>
<p>論理積は、「AかつB」を表現するのに使える。</p>
<p>例えば、人間の体温が平熱かどうかを判断するプログラムを書くとする。36.1℃以上、37.2℃以下を平熱とすると、<code>if</code>文を使って以下のように書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 体温</span>
    <span class="dt">double</span> temperature = <span class="fl">36.6</span> ;

    <span class="co">// 36.1度以上</span>
    <span class="kw">if</span> ( temperature &gt;= <span class="fl">36.1</span> )
        <span class="kw">if</span> ( temperature &lt;= <span class="fl">37.2</span> )
        { std::cout &lt;&lt; <span class="st">&quot;Good.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
        <span class="kw">else</span>
        { std::cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
    <span class="kw">else</span>
    { std::cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
}</code></pre></div>
<p>このコードは、<code>operator &amp;&amp;</code>を使えば簡潔に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> temperature = <span class="fl">36.6</span> ;

    <span class="kw">if</span> ( ( temperature &gt;= <span class="fl">36.1</span> ) &amp;&amp; ( temperature &lt;= <span class="fl">37.2</span> ) )
    { std::cout &lt;&lt; <span class="st">&quot;Good.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
    <span class="kw">else</span>
    { std::cout &lt;&lt; <span class="st">&quot;Bad.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
}</code></pre></div>
<h3 id="論理和-operator">論理和: operator ||</h3>
<p><code>&quot;a || b&quot;</code>は<code>a</code>と<code>b</code>がともに<code>false</code>のときに<code>false</code>となる。それ以外の場合は<code>true</code>となる。これを論理和という。</p>
<p>表にまとめると以下のようになる。</p>
<table>
<thead>
<tr class="header">
<th align="left">式</th>
<th align="left">結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>false || false</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr class="even">
<td align="left"><code>false || true</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr class="odd">
<td align="left"><code>true  || false</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr class="even">
<td align="left"><code>true  || true</code></td>
<td align="left"><code>true</code></td>
</tr>
</tbody>
</table>
<p>さっそく確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;
    <span class="kw">auto</span> print = []( <span class="kw">auto</span> b )
    { std::cout &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">false</span> || <span class="kw">false</span> ) ; <span class="co">// false</span>
    print( <span class="kw">false</span> || <span class="kw">true</span>  ) ; <span class="co">// true</span>
    print( <span class="kw">true</span>  || <span class="kw">false</span> ) ; <span class="co">// true</span>
    print( <span class="kw">true</span>  || <span class="kw">true</span>  ) ; <span class="co">// true</span>
}</code></pre></div>
<p>論理和は、「AもしくはB」を表現するのに使える。</p>
<p>例えば、ある遊園地の乗り物には安全上の理由で身長が1.1m未満、あるいは1.9mを超える人は乗れないものとする。この場合、乗り物に乗れる身長かどうかを確かめるコードは、<code>if文</code>を使うと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> height = <span class="fl">1.3</span> ;

    <span class="kw">if</span> ( height &lt; <span class="fl">1.1</span> )
    { std::cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }
    <span class="kw">else</span> <span class="kw">if</span> ( height &gt; <span class="fl">1.9</span> )
    { std::cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }
    <span class="kw">else</span>
    { std::cout &lt;&lt; <span class="st">&quot;Yes.&quot;</span>s ; }
}</code></pre></div>
<p>論理和を使うと以下のように簡潔に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> height = <span class="fl">1.3</span> ;

    <span class="kw">if</span> ( ( height &lt; <span class="fl">1.1</span> ) || ( height &gt; <span class="fl">1.9</span> ) )
    { std::cout &lt;&lt; <span class="st">&quot;No.&quot;</span>s ; }
    <span class="kw">else</span>
    { std::cout &lt;&lt; <span class="st">&quot;Yes.&quot;</span>s ; }
}</code></pre></div>
<h3 id="短絡評価">短絡評価</h3>
<p>論理積と論理和は短絡評価と呼ばれる特殊な評価が行われる。これは、左から右に最小限の評価をするという意味だ。</p>
<p>論理積では、&quot;<code>a</code> &amp;&amp; <code>b</code>&quot;とある場合、<code>a</code>と<code>b</code>がともに<code>true</code>である場合のみ、結果は<code>true</code>になる。もし、<code>a</code>が<code>false</code>であった場合、<code>b</code>の結果如何にかかわらず結果は<code>false</code>となるので、<code>b</code>は評価されない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = []()
    {
        std::cout &lt;&lt; <span class="st">&quot;a</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">return</span> <span class="kw">false</span> ;
    } ;
    <span class="kw">auto</span> b = []()
    {
        std::cout &lt;&lt; <span class="st">&quot;b</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">return</span> <span class="kw">true</span> ;
    } ;

    <span class="dt">bool</span> c = a() &amp;&amp; b() ;
    std::cout &lt;&lt; std::boolalpha &lt;&lt; c ; 
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>a
false</code></pre>
<p>関数呼び出し<code>&quot;a()&quot;</code>の結果は<code>false</code>なので、<code>&quot;b()&quot;</code>は評価されない。評価されないということは関数呼び出しが行われず、当然標準出力も行われない。</p>
<p>同様に、論理和では、<code>&quot;a || b&quot;</code>とある場合、<code>a</code>と<code>b</code>のどちらか片方でも<code>true</code>であれば、結果は<code>true</code>となる。もし、<code>a</code>が<code>true</code>であった場合、<code>b</code>の結果如何にかかわらず結果は<code>true</code>となるので、<code>b</code>は評価されない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = []()
    {
        std::cout &lt;&lt; <span class="st">&quot;a</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">return</span> <span class="kw">true</span> ;
    } ;
    <span class="kw">auto</span> b = []()
    {
        std::cout &lt;&lt; <span class="st">&quot;b</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">return</span> <span class="kw">false</span> ;
    } ;

    <span class="dt">bool</span> c = a() || b() ;
    std::cout &lt;&lt; std::boolalpha &lt;&lt; c ; 
}</code></pre></div>
<p>結果、</p>
<pre><code>a
true</code></pre>
<p><code>&quot;b()&quot;</code>が評価されていないことがわかる。</p>
<h2 id="boolの変換">boolの変換</h2>
<p><code>bool</code>型の値と演算はこれで全部だ。値は<code>true</code>/<code>false</code>の2つのみ。演算は<code>==</code>, <code>!=</code>, <code>!</code>と<code>&amp;&amp;</code>と<code>||</code>の5つだけだ。</p>
<p>読者の中には納得のいかないものもいるだろう。ちょっと待ってもらいたい。<code>bool</code>の大小比較できないのだろうか。<code>bool</code>の四則演算はできないのか。<code>&quot;if(123)&quot;</code>などと書けてしまうのは何なのか。</p>
<p>好奇心旺盛な読者は本書の解説を待たずしてすでに自分でいろいろとコードを書いて試してしまっていることだろう。</p>
<p><code>bool</code>の大小比較はどうなるのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;

    <span class="dt">bool</span> b = <span class="kw">true</span> &lt; <span class="kw">false</span> ;
    std::cout &lt;&lt; b ;
}</code></pre></div>
<p>このコードを実行すると、出力は<code>&quot;false&quot;</code>だ。<code>&quot;true \&lt; false&quot;</code>の結果が<code>&quot;false&quot;</code>だということは、<code>true</code>は<code>false</code>より大きいということになる。</p>
<p>四則演算はどうか？</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> x)
    { std::cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">true</span>  + <span class="kw">true</span>  ) ;
    print( <span class="kw">true</span>  + <span class="kw">false</span> ) ;
    print( <span class="kw">false</span> + <span class="kw">true</span>  ) ;
    print( <span class="kw">false</span> + <span class="kw">false</span> ) ;
}</code></pre></div>
<p>結果、</p>
<pre><code>2
1
1
0</code></pre>
<p>不思議な結果だ。<code>&quot;true+true&quot;</code>は<code>&quot;2&quot;</code>、<code>&quot;true+false&quot;</code>は<code>&quot;1&quot;</code>、<code>&quot;false+false&quot;</code>は<code>&quot;0&quot;</code>。これは<code>true</code>が<code>1</code>で<code>false</code>が<code>0</code>ならば納得のいく結果だ。大小比較の結果としても矛盾していない。</p>
<p>すでに見たように、<code>std::boolalpha</code>を出力していない状態で<code>bool</code>を出力すると<code>true</code>が<code>1</code>、<code>false</code>が<code>0</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="kw">true</span> &lt;&lt; <span class="kw">false</span> ;
}</code></pre></div>
<p>結果、</p>
<pre><code>10</code></pre>
<p>これは<code>bool型</code>と<code>整数型</code>が変換されているのだ。</p>
<p>異なる型の値が変換されるというのは、すでに例がある。<code>整数型</code>と<code>浮動小数点数型</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 3</span>
    <span class="dt">int</span> i = <span class="fl">3.14</span> ;
    std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 123.0</span>
    <span class="dt">double</span> d = <span class="dv">123</span> ;
    std::cout &lt;&lt; d &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p><code>浮動小数点数型</code>は<code>整数型</code>に変換できる。その際に小数部は切り捨てられる。<code>整数型</code>は<code>浮動小数点数型</code>に変換できる。小数部はない。</p>
<p>これと同じように、<code>bool型</code>も<code>整数型</code>と変換ができる。</p>
<p><code>bool</code>型の<code>true</code>を<code>整数型</code>に変換すると<code>1</code>になる。<code>false</code>は<code>0</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1</span>
    <span class="dt">int</span> True = <span class="kw">true</span> ;
    <span class="co">// 0</span>
    <span class="dt">int</span> False = <span class="kw">false</span> ;
}</code></pre></div>
<p>同様に、<code>整数型</code>のゼロを<code>bool型</code>に変換すると<code>false</code>になる。非ゼロは<code>true</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// false</span>
    <span class="dt">bool</span> Zero = <span class="dv">0</span> ;

    <span class="co">// すべてtrue</span>
    <span class="dt">bool</span> One = <span class="dv">1</span> ;
    <span class="dt">bool</span> minus_one = <span class="dv">-1</span> ;
    <span class="dt">bool</span> OneTwoThree = <span class="dv">123</span> ;  
}</code></pre></div>
<p>したがって、<code>&quot;if (0)&quot;</code>は<code>&quot;if (false)&quot;</code>と等しく、<code>&quot;if (1)&quot;</code>や<code>&quot;if(-1)&quot;</code>など非ゼロな値は<code>&quot;if (true)&quot;</code>と等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 出力されない</span>
    <span class="kw">if</span> ( <span class="dv">0</span> )
        std::cout &lt;&lt; <span class="st">&quot;No output.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 出力される</span>
    <span class="kw">if</span> ( <span class="dv">1</span> )
        std::cout &lt;&lt; <span class="st">&quot;Output.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>大小比較は単に<code>bool</code>を整数に変換した結果を比較しているだけだ。<code>&quot;true \&lt; false&quot;</code>は<code>&quot;1 \&lt; 0&quot;</code>と書くのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; std::boolalpha ;

    <span class="co">// 1 &lt; 0</span>
    std::cout &lt;&lt; (<span class="kw">true</span> &lt; <span class="kw">false</span>) ;
}</code></pre></div>
<p>同様に四則演算も<code>bool</code>型を整数型に変換した上で計算をしているだけだ。<code>&quot;true + true&quot;</code>は<code>&quot;1 + 1&quot;</code>と書くのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1 + 1</span>
    std::cout &lt;&lt; (<span class="kw">true</span> + <span class="kw">true</span>) ;
}</code></pre></div>
<p>C++では、<code>bool型</code>と<code>整数型</code>の変換は暗黙に行われてしまうので注意が必要だ。</p>
<h1 id="デバッグ-コンパイル警告メッセージ">デバッグ: コンパイル警告メッセージ</h1>
<p>やれやれ、条件分岐は難しかった。この辺でもう一度ひと休みして、息抜きとしてデバッグの話をしよう。今回はコンパイラーの警告メッセージ(warning messages)についてだ。</p>
<p>コンパイラーはソースコードに文法エラーや意味エラーがあると、エラーメッセージを出すことはすでに学んだ。</p>
<p>コンパイラーがエラーメッセージを出さなかったとき、コンパイラーはソースコードには文法エラーや意味エラーを発見できず、コンパイラーは意味のあるプログラムを生成することができたということを意味する。しかし、コンパイルが通って実行可能なプログラムが生成できたからといって、プログラムにバグがないことは保証できない。</p>
<p>たとえば、変数<code>x</code>と<code>y</code>を足して出力するプログラムを考える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">1</span> ;
    <span class="kw">auto</span> y = <span class="dv">2</span> ;

    std::cout &lt;&lt; x + x ;
}</code></pre></div>
<p>このプログラムにはバグがある。プログラムの仕様は変数<code>x</code>と<code>y</code>を足すはずだったが変数<code>x</code>と<code>x</code>を足してしまっている。</p>
<p>コンパイラーはこのソースコードをコンパイルエラーにはしない。なぜならば上のコードは文法的に正しく、意味的にも正しいコードだからだ。</p>
<p>警告メッセージはこのような疑わしいコードについて、エラーとまではいかないまでも、文字どおり警告を出す機能だ。例えば上のコードをGCCでコンパイルすると以下のような警告メッセージを出す。</p>
<pre><code>$ make
g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:5:10: warning: unused variable ‘y’ [-Wunused-variable]
     auto y = 2 ;
          ^</code></pre>
<p>すでに説明したように、GCCのメッセージは</p>
<pre><code>ソースファイル名:行番号:列番号:メッセージの種類:メッセージの内容</code></pre>
<p>というフォーマットを取る。</p>
<p>このメッセージのフォーマットに照らし合わせると、このメッセージはソースファイル<code>main.cpp</code>の5行目の10列目について何かを警告している。警告はメッセージの種類として<code>warning</code>が使われる。</p>
<p>警告メッセージの内容は、「未使用の変数<code>'y'</code> <code>[-Wunused-variable]</code>」だ。コード中で<code>'y'</code>という名前の変数を宣言しているにもかかわらず、使っている場所がない。使わない変数を宣言するのはバグの可能性が高いので警告しているのだ。</p>
<p><code>[-Wunused-variable]</code>というのはGCCに与えるこの警告を有効にするためのオプション名だ。GCCに<code>-Wunused-variable</code>というオプションを与えると、未使用の変数を警告するようになる。</p>
<pre><code>$ g++ -Wunused-variable その他のオプション</code></pre>
<p>今回は<code>-Wall</code>というすべての警告を有効にするオプションを使っているので、このオプションを使う必要はない。</p>
<p>もう1つ例を出そう。以下のソースコードは変数<code>x</code>の値が<code>123</code>と等しいかどうかを調べるものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// xの値は0</span>
    <span class="kw">auto</span> x = <span class="dv">0</span> ;

    <span class="co">// xが123と等しいかどうか比較する</span>
    <span class="kw">if</span> ( x = <span class="dv">123</span> )
        std::cout &lt;&lt; <span class="st">&quot;x is 123.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">else</span>
        std::cout &lt;&lt; <span class="st">&quot;x is NOT 123.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>これを実行すると、<code>&quot;x is 123.\n&quot;</code>と出力される。しかし、変数<code>x</code>の値は<code>0</code>のはずだ。なぜか<code>0</code>と<code>123</code>は等しいと判断されてしまった。いったいどういうことだろう。</p>
<p>この謎は警告メッセージを読むと解ける。</p>
<pre><code>g++ -std=c++17 -Wall --pedantic-error -include all.h main.cpp -o program
main.cpp: In function ‘int main()’:
main.cpp:5:12: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
     if ( x = 123 )
          ~~^~~~~</code></pre>
<p><code>main.cpp</code>の5行目の12列目、「真偽値として使われている代入は括弧で囲むべき」とある。これはいったいどういうことか。よく見てみると、演算子が同値比較に使う<code>==</code>ではなく、<code>=</code>だ。<code>=</code>は代入演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;

    <span class="co">// 代入</span>
    <span class="co">// xの値は1</span>
    x = <span class="dv">1</span> ;

    <span class="co">// 同値比較</span>
    x == <span class="dv">1</span> ;
}</code></pre></div>
<p>実は<code>if文</code>の<code>条件</code>にはあらゆる<code>式</code>を書くことができる。代入というのは、実は<code>代入式</code>という式なので、<code>if文</code>の中にも書くことができる。その場合、式の結果の値は代入される変数の値になる。</p>
<p>そして思い出してほしいのは、整数型は<code>bool</code>型に変換されるということだ。<code>0</code>は<code>false</code>、非ゼロは<code>true</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;
    <span class="co">// 1はtrue</span>
    <span class="dt">bool</span> b1 = x = <span class="dv">1</span> ;
    <span class="kw">if</span> ( x = <span class="dv">1</span> ) ;

    <span class="co">// 0はfalse</span>
    <span class="dt">bool</span> b0 = x = <span class="dv">0</span> ;
    <span class="kw">if</span> ( x = <span class="dv">0</span> ) ;
}</code></pre></div>
<p>つまり、<code>&quot;if(x=1)&quot;</code>というのは、<code>&quot;if(1)&quot;</code>と書くのと同じで、これは最終的に、<code>&quot;if(true)&quot;</code>と同じ意味になる。</p>
<p>警告メッセージの「括弧で囲むべき」というのは、括弧で囲んだ場合、この警告メッセージは出なくなるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> x = <span class="dv">0</span> ;

    <span class="kw">if</span> ( (x = <span class="dv">0</span>) )
        std::cout &lt;&lt; <span class="st">&quot;x is 123.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">else</span>
        std::cout &lt;&lt; <span class="st">&quot;x is NOT 123.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このコードをコンパイルしても警告メッセージは出ない。</p>
<p>わざわざ括弧で囲むということは、ちゃんと代入を意図して使っていることがわかっていると意思表示したことになり、結果として警告メッセージはなくなる。</p>
<p>この警告メッセージ単体を有効にするオプションは<code>-Wparentheses</code>だ。</p>
<p>警告メッセージは万能ではない。ときにはまったく問題ないコードに対して警告メッセージが出たりする。これは仕方がないことだ。というのもコンパイラーはソースコード中に表現されていない、人間の脳内にある意図を読むことはできないからだ。ただし、警告メッセージにはひと通り目を通して、それが問題ない誤検知であるかどうかを確認することは重要だ。</p>
<h1 id="最近体重が気になるあなたのための標準入力">最近体重が気になるあなたのための標準入力</h1>
<h2 id="これまでのおさらい">これまでのおさらい</h2>
<p>ここまで学んできた範囲でも、かなりのプログラムが書けるようになってきた。試しにちょっとプログラムを書いてみよう。</p>
<p>最近肥満が気になる読者は、肥満度を把握するためにBMI(Body Mass Index)を計算して出力するプログラムを書くことにした。</p>
<p>BMIの計算は以下のとおり。</p>
<p><span class="math display">\[
BMI = \frac{体重_{kg}}{身長^2_{m}}
\]</span></p>
<p>本書をここまで読み進めた読者ならば、このようなプログラムは簡単に書けるだろう。計算は小数点以下の値を扱う必要があるために、変数は浮動小数点数型(<code>double</code>)にする。掛け算は<code>operator *</code>で、割り算は<code>operator /</code>だ。出力には<code>std::cout</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長1.63m</span>
    <span class="dt">double</span> height = <span class="fl">1.63</span> ;
    <span class="co">// 体重73kg</span>
    <span class="dt">double</span> mass = <span class="fl">73.0</span> ;

    <span class="co">// BMIの計算</span>
    <span class="dt">double</span> bmi = mass / (height*height) ;

    <span class="co">// BMIの出力</span>
    std::cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span>s &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>結果は<code>&quot;27.4756&quot;</code>となった。これだけでは太っているのか痩せているのかよくわからない。調べてみると、BMIの数値と肥満との関係は以下の表のとおりになるそうだ。</p>
<table>
<thead>
<tr class="header">
<th align="left">BMI</th>
<th align="left">状態</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">18.5未満</td>
<td align="left">痩せすぎ(Underweight)</td>
</tr>
<tr class="even">
<td align="left">18.5以上、25未満</td>
<td align="left">普通(Normal)</td>
</tr>
<tr class="odd">
<td align="left">25以上、30未満</td>
<td align="left">太り気味(Overweight)</td>
</tr>
<tr class="even">
<td align="left">30以上</td>
<td align="left">肥満(Obese)</td>
</tr>
</tbody>
</table>
<p>ではさっそく、この表のようにBMIから肥満状態も出力してくれるように、プログラムを書き換えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長1.63m</span>
    <span class="dt">double</span> height = <span class="fl">1.63</span> ;
    <span class="co">// 体重73kg</span>
    <span class="dt">double</span> mass = <span class="fl">73.0</span> ;

    <span class="co">// BMIの計算</span>
    <span class="dt">double</span> bmi = mass / (height*height) ;

    <span class="co">// BMIの出力</span>
    std::cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span>s &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 状態の判定をする関数</span>
    <span class="kw">auto</span> status = []( <span class="dt">double</span> bmi )
    {
        <span class="kw">if</span> ( bmi &lt; <span class="fl">18.5</span> )
            <span class="kw">return</span> <span class="st">&quot;Underweight.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">else</span> <span class="kw">if</span> ( bmi &lt; <span class="fl">25.0</span> )
            <span class="kw">return</span> <span class="st">&quot;Normal.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">else</span> <span class="kw">if</span> ( bmi &lt; <span class="fl">30.0</span> )
            <span class="kw">return</span> <span class="st">&quot;Overweight.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">else</span>
            <span class="kw">return</span> <span class="st">&quot;Obese.&quot;</span>s ;
    } ;

    <span class="co">// 状態の出力</span>
    std::cout &lt;&lt; status(bmi) ;
}</code></pre></div>
<p>ここまで問題なく読むことができただろうか。ここまでのコードはすべて、本書を始めから読めば理解できる機能しか使っていない。わからない場合、この先に進む前に本書をもう一度始めから読み直すべきだろう。</p>
<h2 id="標準入力">標準入力</h2>
<p>上のプログラムには実用にする上で1つ問題がある。身長と体重の値を変えたい場合、ソースコードを書き換えてコンパイルしなければならないのだ。</p>
<p>例えば読者の身長が1.8mで体重が80kgの場合、以下のように書き換えなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長1.63m</span>
    <span class="dt">double</span> height = <span class="fl">1.80</span> ;
    <span class="co">// 体重73kg</span>
    <span class="dt">double</span> mass = <span class="fl">80.0</span> ;

    <span class="co">// BMIの計算</span>
    <span class="dt">double</span> bmi = mass / (height*height) ;

    <span class="co">// BMIの出力</span>
    std::cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span>s &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>すると今度は身長が1.48mで体重が48kgの人がやってきて私のBMIも計測しろとうるさい。しかも昨日と今日で体重が変わったからどちらも計測したいと言い出す始末。</p>
<p>こういうとき、プログラムのコンパイル時ではなく、実行時に値を入力できたならば、いちいちプログラムをコンパイルし直す必要がなくなる。</p>
<p>入力には<code>std::cin</code>を使う。<code>std::cout</code>は標準出力を扱うのに対し、<code>std::cin</code>は標準入力を扱う。<code>std::cout</code>が<code>operator &lt;&lt;</code>を使って値を出力したのに対し、<code>std::cin</code>は<code>operator &gt;&gt;</code>を使って値を変数に入れる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 入力を受け取るための変数</span>
    std::string x{} ;
    <span class="co">// 変数に入力を受け取る</span>
    std::cin &gt;&gt; x ;
    <span class="co">// 入力された値を出力</span>
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
hello
hello</code></pre>
<p>標準入力はデフォルトでは、プログラムを実行したユーザーがターミナルから入力する。上の実行結果の2行目は、ユーザーの入力だ。</p>
<p><code>std::cin</code>は入力された文字列を変数に入れる。入力は空白文字や改行で区切られる。そのため、空白で区切られた文字列を渡すと、以下のようになる。</p>
<pre><code>$ make run
hello world
hello</code></pre>
<p>入力は複数取ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::string x{} ;
    std::string y{} ;
    std::cin &gt;&gt;  x &gt;&gt; y ;
    std::cout &lt;&lt; x &lt;&lt; y ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
hello world
helloworld</code></pre>
<p>空白文字は文字列の区切り文字として認識されるので変数<code>x</code>, <code>y</code>には入らない。</p>
<p><code>std::cin</code>では文字列のほかにも整数や浮動小数点数、<code>bool</code>を入力として得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数</span>
    <span class="dt">int</span> i{} ;
    std::cin &gt;&gt; i ;
    <span class="co">// 浮動小数点数</span>
    <span class="dt">double</span> d{} ;
    std::cin &gt;&gt; d ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
123 1.23</code></pre>
<p>数値はデフォルトで10進数として扱われる。</p>
<p><code>bool</code>の入力には注意が必要だ。普通に書くと、ゼロが<code>false</code>, 非ゼロが<code>true</code>として扱われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b{} ;
    std::cin &gt;&gt; b ;

    std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>$ make run
1
true
$ make run
0
false
$ make run
123
true
$ make run
-1
true</code></pre>
<p><code>&quot;true&quot;</code>, <code>&quot;false&quot;</code>という文字列で<code>true</code>, <code>false</code>の入力をしたい場合、<code>std::cin</code>に<code>std::boolalpha</code>を「入力」させる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// bool型</span>
    <span class="dt">bool</span> b{} ;
    std::cin &gt;&gt; std::boolalpha &gt;&gt; b ;

    std::cout &lt;&lt; std::boolalpha &lt;&lt; b ;
}</code></pre></div>
<p>実行結果</p>
<pre><code>$ make run
true
true
$ make run
false
false</code></pre>
<p><code>std::boolalpha</code>を入出力するというのは、実際には何も入出力しないので奇妙に見えるが、そういう設計になっているので仕方がない。</p>
<p>では標準入力を学んだので、さっそくBMIを計算するプログラムを標準入力に対応させよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 身長の入力</span>
    <span class="dt">double</span> height{} ;
    std::cout &lt;&lt; <span class="st">&quot;height(m)&gt;&quot;</span> ;
    std::cin &gt;&gt; height ;

    <span class="co">// 体重の入力</span>
    <span class="dt">double</span> mass{} ;
    std::cout &lt;&lt; <span class="st">&quot;mass(kg)&gt;&quot;</span> ;
    std::cin &gt;&gt; mass ;

    <span class="dt">double</span> bmi = mass / (height*height) ;

    std::cout &lt;&lt; <span class="st">&quot;BMI=&quot;</span> &lt;&lt; bmi &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>上出来だ。</p>
<h2 id="リダイレクト">リダイレクト</h2>
<p>標準入出力が扱えるようになれば、もう自分の好きなプログラムを書くことができる。プログラムというのはけっきょく、入力を得て、処理して、出力するだけのものだからだ。入力はテキストだったりグラフィックだったり何らかの特殊なデバイスだったりするが、基本は変わらない。</p>
<p>たとえば読者はまだC++でファイルを読み書きする方法を知らないが、標準入出力さえ使えれば、ファイルの読み書きはリダイレクトを使うだけでできるのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span> ;
}</code></pre></div>
<p>これは<code>&quot;hello&quot;</code>と標準出力するだけの簡単なプログラムだ。このプログラムをコンパイルしたプログラム名を<code>program</code>としよう。標準出力の出力先はデフォルトで、ユーザーのターミナルになる。</p>
<pre><code>$ ./program
hello</code></pre>
<p>リダイレクトを使えば、この出力先をファイルにできる。リダイレクトを使うには<code>&quot;プログラム \&gt; ファイル名&quot;</code>とする。</p>
<pre><code>$ ./program &gt; hello.txt
$ cat hello.txt
hello</code></pre>
<p>ファイルへの簡単な書き込みは、リダイレクトを使うことであとから簡単に実現可能だ。</p>
<p>リダイレクトはファイルの読み込みにも使える。例えば先ほどのBMIを計算するプログラムを用意しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bmi</span>
<span class="dt">int</span> main()
{
    <span class="dt">double</span> height{ } ;
    <span class="dt">double</span> mass { } ;

    std::cin &gt;&gt; height &gt;&gt; mass ;

    std::cout &lt;&lt; mass / (height*height) ;
}</code></pre></div>
<p>このプログラム名を<code>bmi</code>として、通常どおり実行すると以下のようになる。</p>
<pre><code>$　./bmi
1.63
73
27.4756</code></pre>
<p>このうち、<code>1.63</code>と<code>73</code>はユーザーによる入力だ。これを毎回手で入力するのではなく、ファイルから入力することができる。つまり以下のようなファイルを用意して、</p>
<pre><code>1.63
73</code></pre>
<p>このファイルを例えば、<code>&quot;bodymass.txt&quot;</code>とする。手で入力する代わりに、このファイルを入力として使いたい。これにはリダイレクトとして<code>&quot;プログラム名 \&lt; ファイル名&quot;</code>とする。</p>
<pre><code>$ ./bmi &lt; bodymass.txt
27.4756</code></pre>
<p>リダイレクトの入出力を組み合わせることも可能だ。</p>
<pre><code>$ cat bodymass.txt
1.63
73
$ ./bmi &lt; bodymass.txt &gt; index.txt
$ cat index.txt
27.4756</code></pre>
<p>もちろん、このようなファイルの読み書きは簡易的なものだが、かなりの処理がこの程度のファイル操作でも行えるのだ。</p>
<h2 id="パイプ">パイプ</h2>
<p>プログラムが出力した結果をさらに入力にすることだってできる。</p>
<p>例えば、先ほどのプログラム<code>bmi</code>に入力するファイル<code>bodymass.txt</code>の身長の単位がメートルではなくセンチメートルだったとしよう。</p>
<pre><code>163
73</code></pre>
<p>この場合、プログラム<code>bmi</code>を書き換えて対処することもできるが、プログラムに入力させる前にファイルを読み込み、書き換えて出力し、その出力を入力とすることもできる。</p>
<p>まず、身長の単位をセンチメートルからメートルに直すプログラムを書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// convert</span>
<span class="dt">int</span> main()
{
    <span class="dt">double</span> height{} ;
    <span class="dt">double</span> mass{} ;

    std::cin &gt;&gt; height &gt;&gt; mass ;

    <span class="co">// 身長をセンチメートルからメートルに直す</span>
    <span class="co">// 体重はそのままでよい</span>
    std::cout &lt;&lt; height/<span class="fl">100.0</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; mass ;
}</code></pre></div>
<p>このプログラムを<code>convert</code>と名付け、さっそく使ってみよう。</p>
<pre><code>$ ./convert
163
73
1.63
73</code></pre>
<p>身長の単位がセンチメートルからメートルに正しく直されている。</p>
<p>これをリダイレクトで使うとこうなる。</p>
<pre><code>$ ./convert &lt; bodymass.txt &gt; fixed_bodymass.txt
$ ./bmi &lt; fixed_bodymass.txt
27.4756</code></pre>
<p>しかしこれではファイルが増えて面倒だ。この場合、パイプを使うとスッキリと書ける。</p>
<p>パイプはプログラムの標準出力をプログラムの標準入力とするの使い方は、<code>&quot;プログラム名 | プログラム名&quot;</code>だ。</p>
<pre><code>$ ./convert &lt; bodymass.txt | ./bmi
27.4756</code></pre>
<p>ところで、すでに何度か説明なしで使っているが、POSIX規格を満たすOSには<code>cat</code>というプログラムが標準で入っている。<code>cat ファイル名</code>は指定したファイル名の内容を標準出力する。標準出力はパイプで標準入力にできる。</p>
<pre><code>$ cat bodymass.txt | ./convert | ./bmi
27.4756</code></pre>
<h2 id="プログラムの組み合わせ">プログラムの組み合わせ</h2>
<p>現代のプログラミングというのは、すでに存在するプログラムを組み合わせて作るものだ。もし、自分の必要とする処理がすでに実装されているのであれば、自分で書く必要はない。</p>
<p>例えば、読者はまだカレントディレクトリー下のファイルの一覧を列挙する方法を知らない。しかしPOSIX規格を満たすOSには<code>ls</code>というカレントディレクトリー下のファイルの一覧を列挙するプログラムが存在する。これを先ほどまでBMIの計算などの作業をしていたディレクトリー下で実行してみよう。</p>
<pre><code>$ ls
all.h  all.h.gch  bmi  bodymass.txt  convert  data  main.cpp  Makefile  program</code></pre>
<p>ファイルの一覧が列挙される。そしてこれはプログラム<code>ls</code>による標準出力だ。標準出力ということは、リダイレクトしてファイルに書き込んだり、パイプで別のプログラムに渡したりできるということだ。</p>
<pre><code>$ ls &gt; files.txt
$ ls | ./program</code></pre>
<p>標準入出力が扱えれば、ネットワークごしにWebサイトをダウンロードすることもできる。これにはほとんどのGNU/LinuxベースのOSに入っている<code>curl</code>というプログラムを使う。</p>
<pre><code>$ curl https://example.com</code></pre>
<p>プログラム<code>curl</code>は指定されたURLからデータをダウンロードして、標準出力する。標準出力するということは、パイプによって標準入力にできるということだ。</p>
<pre><code>$ curl https://example.com | ./program</code></pre>
<p>読者はC++でネットワークアクセスする方法を知らないが、すでにネットワークアクセスは可能になった。</p>
<p>ほかにも便利なプログラムはたくさんある。プログラミングの学び始めはできることが少なくて退屈になりがちだが、読者はもうファイルの読み書きやネットワークアクセスまでできるようになったのだから、退屈はしないはずだ。</p>
<h1 id="ループ">ループ</h1>
<p>さて、ここまでで変数や関数、標準入出力といったプログラミングの基礎的な概念を教えてきた。あと1つでプログラミングに必要な基礎的な概念はすべて説明し終わる。ループだ。</p>
<h2 id="これまでのおさらい-1">これまでのおさらい</h2>
<p>C++では、プログラムは書いた順番に実行される。これを<code>逐次実行</code>という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="dv">1</span> ;
    std::cout &lt;&lt; <span class="dv">2</span> ;
    std::cout &lt;&lt; <span class="dv">3</span> ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>123</code></pre>
<p>この実行結果が<code>&quot;123&quot;</code>以外の結果になることはない。C++ではプログラムは書かれた順番に実行されるからだ。</p>
<p>条件分岐は、プログラムの実行を条件付きで行うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="dv">1</span> ;

    <span class="kw">if</span> ( <span class="kw">false</span> )
        std::cout &lt;&lt; <span class="dv">2</span> ;

    std::cout &lt;&lt; <span class="dv">3</span> ;

    <span class="kw">if</span> ( <span class="kw">true</span> )
        std::cout &lt;&lt; <span class="dv">4</span> ;
    <span class="kw">else</span>
        std::cout &lt;&lt; <span class="dv">5</span> ;
}</code></pre></div>
<p>実行結果、</p>
<pre><code>134</code></pre>
<p>条件分岐によって、プログラムの一部を実行しないということが可能になる。</p>
<h2 id="goto文">goto文</h2>
<p>ここでは繰り返し(ループ)の基礎的な仕組みを理解するために、最も原始的で最も使いづらい繰り返しの機能である<code>goto文</code>を学ぶ。<code>goto文</code>で実用的な繰り返し処理をするのは面倒だが、恐れることはない。より簡単な方法もすぐに説明するからだ。なぜ本書で<code>goto文</code>を先に教えるかというと、あらゆる繰り返しは、けっきょくのところ<code>if文</code>と<code>goto文</code>へのシンタックスシュガーにすぎないからだ。<code>goto文</code>を学ぶことにより、繰り返しを恐れることなく使う本物のプログラマーになれる。</p>
<h3 id="無限ループ">無限ループ</h3>
<p><code>&quot;hello\n&quot;</code>と3回出力するプログラムはどうやって書くのだろうか。<code>&quot;hello\n&quot;</code>を1回出力するプログラムの書き方はすでにわかっているので、同じ文を3回書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1回&quot;hello\n&quot;を出力する関数</span>
<span class="dt">void</span> hello()
{
    std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    hello() ;
    hello() ;
    hello() ;
}</code></pre></div>
<p>10回出力する場合はどうするのだろう。10回書けばよい。コードは省略する。</p>
<p>では100回出力する場合はどうするのだろう。100回書くのだろうか。100回も同じコードを書くのはとても面倒だ。読者がVimのような優秀なテキストエディターを使っていない限り100回も同じコードを間違えずに書くことは不可能だろう。Vimならば1回書いたあとにノーマルモードで<code>&quot;100.&quot;</code>するだけで100回書ける。</p>
<p>実際のところ、100回だろうが、1000回だろうが、あらかじめ回数がコンパイル時に決まっているのであれば、その回数だけ同じ処理を書くことで実現可能だ。</p>
<p>しかし、プログラムを外部から強制的に停止させるまで、無限に出力し続けるプログラムはどう書けばいいのだろうか。そういった停止しないプログラムを外部から強制的に停止させるには<code>Ctrl-C</code>を使う。</p>
<p>以下はそのようなプログラムの実行例だ。</p>
<pre><code>$ make run
hello
hello
hello
hello
...
[Ctrl-Cを押す]</code></pre>
<p><code>goto文</code>は指定したラベルに実行を移す機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ラベル名 : 文

<span class="kw">goto</span> ラベル名 ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="dv">1</span> ;

    <span class="co">// ラベルskipまで飛ぶ</span>
    <span class="kw">goto</span> skip ;

    std::cout &lt;&lt; <span class="dv">2</span> ;

<span class="co">// ラベルskip</span>
skip :
    std::cout &lt;&lt; <span class="dv">3</span> ;
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>13</code></pre>
<p><code>2</code>を出力すべき文の実行が飛ばされていることがわかる。</p>
<p>これだけだと<code>&quot;if (false)&quot;</code>と同じように見えるが、<code>goto文</code>はソースコードの上に飛ぶこともできるのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello()
{
    std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}
<span class="dt">int</span> main()
{
loop :
    hello() ;
    <span class="kw">goto</span> loop ; 
}</code></pre></div>
<p>これは<code>&quot;hello\n&quot;</code>を無限に出力するプログラムだ。</p>
<p>このプログラムを実行すると、</p>
<ol style="list-style-type: decimal">
<li>関数<code>hello</code>が呼ばれる</li>
<li><code>goto</code>文でラベル<code>loop</code>まで飛ぶ</li>
<li>1.に戻る</li>
</ol>
<p>という処理を行う。</p>
<h3 id="終了条件付きループ">終了条件付きループ</h3>
<p>ひたすら同じ文字列を出力し続けるだけのプログラムというのも味気ない。もっと面白くてためになるプログラムを作ろう。例えば、ユーザーから入力された数値を合計し続けるプログラムはどうだろう。</p>
<p>いまから作るプログラムを実行すると以下のようになる。</p>
<pre><code>$ make run
&gt; 10
10
&gt; 5
15
&gt; 999
1014
&gt; -234
780</code></pre>
<p>このプログラムは、</p>
<ol style="list-style-type: decimal">
<li><code>&quot;\&gt;&quot;</code>と表示してユーザーから整数値を入力</li>
<li>これまでの入力との合計値を出力</li>
<li>1.に戻る</li>
</ol>
<p>という動作を繰り返す。先ほど学んだ無限ループと同じだ。</p>
<p>さっそく作っていこう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    std::cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    std::cin &gt;&gt; x ;
    <span class="kw">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
loop :
    sum = sum + input() ;
    std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">goto</span> loop ;
}</code></pre></div>
<p>関数<code>input</code>は<code>&quot;\&gt;&quot;</code>を表示してユーザーからの入力を得て戻り値として返すだけの関数だ。</p>
<p><code>&quot;sum = sum + input()&quot;</code>は、変数<code>sum</code>に新しい値を代入するもので、その代入する値というのは、代入する前の変数<code>sum</code>の値と関数<code>input</code>の戻り値を足した値だ。</p>
<p>このような変数<code>x</code>に何らかの値<code>n</code>を足した結果を元の変数<code>x</code>に代入するという処理はとても多く使われるので、C++では<code>&quot;x = x + n&quot;</code>を意味する省略記法<code>&quot;x += n&quot;</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="dt">int</span> n = <span class="dv">5</span> ;

    x = x + n ; <span class="co">// 6</span>
    x += n ; <span class="co">// 11</span>
}</code></pre></div>
<p>さて、本題に戻ろう。上のプログラムは動く。しかし、プログラムを停止するには<code>Ctrl-C</code>を押すしかない。できればプログラム自ら終了してもらいたいものだ。</p>
<p>そこで、ユーザーが<code>0</code>を入力したときはプログラムを終了するようにしよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    std::cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    std::cin &gt;&gt; x ;
    <span class="kw">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
loop :
    <span class="co">// 一度入力を変数に代入</span>
    <span class="dt">int</span> x = input() ;
    <span class="co">// 変数xが0でない場合</span>
    <span class="kw">if</span> ( x != <span class="dv">0</span> )
    {<span class="co">// 実行</span>
        sum = sum + x ;
        std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">goto</span> loop ;
    }
    <span class="co">// x == 0の場合、ここに実行が移る</span>
    <span class="co">// main関数の最後なのでプログラムが終了</span>
}</code></pre></div>
<p>うまくいった。このループは、ユーザーが<code>0</code>を入力した場合に繰り返しを終了する、条件付きのループだ。</p>
<h3 id="インデックスループ">インデックスループ</h3>
<p>最後に紹介するループは、インデックスループだ。<span class="math inline">\(n\)</span>回<code>&quot;hello\n&quot;s</code>を出力するプログラムを書こう。問題は、この<span class="math inline">\(n\)</span>はコンパイル時には与えられず、実行時にユーザーからの入力で与えられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n回出力する関数の宣言</span>
<span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;

<span class="dt">int</span> main()
{
    <span class="co">// ユーザーからの入力</span>
    <span class="dt">int</span> n {} ;
    std::cin &gt;&gt; n ;
    <span class="co">// n回出力</span>
    hello_n( n ) ;
}</code></pre></div>
<p>このコードをコンパイルしようとするとエラーになる。これは実はコンパイルエラーではなくてリンクエラーという種類のエラーだ。その理由は、関数<code>hello_n</code>に対する関数の定義が存在しないからだ。</p>
<p>関数というのは宣言と定義に分かれている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 関数の宣言</span>
<span class="dt">void</span> f( ) ;

<span class="co">// 宣言</span>
<span class="dt">void</span> f( )
<span class="co">// 定義</span>
{ }</code></pre></div>
<p>関数の宣言というのは何度書いても大丈夫だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宣言</span>
<span class="dt">int</span> f( <span class="dt">int</span> x ) ;

<span class="co">// 再宣言</span>
<span class="dt">int</span> f( <span class="dt">int</span> x ) ;

<span class="co">// 再宣言</span>
<span class="dt">int</span> f( <span class="dt">int</span> x ) ;</code></pre></div>
<p>関数の宣言というのは戻り値の型や関数名や引数リストだけで、<code>&quot;;&quot;</code>で終わる。</p>
<p>関数の定義とは、関数の宣言のあとの<code>&quot;{}&quot;</code>だ。この場合、宣言のあとに<code>&quot;;&quot;</code>は書かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x ) { <span class="kw">return</span> x ; }</code></pre></div>
<p>関数の定義は一度しか書けない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 定義</span>
<span class="dt">void</span> f() {}
<span class="co">// エラー、再定義</span>
<span class="dt">void</span> f() {}</code></pre></div>
<p>なぜ関数は宣言と定義とに分かれているかというと、C++では名前は宣言しないと使えないためだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    <span class="co">// 名前fは宣言されていない</span>
    f() ;
}

<span class="co">// 定義</span>
<span class="dt">void</span> f() { }</code></pre></div>
<p>なので、必ず名前は使う前に宣言しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 名前fの宣言</span>
<span class="dt">void</span> f() ;

<span class="dt">int</span> main()
{
    <span class="co">// OK、名前fは関数</span>
    f() ;
}

<span class="co">// 名前fの定義</span>
<span class="dt">void</span> f() { }</code></pre></div>
<p>さて、話を元に戻そう。これから学ぶのは<span class="math inline">\(n\)</span>回<code>&quot;hello\n&quot;s</code>と出力するプログラムの書き方だ。ただし<span class="math inline">\(n\)</span>はユーザーが入力するので実行時にしかわからない。すでに我々はユーザーから<span class="math inline">\(n\)</span>の入力を受け取る部分のプログラムは書いた。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n回出力する関数の宣言</span>
<span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;

<span class="dt">int</span> main()
{
    <span class="co">// ユーザーからの入力</span>
    <span class="dt">int</span> n {} ;
    std::cin &gt;&gt; n ;
    <span class="co">// n回出力</span>
    hello_n( n ) ;
}</code></pre></div>
<p>あとは関数<code>hello_n(n)</code>が<span class="math inline">\(n\)</span>回<code>&quot;hello\n&quot;s</code>と出力するようなループを実行すればいいのだ。</p>
<p>すでに我々は無限回<code>&quot;hello\n&quot;s</code>と出力する方法を知っている。まずは無限回ループを書こう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
loop :
    std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">goto</span> loop ;
}</code></pre></div>
<p>終了条件付きループで学んだように、このループを<span class="math inline">\(n\)</span>回繰り返した場合に終了させるには、<code>if文</code>を使って、終了条件に達したかどうかで実行を分岐させればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
loop :
    <span class="co">// まだn回繰り返していない場合</span>
    <span class="kw">if</span> ( ??? )
    { <span class="co">// 以下を実行</span>
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">goto</span> loop ;
    }
}</code></pre></div>
<p>このコードを完成させるにはどうすればいいのか。まず、現在何回繰り返しを行ったのか記録する必要がある。このために変数を作る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i = <span class="dv">0</span> ;</code></pre></div>
<p>変数<code>i</code>の初期値は0だ。まだ繰り返し実行を1回も行っていないということは、つまり0回繰り返し実行をしたということだ。</p>
<p>1回繰り返し実行をするたびに、変数<code>i</code>の値を1増やす。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i = i + <span class="dv">1</span> ;</code></pre></div>
<p>これはすでに学んだように、もっと簡単に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i += <span class="dv">1</span> ;</code></pre></div>
<p>実は、さらに簡単に書くこともできる。変数の代入前の値に1を足した値を代入する、つまり変数の値を1増やすというのはとてもよく書くコードなので、とても簡単な演算子が用意されている。<code>operator ++</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
    ++i ; <span class="co">// 1</span>
    ++i ; <span class="co">// 2</span>
    ++i ; <span class="co">// 3</span>
}</code></pre></div>
<p>これで変数<code>i</code>の値は1増える。これをインクリメント(increment)という。</p>
<p>インクリメントと対になるのがデクリメント(decrement)だ。これは変数の値を1減らす。演算子は<code>operator --</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
    --i ; <span class="co">// -1</span>
    --i ; <span class="co">// -2</span>
    --i ; <span class="co">// -3</span>
}</code></pre></div>
<p>さて、必要な知識は学び終えたので本題に戻ろう。<span class="math inline">\(n\)</span>回の繰り返しをしたあとにループを終了するには、まずいま何回繰り返し実行しているのかを記録する必要がある。その方法を学ぶために、0, 1, 2, 3, 4...と無限に出力されるプログラムを書いてみよう。</p>
<p>このプログラムを実行すると以下のように表示される。</p>
<pre><code>$ make run
1, 2, 3, 4, 5, 6, [Ctrl-C]</code></pre>
<p><code>Ctrl-C</code>を押すまでプログラムは無限に実行される。</p>
<p>ではどうやって書くのか。以下のようにする。</p>
<ol style="list-style-type: decimal">
<li>変数<code>i</code>を作り、値を<code>0</code>にする</li>
<li>変数<code>i</code>と<code>&quot;, &quot;s</code>を出力する</li>
<li>変数<code>i</code>をインクリメントする</li>
<li><code>goto</code> 2.</li>
</ol>
<p>この処理を素直に書くと以下のコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1. 変数iを作り、値を0にする</span>
    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="co">// 2. 変数iと&quot;, &quot;sを出力する</span>
    std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span>s ;
    <span class="co">// 3. 変数iをインクリメントする</span>
    ++i ;
    <span class="co">// 4. goto 2</span>
    <span class="kw">goto</span> loop ;
}</code></pre></div>
<p>どうやら、いま何回繰り返し実行しているか記録することはできるようになったようだ。</p>
<p>ここまでくればしめたもの。あとは<code>goto文</code>を実行するかどうかを<code>if文</code>で条件分岐すればよい。しかし、<code>if文</code>の中にどんな条件を書けばいいのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="co">// まだn回繰り返し実行をしていなければ実行</span>
    <span class="kw">if</span> ( ??? )
    {
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="kw">goto</span> loop ;
    }
}</code></pre></div>
<p>具体的に考えてみよう。<code>n == 3</code>のとき、つまり3回繰り返すときを考えよう。</p>
<ol style="list-style-type: decimal">
<li>1回目の<code>if</code>文実行のとき、<code>i == 0</code></li>
<li>2回目の<code>if</code>文実行のとき、<code>i == 1</code></li>
<li>3回目の<code>if</code>文実行のとき、<code>i == 2</code></li>
<li>4回目の<code>if</code>文実行のとき、<code>i == 3</code></li>
</ol>
<p>ここでは<code>n == 3</code>なので、3回まで実行してほしい。つまり3回目までは<code>true</code>になり、4回目の<code>if</code>文実行のときには<code>false</code>になるような式を書く。そのような式とは、ズバリ<code>&quot;i != n&quot;</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="kw">if</span> ( i != n )
    {
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="kw">goto</span> loop ;
    }
}</code></pre></div>
<p>さっそく実行してみよう。</p>
<pre><code>$ make run
3
hello
hello
hello
$ make run
2
hello
hello</code></pre>
<p>なるほど、動くようだ。しかしこのプログラムにはバグがある。<code>-1</code>を入力すると、なぜか大量の<code>hello</code>が出力されてしまうのだ。</p>
<pre><code>$ make run
-1
hello
hello
hello
hello
[Ctrl-C]</code></pre>
<p>この原因はまだ現時点の読者には難しい。この謎はいずれ明らかにするとして、いまは<code>n</code>が負数の場合にプログラムを0回の繰り返し分の実行で終了するように書き換えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="co">// nが負数ならば</span>
    <span class="kw">if</span> ( n &lt; <span class="dv">0</span> )
        <span class="co">// 関数の実行を終了</span>
        <span class="kw">return</span> ;

    <span class="dt">int</span> i = <span class="dv">0</span> ;
loop :
    <span class="kw">if</span> ( i != n )
    {
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="kw">goto</span> loop ;
    }
}</code></pre></div>
<h2 id="while文">while文</h2>
<p><code>goto文</code>は極めて原始的で使いづらい機能だ。現実のC++プログラムでは<code>goto文</code>はめったに使われない。もっと簡単な機能を使う。ではなぜ<code>goto文</code>が存在するかというと、<code>goto文</code>は最も原始的で基礎的で、ほかの繰り返し機能は<code>if文</code>と<code>goto文</code>に変換することで実現できるからだ。</p>
<p><code>goto文</code>より簡単な繰り返し文に、<code>while文</code>がある。ここでは<code>goto文</code>と<code>while文</code>を比較することで、<code>while文</code>を学んでいこう。</p>
<h3 id="無限ループ-1">無限ループ</h3>
<p>無限ループを<code>goto文</code>で書く方法を思い出してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> hello = []()
    { std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

loop :
    <span class="co">// 繰り返し実行される文</span>
    hello() ;
    <span class="kw">goto</span> loop ;
}</code></pre></div>
<p>このコードで本当に重要なのは関数<code>hello</code>を呼び出している部分だ。ここが繰り返し実行される文で、<code>ラベル文</code>と<code>goto文</code>は、繰り返し実行を実現するために必要な記述でしかない。</p>
<p>そこで<code>while(true)</code>だ。<code>while(true)</code>は<code>goto文</code>と<code>ラベル文</code>よりも簡単に無限ループを実現できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> (<span class="kw">true</span>) 文</code></pre></div>
<p><code>while文</code>は文を無限に繰り返して実行してくれる。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> hello = []()
    { std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    <span class="kw">while</span> (<span class="kw">true</span>)
        hello() ;
}</code></pre></div>
<p>このコードの重要な部分は以下の2行。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> (<span class="kw">true</span>)
    hello() ;</code></pre></div>
<p>これを<code>goto文</code>と<code>ラベル文</code>を使った無限ループと比べてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">loop:
    hello() ;
    <span class="kw">goto</span> loop ;</code></pre></div>
<p>どちらも同じ意味のコードだが、<code>while文</code>の方が明らかに書きやすくなっているのがわかる。</p>
<p><code>goto文</code>で学んだ、ユーザーからの整数値の入力の合計の計算を繰り返すプログラムを<code>while(true)</code>で書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    std::cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    std::cin &gt;&gt; x ;
    <span class="kw">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="kw">while</span>( <span class="kw">true</span> )
    {
        sum += input() ;
        std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>重要なのは以下の5行だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span>( <span class="kw">true</span> )
{
    sum += input() ;
    std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>これを<code>goto文</code>で書いた場合と比べてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">loop :
    sum += input() ;
    std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="kw">goto</span> loop ;</code></pre></div>
<p>本当に重要で本質的な、繰り返し実行をする部分の2行のコードはまったく変わっていない。それでいて<code>while(true)</code>の方が圧倒的に簡単に書ける。</p>
<h3 id="終了条件付きループ-1">終了条件付きループ</h3>
<p>なるほど、無限ループを書くのに、<code>goto文</code>を使うより<code>while(true)</code>を使った方がいいことがわかった。ではほかのループの場合でも、<code>while文</code>の方が使いやすいだろうか。</p>
<p>本書を先頭から読んでいる優秀な読者は<code>while(true)</code>の<code>true</code>は<code>bool</code>型の値であることに気が付いているだろう。実は<code>while(E)</code>の括弧の中<code>E</code>は、<code>if(E)</code>と書くのとまったく同じ<code>条件</code>なのだ。<code>条件</code>が<code>true</code>であれば繰り返し実行される。<code>false</code>なら繰り返し実行されない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> ( 条件 ) 文</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 実行されない</span>
    <span class="kw">while</span> ( <span class="kw">false</span> )
        std::cout &lt;&lt; <span class="st">&quot;No&quot;</span>s ;

    <span class="co">// 実行されない</span>
    <span class="kw">while</span> ( <span class="dv">1</span> &gt; <span class="dv">2</span> )
        std::cout &lt;&lt; <span class="st">&quot;No&quot;</span>s ;

    <span class="co">// 実行される</span>
    <span class="co">// 無限ループ</span>
    <span class="kw">while</span> ( <span class="dv">1</span> &lt; <span class="dv">2</span> )
        std::cout &lt;&lt; <span class="st">&quot;Yes&quot;</span>s ;
}</code></pre></div>
<p><code>while文</code>を使って、<code>0</code>が入力されたら終了する合計値計算プログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    std::cout &lt;&lt; <span class="st">&quot;&gt;&quot;</span>s ;
    <span class="dt">int</span> x {} ;
    std::cin &gt;&gt; x ;
    <span class="kw">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
    <span class="dt">int</span> x {} ;

    <span class="kw">while</span>( ( x = input() ) != <span class="dv">0</span> )
    {
        sum += x ;
        std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>重要なのはこの5行。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span>( ( x = input() ) != <span class="dv">0</span> )
{
    sum += x ;
    std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>ここではちょっと難しいコードが出てくる。<code>while</code>の中の<code>条件</code>が、<code>&quot;( x = input() ) != 0&quot;</code>になっている。これはどういうことか。</p>
<p>実は<code>条件</code>は<code>bool型</code>に変換さえできればどんな式でも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x { } ;

    <span class="kw">if</span> ( (x = <span class="dv">1</span>) == <span class="dv">1</span> )
        std::cout &lt;&lt; <span class="st">&quot;(x = 1) is 1.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このコードでは、&quot;<code>(x=1)</code>&quot;と&quot;<code>1</code>&quot;が等しい&quot;<code>==</code>&quot;かどうかを判断している。&quot;<code>(x=1)</code>&quot;という式は変数<code>x</code>に<code>1</code>を代入する式だ。<code>代入式</code>の値は、代入された変数の値になる。この場合変数<code>x</code>の値だ。変数<code>x</code>には<code>1</code>が代入されているので、その値は1、つまり&quot;<code>(x=1) == 1</code>&quot;は&quot;<code>1 == 1</code>&quot;と書くのと同じ意味になる。この結果は<code>true</code>だ。</p>
<p>さて、このことを踏まえて、&quot;<code>( x = input() ) != 0</code>&quot;を考えてみよう。</p>
<p>&quot;<code>( x = input() )</code>&quot;は変数<code>x</code>に関数<code>input</code>を呼び出した結果を代入している。関数<code>input</code>はユーザーから入力を得て、その入力をそのまま返す。つまり変数<code>x</code>にはユーザーの入力した値が代入される。その結果が<code>0</code>と等しくない&quot;<code>!=</code>&quot;かどうかを判断している。つまり、ユーザーが<code>0</code>を入力した場合は<code>false</code>、非ゼロを入力した場合は<code>true</code>となる。</p>
<p><code>while(条件)</code>は<code>条件</code>が<code>true</code>となる場合に繰り返し実行をする。結果として、ユーザーが<code>0</code>を入力するまで繰り返し実行をするコードになる。</p>
<p><code>goto文</code>を使った終了条件付きループと比較してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">loop:
    <span class="kw">if</span> ( (x = input() ) != <span class="dv">0</span> )
    {
        sum += x ;
        std::cout &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="kw">goto</span> loop ;
    }</code></pre></div>
<p><code>while文</code>の方が圧倒的に書きやすいことがわかる。</p>
<h3 id="インデックスループ-1">インデックスループ</h3>
<p><span class="math inline">\(n\)</span>回<code>&quot;hello\n&quot;s</code>と出力するプログラムを<code>while文</code>で書いてみよう。ただし<span class="math inline">\(n\)</span>はユーザーが入力するものとする。</p>
<p>まずは<code>goto文</code>でも使ったループ以外の処理をするコードから。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n ) ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> n {} ;
    std::cin &gt;&gt; n ;
    hello_n( n ) ;
}</code></pre></div>
<p>あとは関数<code>hello_n(n)</code>がインデックスループを実装するだけだ。ただし<code>n</code>が負数ならば何も実行しないようにしよう。</p>
<p><code>goto文</code>でインデックスループを書くときに学んだように、</p>
<ol style="list-style-type: decimal">
<li><code>n &lt; 0</code>ならば関数を終了</li>
<li>変数<code>i</code>を作り値を0にする</li>
<li><code>i != n</code>ならば繰り返し実行</li>
<li>出力</li>
<li><code>++i</code></li>
<li><code>goto</code> 3.</li>
</ol>
<p>を<code>while文</code>で書くだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello_n( <span class="dt">int</span> n )
{
    <span class="co">// 1. n &lt; 0ならば関数を終了</span>
    <span class="kw">if</span> ( n &lt; <span class="dv">0</span> )
        <span class="kw">return</span> ;

    <span class="co">// 2. 変数iを作り値を0にする</span>
    <span class="dt">int</span> i = <span class="dv">0</span> ;

    <span class="co">// 3. i != nならば繰り返し実行</span>
    <span class="kw">while</span>( i != n )
    {   <span class="co">// 4. 出力</span>
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="co">// 5. ++i</span>
        ++i ;
    } <span class="co">// 6. goto 3</span>
}</code></pre></div>
<p>重要な部分だけ抜き出すと以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span>( i != n )
{
    std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    ++i ;
}</code></pre></div>
<p><code>goto文</code>を使ったインデックスループと比較してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">loop :
    <span class="kw">if</span> ( i != n )
    {
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        ++i ;
        <span class="kw">goto</span> loop ;
    }</code></pre></div>
<p>読者の中にはあまり変わらないのではないかと思う人もいるかもしれない。しかし、次の問題を解くプログラムを書くと、<code>while文</code>がいかに楽に書けるかを実感するだろう。</p>
<p>問題：以下のような九九の表を出力するプログラムを書きなさい。</p>
<pre><code>1   2   3   4   5   6   7   8   9   
2   4   6   8   10  12  14  16  18  
3   6   9   12  15  18  21  24  27  
4   8   12  16  20  24  28  32  36  
5   10  15  20  25  30  35  40  45  
6   12  18  24  30  36  42  48  54  
7   14  21  28  35  42  49  56  63  
8   16  24  32  40  48  56  64  72  
9   18  27  36  45  54  63  72  81</code></pre>
<p>もちろん、このような文字列を愚直に出力しろという問題ではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 違う！</span>
    std::cout &lt;&lt; <span class="st">&quot;1 2 3 4 5...&quot;</span>s ;
}</code></pre></div>
<p>逐次実行、条件分岐、ループまでを習得した誇りある本物のプログラマーである我々は、もちろん九九の表はループを書いて出力する。</p>
<p>まず出力すべき表を見ると、数値が左揃えになっていることに気が付くだろう。</p>
<pre><code>4   8   12
5   10  15</code></pre>
<p><code>8</code>は1文字、<code>10</code>は2文字にもかかわらず、<code>12</code>と<code>15</code>は同じ列目から始まっている。これは出力するスペース文字を調整することでも実現できるが、ここでは単にタブ文字を使っている。</p>
<p>タブ文字は<code>Makefile</code>を書くのにも使った文字で、C++の文字列中に直接書くこともできるが、エスケープ文字<code>\t</code>を使ってもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;4</span><span class="ch">\t</span><span class="st">8</span><span class="ch">\t</span><span class="st">12</span><span class="ch">\n</span><span class="st">5</span><span class="ch">\t</span><span class="st">10</span><span class="ch">\t</span><span class="st">15&quot;</span>s ;
}</code></pre></div>
<p>エスケープ文字<code>\n</code>が改行文字に置き換わるように、エスケープ文字<code>\t</code>はタブ文字に置き換わる。</p>
<p>九九の表はどうやって出力すればよいだろうか。計算自体はC++では<code>&quot;a*b&quot;</code>でできる。上の表がどのように計算されているかを考えてみよう。</p>
<pre><code>1*1 1*2 1*3 1*4 1*5 1*6 1*7 1*8 1*9 
2*1 2*2 2*3 2*4 2*5 2*6 2*7 2*8 2*9 
3*1 3*2 3*3 3*4 3*5 3*6 3*7 3*8 3*9 
4*1 4*2 4*3 4*4 4*5 4*6 4*7 4*8 4*9 
5*1 5*2 5*3 5*4 5*5 5*6 5*7 5*8 5*9 
6*1 6*2 6*3 6*4 6*5 6*6 6*7 6*8 6*9 
7*1 7*2 7*3 7*4 7*5 7*6 7*7 7*8 7*9 
8*1 8*2 8*3 8*4 8*5 8*6 8*7 8*8 8*9 
9*1 9*2 9*3 9*4 9*5 9*6 9*7 9*8 9*9</code></pre>
<p>これを見ると、<code>&quot;a*b&quot;</code>のうちの<code>a</code>を<code>1</code>から<code>9</code>までインクリメントし、それに対して<code>b</code>を<code>1</code>から<code>9</code>までインクリメントさせればよい。つまり、9回のインデックスループの中で9回のインデックスループを実行することになる。ループの中のループだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> ( 条件 )
    <span class="kw">while</span> ( 条件 )
        文</code></pre></div>
<p>さっそくそのようなコードを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1から9まで</span>
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="kw">while</span> ( a &lt;= <span class="dv">9</span> )
    {
        <span class="co">// 1から9まで</span>
        <span class="dt">int</span> b = <span class="dv">1</span> ;
        <span class="kw">while</span> ( b &lt;= <span class="dv">9</span> )
        {
            <span class="co">// 計算結果を出力</span>
            std::cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>s ;
            ++b ;
        }
        <span class="co">// 段の終わりに改行</span>
        std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        ++a ;
    }
}</code></pre></div>
<p>うまくいった。</p>
<p>ところで、このコードを<code>goto文</code>で書くとどうなるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
loop_outer :
    <span class="kw">if</span> ( a &lt;= <span class="dv">9</span> )
    {
        <span class="dt">int</span> b = <span class="dv">1</span> ;
loop_inner :
        <span class="kw">if</span> ( b &lt;= <span class="dv">9</span> )
        {
            std::cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>s ;
            ++b ;
            <span class="kw">goto</span> loop_inner ;
        }
        std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        ++a ;
        <span class="kw">goto</span> loop_outer ;
    }
}</code></pre></div>
<p>とてつもなく読みにくい。</p>
<h2 id="for文">for文</h2>
<p>ところでいままで<code>while文</code>で書いてきたインデックスループには特徴がある。</p>
<p>試しに1から100までの整数を出力するコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">1</span> ;
    <span class="kw">while</span> ( i &lt;= <span class="dv">100</span> )
    {
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;
        ++i ;
    }
}</code></pre></div>
<p>このコードを読むと、以下のようなパターンがあることがわかる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// ループ実行前の変数の宣言と初期化</span>
    <span class="dt">int</span> i = <span class="dv">1</span> ;
    <span class="co">// ループ中の終了条件の確認</span>
    <span class="kw">while</span> ( i &lt;= <span class="dv">100</span> )
    {
        <span class="co">// 実際に繰り返したい文</span>
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;
        <span class="co">// 各ループの最後に必ず行う処理</span>
        ++i ;
    }
}</code></pre></div>
<p>ここで真に必要なのは、「実際に繰り返したい文」だ。その他の処理は、ループを実現するために必要なコードだ。ループの実現に必要な処理が飛び飛びの場所にあるのは、はなはだわかりにくい。</p>
<p><code>for文</code>はそのような問題を解決するための機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( 変数の宣言 ; 終了条件の確認 ; 各ループの最後に必ず行う処理 ) 文</code></pre></div>
<p><code>for文</code>を使うと、上のコードは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt;= <span class="dv">100</span> ; ++i )
    {
        std::cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    } 
}</code></pre></div>
<p>ループの実現に必要な部分だけ抜き出すと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// for文の開始</span>
<span class="kw">for</span> (
<span class="co">// 変数の宣言と初期化</span>
<span class="dt">int</span> i = <span class="dv">1</span> ;
<span class="co">// 終了条件の確認</span>
i &lt;= <span class="dv">100</span> ;
<span class="co">// 各ループの最後に必ず行う処理</span>
++i )</code></pre></div>
<p><code>for文</code>はインデックスループによくあるパターンをわかりやすく書くための機能だ。例えば<code>while文</code>のときに書いた九九の表を出力するプログラムは、<code>for文</code>ならばこんなに簡潔に書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">for</span> ( <span class="dt">int</span> a = <span class="dv">1</span> ; a &lt;= <span class="dv">9</span> ; ++a )
    {
        <span class="kw">for</span> ( <span class="dt">int</span> b = <span class="dv">1</span> ; b &lt;= <span class="dv">9</span> ; ++b )
        { std::cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>s ; }

        std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p><code>while文</code>を使ったコードと比べてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="kw">while</span> ( a &lt;= <span class="dv">9</span> )
    {
        <span class="dt">int</span> b = <span class="dv">1</span> ;
        <span class="kw">while</span> ( b &lt;= <span class="dv">9</span> )
        {
            std::cout &lt;&lt; a * b &lt;&lt; <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>s ;
            ++b ;
        }
        std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        ++a ;
    }
}</code></pre></div>
<p>格段に読みやすくなっていることがわかる。</p>
<p>C++ではカンマ<code>','</code>を使うことで、複数の<code>式</code>を1つの<code>文</code>に書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">0</span>, b = <span class="dv">0</span> ;
    ++a, ++b ;
}</code></pre></div>
<p><code>for文</code>でもカンマが使える。九九の表を出力するプログラムは、以下のように書くこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">for</span> ( <span class="dt">int</span> a = <span class="dv">1</span> ; a &lt;= <span class="dv">9</span> ; ++a, std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s )
        <span class="kw">for</span> ( <span class="dt">int</span> b = <span class="dv">1</span> ; b &lt;= <span class="dv">9</span> ; ++b )
            std::cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>変数もカンマで複数宣言できると知った読者は、以下のように書きたくなるだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">for</span> (   <span class="dt">int</span> a = <span class="dv">1</span>, b = <span class="dv">1</span> ;
            a &lt;= <span class="dv">9</span> ;
            ++a, ++b,
            std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        )
            std::cout &lt;&lt; a*b &lt;&lt; <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>これは動かない。なぜならば、<code>for文</code>を2つネストさせたループは、<span class="math inline">\(a \times b\)</span>回のループで、変数<code>a</code>が<code>1</code>から<code>9</code>まで変化するそれぞれに対して、変数<code>b</code>が<code>1</code>から<code>9</code>まで変化する。しかし、上の<code>for文</code>1つのコードは、変数<code>a</code>, <code>b</code>ともに同時に<code>1</code>から<code>9</code>まで変化する。したがって、これは単に<code>a</code>回のループでしかない。<code>a</code>回のループの中で<code>b</code>回のループをすることで<span class="math inline">\(a \times b\)</span>回のループを実現できる。</p>
<p><code>for文</code>では使わない部分を省略することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b = <span class="kw">true</span> ;
    <span class="co">// for文による変数宣言は使わない</span>
    <span class="kw">for</span> ( ; b ; b = <span class="kw">false</span> )
        std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
}</code></pre></div>
<p><code>for文</code>で終了条件を省略した場合、<code>true</code>と同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">for</span> (;;)
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このプログラムは<code>&quot;hello\n&quot;s</code>と無限に出力し続けるプログラムだ。<code>&quot;for(;;)&quot;</code>は<code>&quot;for(;true;)&quot;</code>と同じ意味であり、<code>&quot;while(true)&quot;</code>とも同じ意味だ。</p>
<h2 id="do文">do文</h2>
<p><code>do文</code>は<code>while文</code>に似ている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">do</span> 文 <span class="kw">while</span> ( 条件 ) ;</code></pre></div>
<p>比較のために<code>while文</code>の文法も書いてみると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> ( 条件 ) 文</code></pre></div>
<p><code>while文</code>はまず<code>条件</code>を確認し<code>true</code>の場合<code>文</code>を実行する。これを繰り返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">while</span> ( <span class="kw">false</span> )
    {
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p><code>do文</code>はまず<code>文</code>を実行する。しかる後に<code>条件</code>を確認し<code>true</code>の場合繰り返しを行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">do</span> {
        std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    } <span class="kw">while</span> ( <span class="kw">false</span> ) ;
}</code></pre></div>
<p>違いがわかっただろうか。<code>do文</code>は繰り返し実行する<code>文</code>を、<code>条件</code>がなんであれ、最初に一度実行する。</p>
<p><code>do文</code>を使うと条件にかかわらず文を1回は実行するコードが、文の重複なく書けるようになる。</p>
<h2 id="break文">break文</h2>
<p>ループの実行の途中で、ループの中から外に脱出したくなった場合、どうすればいいのだろうか。例えばループを実行中に何らかのエラーを検出したので処理を中止したい場合などだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> ( <span class="kw">true</span> )
{
    <span class="co">// 処理</span>

    <span class="kw">if</span> ( is_error() )
        <span class="co">// エラーのため脱出したくなった</span>

    <span class="co">// 処理</span>
}</code></pre></div>
<p><code>break文</code>はループの途中から脱出するための文だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">break</span> ;</code></pre></div>
<p><code>break文</code>は<code>for文</code>、<code>while文</code>、<code>do文</code>の中でしか使えない。</p>
<p><code>break文</code>は<code>for文</code>、<code>while文</code>、<code>do文</code>の外側に脱出する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="kw">break</span> ;

        <span class="co">// 処理</span>
    }
}</code></pre></div>
<p>これは以下のようなコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="kw">goto</span> break_while ;

        <span class="co">// 処理</span>
    }
break_while : ;
}</code></pre></div>
<p><code>break文</code>は最も内側の<code>繰り返し文</code>から脱出する</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">while</span> ( <span class="kw">true</span> ) <span class="co">// 外側</span>
    {
        <span class="kw">while</span> ( <span class="kw">true</span> ) <span class="co">// 内側</span>
        {
            <span class="kw">break</span> ;
        }
        <span class="co">// ここに脱出</span>
    }
}</code></pre></div>
<h2 id="continue文">continue文</h2>
<p>ループの途中で、いまのループを打ち切って次のループに進みたい場合はどうすればいいのだろう。例えば、ループの途中でエラーを検出したので、そのループについては処理を打ち切りたい場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">while</span> ( <span class="kw">true</span> )
{
    <span class="co">// 処理</span>

    <span class="kw">if</span> ( is_error() )
        <span class="co">// このループは打ち切りたい</span>

    <span class="co">// 処理</span>
}</code></pre></div>
<p><code>continue文</code>はループを打ち切って次のループに行くための文だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">continue</span> ;</code></pre></div>
<p><code>continue文</code>は<code>for文</code>、<code>while文</code>、<code>do</code>文の中でしか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="kw">continue</span> ;

        <span class="co">// 処理</span>
    }
}</code></pre></div>
<p>これは以下のようなコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">while</span> ( <span class="kw">true</span> )
    {
        <span class="co">// 処理</span>

        <span class="kw">goto</span> continue_while ;

        <span class="co">// 処理</span>

continue_while : ;
    }
}</code></pre></div>
<p><code>continue</code>文はループの最後に処理を移す。その結果、次のループを実行するかどうかの<code>条件</code>を評価することになる。</p>
<p><code>continue文</code>は最も内側のループに対応する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">while</span> ( <span class="kw">true</span> ) <span class="co">// 外側</span>
    {
        <span class="kw">while</span> ( <span class="kw">true</span> ) <span class="co">// 内側</span>
        {
            <span class="kw">continue</span> ;
            <span class="co">// continueはここに実行を移す</span>
        }
    }
}</code></pre></div>
<h2 id="再帰関数">再帰関数</h2>
<p>最後に関数でループを実装する方法を示してこの章を終わりにしよう。</p>
<p>関数は関数を呼び出すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }

<span class="dt">void</span> g()
{
    f() ; <span class="co">// 関数fの呼び出し</span>
}

<span class="dt">int</span> main()
{
    g() ; <span class="co">// 関数gの呼び出し</span>
}</code></pre></div>
<p>ではもし、関数が自分自身を呼び出したらどうなるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello()
{
    std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    hello() ;
}

<span class="dt">int</span> main()
{
    hello() ;
}</code></pre></div>
<ol style="list-style-type: decimal">
<li>関数<code>main</code>は関数<code>hello</code>を呼び出す</li>
<li>関数<code>hello</code>は<code>&quot;hello\n&quot;</code>と出力して関数<code>hello</code>を呼び出す</li>
</ol>
<p>関数<code>hello</code>は必ず関数<code>hello</code>を呼び出すので、この実行は無限ループする。</p>
<p>関数が自分自身を呼び出すことを、<code>再帰</code>(recursion)という。</p>
<p>なるほど、再帰によって無限ループを実現できることはわかった。では終了条件付きループは書けるだろうか。</p>
<p>関数は<code>return文</code>によって呼び出し元に戻る。単に<code>'return ;'</code>と書けば再帰はしない。そして、<code>if文</code>によって実行は分岐できる。これを使えば再帰で終了条件付きループが実現できる。</p>
<p>試しに、ユーザーが<code>0</code>を入力するまでループし続けるプログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ユーザーからの入力を返す</span>
<span class="dt">int</span> input ()
{
    <span class="dt">int</span> x { } ;
    std::cin &gt;&gt; x ;
    <span class="kw">return</span> x ;
}

<span class="co">// 0の入力を終了条件としたループ</span>
<span class="dt">void</span> loop_until_zero()
{
    <span class="kw">if</span> ( input() == <span class="dv">0</span> )
        <span class="kw">return</span> ;
    <span class="kw">else</span>
        loop_until_zero() ;
}

<span class="dt">int</span> main()
{
    loop_until_zero() ;
}</code></pre></div>
<p>書けた。</p>
<p>ではインデックスループはどうだろうか。<code>1</code>から<code>10</code>までの整数を出力してみよう。</p>
<p>インデックスループを実現するには、書き換えられる変数が必要だ。関数は引数で値を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> g( <span class="dt">int</span> x ) { }
<span class="dt">void</span> f( <span class="dt">int</span> x ) { g( x<span class="dv">+1</span> ) ; }

<span class="dt">int</span> main() { f( <span class="dv">0</span> ) ; }</code></pre></div>
<p>これを見ると、関数<code>main</code>は関数<code>f</code>に引数<code>0</code>を渡し、関数<code>f</code>は関数<code>g</code>に引数<code>1</code>を渡している。これをもっと再帰的に考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> until_ten( <span class="dt">int</span> x )
{
    <span class="kw">if</span> ( x &gt; <span class="dv">10</span> )
        <span class="kw">return</span> ;
    <span class="kw">else</span>
    {
        std::cout &lt;&lt; x &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> ;
        <span class="kw">return</span> until_ten( x + <span class="dv">1</span> ) ;
    }
}

<span class="dt">int</span> main()
{
    until_ten(<span class="dv">1</span>) ;
}</code></pre></div>
<p>関数<code>main</code>は関数<code>until_ten</code>に引数1を渡す。</p>
<p>関数<code>until_ten</code>は引数が<code>10</code>より大きければ何もせず処理を戻し、そうでなければ引数を出力して再帰する。そのとき引数は<span class="math inline">\(+1\)</span>される。</p>
<p>これによりインデックスループが実現できる。</p>
<p>関数は戻り値を返すことができる。再帰で戻り値を使うことにより面白い問題も解くことができる。</p>
<p>例えば、<code>1</code>と<code>0</code>だけを使った10進数の整数を2進数に変換するプログラムを書いてみよう。</p>
<pre><code>$ make run
&gt; 0
0
&gt; 1
1
&gt; 10
2
&gt; 11
3
&gt; 1010
10
&gt; 1111
15</code></pre>
<p>まず10進数と2進数を確認しよう。数学的に言うと「10を底にする」とか「2を底にする」という言い方をする。</p>
<p>具体的な例を出すと10進数では1,2,3,4,5,6,7,8,9,0の文字を使う。<code>1234</code>は以下のようになる。</p>
<p><span class="math display">\[
1234 = 1 \times 10^3 + 2 \times 10^2 + 3 \times 10^1 + 4 \times 10^0 = 1 \times 1000 + 2 \times 100 + 3 \times 10 + 4 \times 1
\]</span></p>
<p>10進数で<code>1010</code>は以下のようになる。</p>
<p><span class="math display">\[
1010 = 1 \times 10^3 + 0 \times 10^2 + 1 \times 10^1 + 0 \times 10^0 = 1 \times 1000 + 0 \times 100 + 1 \times 10 + 0 \times 1
\]</span></p>
<p>2進数では1,0の文字を使う。<code>1010</code>は以下のようになる。</p>
<p><span class="math display">\[
1010 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 1 \times 8 + 0 \times 4 + 1 \times 2 + 0 \times 1
\]</span></p>
<p>2進数の<code>1010</code>は10進数では<code>10</code>になる。</p>
<p>では問題を解いていこう。</p>
<p>問題を難しく考えるとかえって解けなくなる。ここではすでに10進数から2進数への変換は解決したものとして考えよう。関数<code>convert</code>によってその問題は解決した。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 2進数への変換</span>
<span class="dt">int</span> convert( <span class="dt">int</span> n ) ;</code></pre></div>
<p>まだ我々は関数<code>convert</code>の中身を書いていないが、すでに書き終わったと仮定しよう。するとプログラムの残りの部分は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> convert( <span class="dt">int</span> n ) ;

<span class="co">// 入力</span>
<span class="dt">int</span> input()
{
    std::cout &lt;&lt; <span class="st">&quot;&gt; &quot;</span> ;
    <span class="dt">int</span> x{} ;
    std::cin &gt;&gt; x ;
    <span class="kw">return</span> x ;
}

<span class="co">// 出力</span>
<span class="dt">void</span> output( <span class="dt">int</span> binary )
{
    std::cout &lt;&lt; binary &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    <span class="co">// 入力、変換、出力のループ</span>
    <span class="kw">while</span>( <span class="kw">true</span> )
    {
        <span class="kw">auto</span> decimal = input() ;
        <span class="kw">auto</span> binary = convert( decimal ) ;
        output( binary ) ;
    } 
}</code></pre></div>
<p>あとは関数<code>convert</code>を実装すればよいだけだ。</p>
<p>関数<code>convert</code>に引数を渡したときの結果を考えてみよう。<code>convert(1010)</code>は<code>10</code>を返し、<code>convert(1111)</code>は<code>15</code>を返す。</p>
<p>では<code>convert(-1010)</code>の結果はどうなるだろうか。これは<code>-10</code>になる。</p>
<p>負数と正数の違いを考えるのは面倒だ。ここでは正数を引数として与えると10進数から2進数へ変換した答えを返してくる魔法のような関数<code>solve</code>をすでに書き終えたと仮定しよう。我々はまだ関数<code>solve</code>を書いていないが、その問題は未来の自分に押し付けよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1,0のみを使った10進数から</span>
<span class="co">// 2進数へ変換する関数</span>
<span class="dt">int</span> solve( <span class="dt">int</span> n ) ;</code></pre></div>
<p>すると、関数<code>convert</code>がやるのは負数と正数の処理だけでよい。</p>
<ol style="list-style-type: decimal">
<li>引数が正数の場合はそのまま関数<code>solve</code>に渡して<code>return</code></li>
<li>引数が負数の場合は絶対値を関数<code>solve</code>に渡して負数にして<code>return</code></li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> convert( <span class="dt">int</span> n )
{
    <span class="co">// 引数が正数の場合</span>
    <span class="kw">if</span> ( n &gt; <span class="dv">0</span> )
        <span class="co">// そのまま関数solveに渡してreturn</span>
        <span class="kw">return</span> solve( n ) ;
    <span class="kw">else</span> <span class="co">// 引数が負数の場合</span>
        <span class="co">// 絶対値を関数solveに渡して負数にしてreturn</span>
        <span class="kw">return</span> - solve( -n ) ;
}</code></pre></div>
<p><code>n</code>が負数の場合の絶対値は<code>-n</code>で得られる。その場合、関数<code>solve</code>の答えは正数なので負数にする。</p>
<p>あとは関数<code>solve</code>を実装するだけだ。</p>
<p>今回、引数の整数を10進数で表現した場合に2,3,4,5,6,7,8,9が使われている場合は考えないものとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK</span>
solve(<span class="dv">10111101</span>) ;
<span class="co">// あり得ない</span>
solve(<span class="dv">2</span>) ;</code></pre></div>
<p>再帰で問題を解くには再帰的な考え方が必要だ。再帰的な考え方では、問題の一部のみを解き、残りは自分自身に丸投げする。</p>
<p>まずとても簡単な1桁の変換を考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">0</span>) ; <span class="co">// 0</span>
solve(<span class="dv">1</span>) ; <span class="co">// 1</span></code></pre></div>
<p>引数が<code>0</code>か<code>1</code>の場合、単にその値を返すだけだ。関数<code>solve</code>には正数しか渡されないので、負数は考えなくてよい。すると、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="kw">if</span> ( n &lt;= <span class="dv">1</span> )
        <span class="kw">return</span> n ;
    <span class="kw">else</span>
        <span class="co">// その他の場合</span>
}</code></pre></div>
<p>その他の場合とは、桁数が多い場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">10</span>) ;  <span class="co">// 2</span>
solve(<span class="dv">11</span>) ;  <span class="co">// 3</span>
solve(<span class="dv">110</span>) ; <span class="co">// 4</span>
solve(<span class="dv">111</span>) ; <span class="co">// 5</span></code></pre></div>
<p>関数<code>solve</code>が解決するのは最下位桁だ。<code>110</code>の場合は<code>0</code>で、<code>111</code>の場合は<code>1</code>となる。最も右側の桁のみを扱う。数値から10進数で表記したときの最下位桁を取り出すには、10で割った余りが使える。覚えているだろうか。剰余演算子の<code>operator %</code>を。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="kw">if</span> ( n &lt;= <span class="dv">1</span> )
        <span class="kw">return</span> n ;
    <span class="kw">else</span> <span class="co">// 未完成</span>
        <span class="kw">return</span> n%<span class="dv">10</span> ;
}</code></pre></div>
<p>結果は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">10</span>) ;  <span class="co">// 0</span>
solve(<span class="dv">11</span>) ;  <span class="co">// 1</span>
solve(<span class="dv">110</span>) ; <span class="co">// 0</span>
solve(<span class="dv">111</span>) ; <span class="co">// 1</span></code></pre></div>
<p>これで関数<code>solve</code>は最下位桁に完全に対応した。しかしそれ以外の桁はどうすればいいのだろう。</p>
<p>ここで再帰的な考え方が必要だ。関数<code>solve</code>はすでに最下位桁に完全に対応している。ならば次の桁を最下位桁とした数値で関数<code>solve</code>を再帰的に呼び出せばいいのではないか。</p>
<p>以下は<code>solve(n)</code>が再帰的に呼び出す関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">solve(<span class="dv">10</span>) ;  <span class="co">// solve(1)</span>
solve(<span class="dv">11</span>) ;  <span class="co">// solve(1)</span>
solve(<span class="dv">100</span>) ; <span class="co">// solve(10)→solve(1)</span>
solve(<span class="dv">110</span>) ; <span class="co">// solve(11)→solve(1)</span>
solve(<span class="dv">111</span>) ; <span class="co">// solve(11)→solve(1)</span></code></pre></div>
<p>10進数表記された数値から最下位桁を取り除いた数値にするというのは、11を1に, 111を11にする処理だ。これは数値を10で割ればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">10</span>  / <span class="dv">10</span> ; <span class="co">// 1</span>
<span class="dv">11</span>  / <span class="dv">10</span> ; <span class="co">// 1</span>
<span class="dv">100</span> / <span class="dv">10</span> ; <span class="co">// 10</span>
<span class="dv">110</span> / <span class="dv">10</span> ; <span class="co">// 11</span>
<span class="dv">111</span> / <span class="dv">10</span> ; <span class="co">// 11</span></code></pre></div>
<p>10進数表記は桁が1つ上がると10倍される。だから10で割れば最下位桁が消える。ところで、我々は計算しようとしているのは2進数だ。2進数では桁が1つ上がると2倍される。なので、再帰的に関数<code>solve</code>を呼び出して得られた結果は2倍しなければならない。そして足し合わせる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="co">// 1桁の場合</span>
    <span class="kw">if</span> ( n &lt;= <span class="dv">1</span> )
        <span class="kw">return</span> n ; <span class="co">// 単に返す</span>
    <span class="kw">else</span> <span class="co">// それ以外</span>
        <span class="kw">return</span>
            <span class="co">// 最下位桁の計算</span>
            n%<span class="dv">10</span>
            <span class="co">// 残りの桁を丸投げする</span>
            <span class="co">// 次の桁なので2倍する</span>
            + <span class="dv">2</span> * solve( n/<span class="dv">10</span> ) ;
}</code></pre></div>
<p>冗長なコメントを除いて短くすると以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="kw">if</span> ( n &lt;= <span class="dv">1</span> )
        <span class="kw">return</span> n ;
    <span class="kw">else</span>
        <span class="kw">return</span> n%<span class="dv">10</span> + <span class="dv">2</span> * solve( n/<span class="dv">10</span> ) ;
}</code></pre></div>
<p>再帰ではないループで関数<code>solve</code>を実装するとどうなるのだろうか。</p>
<p>引数の数値が何桁あっても対応できるよう、ループで1桁ずつ処理していくのは変わらない。</p>
<p>もう一度2進数の計算を見てみよう。</p>
<p><span class="math display">\[
1010 = 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 1 \times 8 + 0 \times 4 + 1 \times 2 + 0 \times 1
\]</span></p>
<p>1桁目は0で、この値は<span class="math inline">\(0 \times 2^0\)</span>、2桁目は1で、この値は<span class="math inline">\(1 \times 2^1\)</span>になる。</p>
<p>一般に、<span class="math inline">\(i\)</span>桁目の値は<span class="math inline">\(i桁目の数字 \times 2^{i-1}\)</span>になる。</p>
<p>すると解き方としては、各桁の値を計算した和を返せばよい</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> solve( <span class="dt">int</span> n )
{
    <span class="co">// 和</span>
    <span class="dt">int</span> result = <span class="dv">0</span> ;
    <span class="co">// i桁目の数字に乗ずる値</span>
    <span class="dt">int</span> i = <span class="dv">1</span> ;

    <span class="co">// 桁がなくなれば終了</span>
    <span class="kw">while</span> ( n != <span class="dv">0</span> )
    {
        <span class="co">// 現在の桁を計算して足す</span>
        result += n%<span class="dv">10</span> * i ;
        <span class="co">// 次の桁に乗ずる値</span>
        i *= <span class="dv">2</span> ;
        <span class="co">// 桁を1つ減らす</span>
        n /= <span class="dv">10</span> ;
    }

    <span class="kw">return</span> result ;
}</code></pre></div>
<p>再帰を使うコードは、再帰を理解できれば短く簡潔でわかりやすい。ただし、再帰を理解するためにはまず再帰を理解しなければならない。</p>
<p>再帰は万能ではない。そもそも関数とは、別の関数から呼ばれるものだ。関数<code>main</code>だけは特別で、関数<code>main</code>を呼び出すことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    main() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>関数の実行が終了した場合、呼び出し元に処理が戻る。そのために関数は呼び出し元を覚えていなければならない。これには通常<code>スタック</code>と呼ばれるメモリーを消費する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }            <span class="co">// gに戻る</span>
<span class="dt">void</span> g() { f() ; }      <span class="co">// mainに戻る </span>
<span class="dt">int</span> main() { g() ; }</code></pre></div>
<p>関数の中の変数も通常<code>スタック</code>に確保される。これもメモリーを消費する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }

<span class="dt">void</span> g()
{
    <span class="dt">int</span> x {} ;
    std::cin &gt;&gt; x ;
    f() ;   <span class="co">// 関数を呼び出す</span>
    <span class="co">// 関数を呼び出したあとに変数を使う</span>
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p>このコードでは、関数<code>g</code>が変数<code>x</code>を用意し、関数<code>f</code>を呼び出し、処理が戻ったら変数<code>x</code>を使っている。このコードが動くためには、変数<code>x</code>は関数<code>f</code>が実行されている間もスタックメモリーを消費し続けなければならない。</p>
<p>スタックメモリーは有限であるので、以下のような再帰による無限ループは、いつかスタックメモリーを消費し尽して実行が止まるはずだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello()
{
    std::cout &lt;&lt; <span class="st">&quot;hello</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    hello() ;
}

<span class="dt">int</span> main() { hello() ; }</code></pre></div>
<p>しかし、大半の読者の環境ではプログラムの実行が止まらないはずだ。これはコンパイラーの末尾再帰の最適化によるものだ。</p>
<p>末尾再帰とは、関数のすべての条件分岐の末尾が再帰で終わっている再帰のことだ。</p>
<p>例えば以下は階乗を計算する再帰で書かれたループだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> factorial( <span class="dt">int</span> n )
{
    <span class="kw">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="kw">return</span> <span class="dv">0</span> ;
    <span class="kw">else</span> <span class="kw">if</span> ( n == <span class="dv">1</span> )
        <span class="kw">return</span> <span class="dv">1</span> ;
    <span class="kw">else</span>
        <span class="kw">return</span> n * factorial(n<span class="dv">-1</span>) ;
}</code></pre></div>
<p><code>factorial(n)</code>は<span class="math inline">\(1 \times 2 \times 3 \times ... \times n\)</span>を計算する。</p>
<p>この関数は、引数<code>n</code>が<code>1</code>未満であれば引数が間違っているので<code>0</code>を返す。そうでない場合で<code>n</code>が<code>1</code>であれば<code>1</code>を返す。それ以外の場合、<code>n * factorial(n-1)</code>を返す。</p>
<p>このコードは末尾再帰になっている。末尾再帰は非再帰のループに機械的に変換できる特徴を持っている。例えば以下のように、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> factorial( <span class="dt">int</span> n )
{
    <span class="dt">int</span> temp = n ;

loop :
    <span class="kw">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="kw">return</span> <span class="dv">0</span> ;
    <span class="kw">else</span> <span class="kw">if</span> ( n == <span class="dv">1</span> )
        <span class="kw">return</span> temp * <span class="dv">1</span> ;
    <span class="kw">else</span>
    {
        n = n<span class="dv">-1</span> ;
        temp *= n ;
        <span class="kw">goto</span> loop ;
    }
}</code></pre></div>
<p>関数のすべての条件分岐の末尾が再帰になっているため、機械的に関数呼び出しを<code>goto</code>文で置き換えることができる。</p>
<p>ただし、プログラミング言語C++の標準規格は、C++の実装に末尾再帰の最適化を義務付けてはいない。そのため、末尾再帰が最適化されるかどうかはC++コンパイラー次第だ。</p>
<p>再帰は強力なループの実現方法で、再帰的な問題を解くのに最適だが、落とし穴もある。</p>
<h1 id="メモリーを無限に確保する">メモリーを無限に確保する</h1>
<h2 id="これまでのまとめ">これまでのまとめ</h2>
<p>ここまで読み進めてきた読者は、逐次実行、条件分岐、ループに加えて、変数と関数を理解した。これだけの要素を習得したならば、本質的にはプログラミングはほぼできるようになったと言ってよい。ただし、まだできないことがある。動的なメモリー確保だ。</p>
<p>標準入力から<code>0</code>が入力されるまで任意個の整数値を受け取り、小さい値から順に出力するプログラムを実装しよう。以下はそのようなプログラムの実行例だ。</p>
<pre><code>$ make run
100
-100
1
6
3
999
-5000
0
-5000
-100
1
3
6
100
999</code></pre>
<p><code>0</code>が入力されるまで、1番目に、2番目に小さい値はわからない。そのため、この問題の解決には、入力をすべて保持しておく必要がある。</p>
<p>ここで必要なのは、値をいくらでも保持しておく方法と、値に順番があり、<span class="math inline">\(i\)</span>番目の値を間接的に指定して読み書きできる方法だ。その方法としてC++には標準ライブラリ<code>std::vector</code>がある。</p>
<h2 id="vector">vector</h2>
<p><code>std::vector&lt;T&gt;</code>は<code>T</code>型の値をいくらでも保持できる。<code>T</code>には保持する値の型を指定する。例えば<code>int</code>とか<code>double</code>とか<code>std::string</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数型intの値を保持するvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; vi ;

    <span class="co">// 浮動小数点数型doubleの値を保持するvector</span>
    std::vector&lt;<span class="dt">double</span>&gt; vd ;

    <span class="co">// 文字列型std::stringの値を保持するvector</span>
    std::vector&lt;std::string&gt; vs ;
}</code></pre></div>
<p><code>std::vector&lt;T&gt;</code>というのはそれ自体が型になっている。そして<code>T</code>には型を指定する。ということは、<code>vector</code>型の値を保持する<code>vector</code>も書けるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 整数型intを保持するvectorを保持するvector</span>
    std::vector&lt; std::vector&lt; <span class="dt">int</span> &gt; &gt; vvi ;
}</code></pre></div>
<p>もちろん、上の<code>vector</code>を保持する<code>vector</code>も書ける。その場合、<code>std::vector&lt;std::vector&lt;std::vector&lt;int&gt;&gt;&gt;</code>になる。この<code>vector</code>を保持する<code>vector</code>も当然書けるが省略する。</p>
<p><code>std::vector</code>型の変数にはメンバー関数<code>push_back</code>を使うことで値を保持できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v  ;

    v.push_back(<span class="dv">1</span>) ;
    v.push_back(<span class="dv">2</span>) ;
    v.push_back(<span class="dv">3</span>) ;
}</code></pre></div>
<p><code>メンバー関数</code>(member function)というのは特別な関数で、詳細はまだ説明しない。ここで覚えておくべきこととしては、メンバー関数は一部の変数に使うことができること、メンバー関数<code>f</code>を変数<code>x</code>に使うには<code>'x.f(...)'</code>のように書くこと、を覚えておこう。</p>
<p><code>std::vector</code>はメモリーの続く限りいくらでも値を保持できる。試しに1000個の整数を保持させてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">1000</span> ; ++i )
    {
        v.push_back( i ) ;
    }
}</code></pre></div>
<p>このプログラムは<code>0</code>から<code>999</code>までの1000個の整数を<code>std::vector</code>に保持させている。</p>
<p><code>std::vector</code>では保持する値のことを要素という。要素は順番を持っている。メンバー関数<code>push_back</code>は最後の要素の次に要素を追加する。最初に要素はない。もしくは0個ある空の状態だと言ってもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// vは空</span>

    <span class="co">// 要素数1、中身は{1}</span>
    v.push_back(<span class="dv">1</span>) ;
    <span class="co">// 要素数2、中身は{1,2}</span>
    v.push_back(<span class="dv">2</span>) ;
    <span class="co">// 要素数3、中身は{1,2,3}</span>
    v.push_back(<span class="dv">3</span>) ;
}</code></pre></div>
<p><code>std::vector</code>はメンバー関数<code>size()</code>で現在の要素数を取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// 0</span>
    std::cout &lt;&lt; v.size() ;
    v.push_back(<span class="dv">1</span>) ;
    <span class="co">// 1</span>
    std::cout &lt;&lt; v.size() ;
    v.push_back(<span class="dv">2</span>) ;
    <span class="co">// 2</span>
    std::cout &lt;&lt; v.size() ;
}</code></pre></div>
<p>せっかく値を入れたのだから取り出したいものだ。<code>std::vector</code>ではメンバー関数<code>at(i)</code>を使うことで、<code>i</code>番目の要素を取り出すことができる。この<code>i</code>のことを添字、インデックスと呼ぶ。ここで注意してほしいのは、最初の要素は0番目で、次の要素は1番目だということだ。最後の要素は<code>size()-1</code>番目になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        v.push_back(i) ;
    }

    <span class="co">// vの中身は{0,1,2,3,4,5,6,7,8,9}</span>

    <span class="co">// 0, 0番目の最初の要素</span>
    std::cout &lt;&lt; v.at(<span class="dv">0</span>) ;
    <span class="co">// 4, 4番目の要素</span>
    std::cout &lt;&lt; v.at(<span class="dv">4</span>) ;
    <span class="co">// 9, 9番目の最後の要素</span>
    std::cout &lt;&lt; v.at(<span class="dv">9</span>) ;
}</code></pre></div>
<p>この例ではループを使っている。読者はすでにループについては理解しているはずだ。上のコードが理解できないのであれば、もう一度ループの章に戻って学び直すべきだ。</p>
<p>もし<code>at(i)</code>に要素数を超える<code>i</code>を渡してしまった場合どうなるのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v { } ;
    v.push_back(<span class="dv">0</span>) ;
    <span class="co">// vには0番目の要素しかない</span>
    <span class="co">// 1番目は誤り</span>
    std::cout &lt;&lt; v.at(<span class="dv">1</span>) ;
}</code></pre></div>
<p>実行して確かめてみよう。</p>
<pre><code>$ ./program
terminate called after throwing an instance of &#39;std::out_of_range&#39;
  what():  vector::_M_range_check: __n (which is 1) &gt;= this-&gt;size() (which is 1)
Aborted (core dumped)</code></pre>
<p>なにやら恐ろしげなメッセージが表示されるではないか。しかし心配することはない。このメッセージはむしろうれしいメッセージだ。変数<code>v</code>に1番目の要素がないことを発見してくれたという実行時のエラーメッセージだ。すでに学んだように、エラーメッセージは恐れるものではない。エラーメッセージはうれしいものだ。エラーメッセージが出たらありがとう。エラーメッセージがあるおかげでバグの存在がわかる。</p>
<p>このメッセージの本当の意味はいずれ例外やデバッガーを解説する章で説明するとして、<code>vector</code>の要素数を超える指定をしてはいけないことを肝に銘じておこう。もちろん、<code>-1</code>もダメだ。</p>
<p>メンバー関数<code>at(i)</code>に与える引数<code>i</code>の型は整数型ではあるのだが<code>int</code>型ではない。<code>std::size_t</code>型という特殊な型になる。メンバー関数<code>size</code>も同様に<code>std::size_t</code>型を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// std::size_t型</span>
    std::size_t size = v.size() ;

    v.push_back(<span class="dv">0</span>) ;

    <span class="co">// std::size_t型</span>
    std::size_t index = <span class="dv">0</span> ;
    v.at( index ) ;
}</code></pre></div>
<p>なぜ<code>int</code>型ではダメなのか。その謎は整数の章で明らかになる。ここでは<code>std::size_t</code>型は負数が使えない整数型だということだけ覚えておこう。<code>std::size_t</code>型に<code>-1</code>はない。<code>vector</code>の要素指定では負数は使えないので、負数が使えない変数を使うのは理にかなっている。</p>
<p>さて、これまでに学んだ知識だけを使って、<code>std::vector</code>のすべての要素を順番どおりに出力するコードが書けるはずだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="kw">for</span> ( <span class="dt">int</span> iota = <span class="dv">0</span> ; iota != <span class="dv">10</span> ; ++iota )
    {
        v.push_back(iota) ;
    }

    <span class="kw">for</span> ( std::size_t index = <span class="dv">0</span> ; index != v.size() ; ++index )
    {
        std::cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>このコードが書けるということは、もう標準入力から<code>0</code>が入力されるまで任意個の値を受け取り、入力された順番で出力するプログラムも書けるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> input()
{
    <span class="dt">int</span> x{} ;
    std::cin &gt;&gt; x ;
    <span class="kw">return</span> x ;
}
<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="dt">int</span> x { } ;

    <span class="co">// 入力</span>
    <span class="kw">while</span> ( ( x = input() ) != <span class="dv">0</span> )
    {
        v.push_back( x ) ;
    }

    <span class="co">// 出力</span>
    <span class="kw">for</span> ( std::size_t index = <span class="dv">0</span> ; index != v.size() ; ++index )
    {
        std::cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>入力された順番に出力できるということは、その逆順にも出力できるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( std::size_t index = v.size()<span class="dv">-1</span> ; index != <span class="dv">0</span> ; --index )
{
    std::cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
}

std::cout &lt;&lt; v.at(<span class="dv">0</span>) ;</code></pre></div>
<p>最後に<code>'v.at(0)'</code>を出力しているのは、ループが<code>'i == 0'</code>のときに終了してしまうからだ。つまり最後に出力すべき<code>vector</code>最初の要素である<code>'v.at(0)'</code>が出力されない。</p>
<p><code>std::size_t</code>型は<code>-1</code>が使えないため、このようなコードになってしまう。<code>int</code>型を使えば負数は使えるのだが、<code>int</code>型と<code>std::size_t</code>型の比較はさまざまな理由で問題がある。その理由は整数の章で深く学ぶことになるだろう。</p>
<p>ところで、問題は入力された整数を小さい順に出力することだった。この問題を考えるために、まず<code>vector</code>の中に入っている要素から最も小さい整数の場所を探すプログラムを考えよう。</p>
<p>問題を考えるにあたって、いちいち標準入力から入力を取るのも面倒なので、あらかじめ<code>vector</code>に要素を入れておく方法を学ぶ。実は、<code>vector</code>の要素は以下のように書けば指定することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素{1, 2, 3}</span>
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;

    <span class="co">// 1</span>
    <span class="kw">auto</span> x = v.at(<span class="dv">0</span>) ;
    <span class="co">// 2</span>
    <span class="kw">auto</span> y = v.at(<span class="dv">1</span>) ;
    <span class="co">// 3</span>
    <span class="kw">auto</span> z = v.at(<span class="dv">2</span>) ;
}</code></pre></div>
<p>この例では、<code>1</code>, <code>2</code>, <code>3</code>の整数が書かれた順番であらかじめ<code>vector</code>の要素として入った状態になる。</p>
<p>さて、以下のような要素の<code>vector</code>から最も小さい整数を探すプログラムを考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;</code></pre></div>
<p>これを見ると、最も小さい整数は4番目(最初の要素は0番目なので4番目)にある<code>2</code>だ。ではどうやって探すのだろうか。</p>
<p>解決方法としては先頭から末尾まで要素を1つずつ比較して、最も小さい要素を見つけ出す。まず0番目の<code>8</code>が最も小さいと仮定する。現在わかっている中で最も小さい要素のインデックスを記録するために変数<code>min</code>を作っておこう。</p>
<pre><code>min = 0
8 3 7 4 2 9 3
^</code></pre>
<p>次に1番目の<code>3</code>と<code>min</code>番目を比較する。1番目の方が小さいので変数<code>min</code>に<code>1</code>を代入する。</p>
<pre><code>min = 1
8 3 7 4 2 9 3
  ^</code></pre>
<p>2番目の<code>7</code>と<code>min</code>番目を比較するとまだ1番目の方が小さい。3番目の4と比較してもまだ<code>min</code>番目の方が小さい。</p>
<p>4番目の<code>2</code>と<code>min</code>番目を比較すると、4番目の方が小さい。変数<code>min</code>に<code>4</code>を代入しよう。</p>
<pre><code>min = 4
8 3 7 4 2 9 3
        ^</code></pre>
<p>5番目と6番目も<code>min</code>番目より大きいので、これで変数<code>min</code>に代入された4番目の要素が最も小さいことがわかる。</p>
<p><code>vector</code>の変数を<code>v</code>、要素数を<code>size</code>とする。変数<code>min</code>には現在わかっている中で最も小さい要素へのインデックスが代入される。</p>
<ol style="list-style-type: decimal">
<li>変数<code>min</code>に0を代入する</li>
<li><code>size</code>回のループを実行する</li>
<li>変数<code>index</code>に<code>0</code>から<code>size-1</code>までの整数を代入する</li>
<li><code>'v.at(index) &lt; v.at(min)'</code>ならば<code>min = index</code></li>
</ol>
<p>さっそく書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// vectorの変数をv</span>
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;
    <span class="co">// 要素数をsizeとする</span>
    std::size_t size = v.size() ;

    <span class="co">// 変数minに0を代入する</span>
    std::size_t min = <span class="dv">0</span> ;

    <span class="co">// size回のループを実行する</span>
    <span class="co">// 変数iに0からsize-1までの整数を代入する</span>
    <span class="kw">for</span> ( std::size_t index = <span class="dv">1</span> ; index != size ; ++index )
    {
        <span class="co">// &#39;v.at(index) &lt; v.at(min)&#39;ならばmin = index</span>
        <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
            min = index ;
    }

    <span class="co">// 一番小さい値を出力</span>
    std::cout &lt;&lt; v.at(min) ;
}</code></pre></div>
<p>うまくいった。</p>
<p>ところで、最終的に解きたい問題とは、<code>vector</code>のすべての要素を小さい順に出力するということだ。すると、もっと小さい要素を出力した次に、2番目に小さい要素、3番目に小さい要素・・・と出力していく必要がある。</p>
<p>2番目に小さい要素を見つけるためには、1番目に小さい要素を探さなければよい。そこで、発見した最も小さい要素と先頭の要素を交換してしまい、先頭は無視して最も小さい要素を探すことを繰り返すと実現できる。</p>
<p>例えば以下のような要素があるとして、</p>
<pre><code>8 3 7 4 2 9 3
        ^</code></pre>
<p>最も小さい要素である4番目の<code>2</code>と0番目の<code>8</code>を交換する。</p>
<pre><code>2 3 7 4 8 9 3
^       ^
+-------+</code></pre>
<p>そして、0番目は無視して最も小さい要素を探す。</p>
<pre><code>3 7 4 8 9 3
^</code></pre>
<p>この場合、最も小さいのは0番目と5番目の<code>3</code>だ。どちらも同じだが今回は0番目を選ぶ。もともと0番目にあるので0番目と0番目を交換した結果は変わらない。</p>
<p>そして、新しい0番目は無視して最も小さい要素を探す。</p>
<pre><code>7 4 8 9 3
        ^</code></pre>
<p>今度は4番目の<code>3</code>だ。これも先頭と交換する</p>
<pre><code>3 4 8 9 7
^       ^
+-------+</code></pre>
<p>これを繰り返していけば、小さい順に要素を探していくことができる。</p>
<p>この処理を行うコードを考えるために、先ほどと似たようなコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;
    std::size_t size = v.size() ;

    <span class="co">// この部分を繰り返す？ </span>
    { <span class="co">// これ全体が1つのブロック文</span>
        std::size_t min = <span class="dv">0</span> ;

        <span class="kw">for</span> ( std::size_t index = <span class="dv">1</span> ; index != size ; ++index )
        {
            <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
                min = index ;
        }

        <span class="co">// 出力</span>
        std::cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;

        <span class="co">// 先頭と交換</span>
    }
}</code></pre></div>
<p>このコードはそのまま使えない。今回考えた方法では、先頭が1つずつずれていく。そのために、最も小さい要素を探すループを、さらにループさせる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 現在の先頭</span>
<span class="kw">for</span> ( std::size_t head = <span class="dv">0</span> ; head != size ; ++head )
{
    <span class="co">// 現在の先頭であるmin番目を仮の最小の要素とみなすのでhead</span>
    std::size_t min = head ;    
    <span class="co">// 現在の先頭の次の要素から探すのでhead + 1</span>
    <span class="kw">for</span> ( std::size_t index = head + <span class="dv">1</span> ; index != size ; ++index )
    {
        <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
            min = index ;
    }

    std::cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;

    <span class="co">// 先頭と交換</span>
}</code></pre></div>
<p>次に先頭(0番目)と現在見つけた最小の要素(<code>min</code>番目)を交換する方法を考えよう。</p>
<p><code>vector</code>の<code>n</code>番目の要素の値を<code>x</code>に変更するには、単に<code>v.at(n) = x</code>と書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    v.at(<span class="dv">0</span>) = <span class="dv">4</span> ;
    <span class="co">// vは{4,2,3}</span>
}</code></pre></div>
<p>すると、<code>vector</code>の<code>i</code>番目の要素に<code>j</code>番目の要素値を入れるには<code>'v.at(i) = v.at(j)'</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    v.at(<span class="dv">0</span>) = v.at(<span class="dv">2</span>) ;
    <span class="co">// vは{3,2,3}</span>
}</code></pre></div>
<p>変数とまったく同じだ。</p>
<p>しかし、変数<code>a</code>に変数<code>b</code>の値を代入すると、変数<code>a</code>の元の値は消えてしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">2</span> ;

    <span class="co">// aの元の値は上書きされる</span>
    a = b ;
    <span class="co">// a == 2</span>
    b = a ;
    <span class="co">// b == 2</span>
}</code></pre></div>
<p>変数<code>a</code>, <code>b</code>の値を交換するためには、変数への代入の前に、別の変数に値を一時退避しておく必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">2</span> ;

    <span class="co">// 退避</span>
    <span class="kw">auto</span> temp = a ;

    a = b ;
    b = temp ;

    <span class="co">// a == 2</span>
    <span class="co">// b == 1</span>
}</code></pre></div>
<p>さて、これで問題を解く準備はすべて整った。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">3</span> } ;
    std::size_t size = v.size() ;
   
    <span class="co">// 先頭をずらすループ </span>
    <span class="kw">for</span> ( std::size_t head = <span class="dv">0</span> ; head != size ; ++head )
    {
        std::size_t min = head ;
        <span class="co">// 現在の要素の範囲から最小値を見つけるループ</span>
        <span class="kw">for</span> ( std::size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
        {
            <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
                min = index ;
        }
        <span class="co">// 出力</span>
        std::cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot; &quot;</span>s ;

        <span class="co">// 最小値を先頭と交換</span>
        <span class="kw">auto</span> temp = v.at(head) ;
        v.at(head) = v.at(min) ;
        v.at(min) = temp ;
    }

    <span class="co">// 実行したあと</span>
}</code></pre></div>
<p>ところで、このプログラムの「実行したあと」地点での<code>vector</code>の中身はどうなっているだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">8</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">9</span>,<span class="dv">3</span> } ;

    <span class="co">// 上と同じコードなので省略</span>

    <span class="co">// 実行したあと</span>
    std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    
    <span class="kw">for</span> ( std::size_t index = <span class="dv">0</span>, size = v.size() ; index != size ; ++index )
    {
        std::cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>これを実行すると以下のようになる。</p>
<pre><code>$ make run
2 3 3 4 7 8 9
2 3 3 4 7 8 9</code></pre>
<p>なんと<code>vector</code>の要素も小さい順に並んでいる。この状態のことを、ソートされているという。ループの中で最も小さい値を出力していく代わりに、まずソートして先頭から値を出力してもよいということだ。</p>
<p>ソートにはさまざまな方法があるが、今回使ったのは選択ソート(selection sort)というアルゴリズムだ。</p>
<p><code>vector</code>を使う方法には、イテレーターというもっと便利な方法があるが、それはイテレーターの章で説明する。</p>
<h1 id="デバッグprintfデバッグ">デバッグ：printfデバッグ</h1>
<p>ループと多数の要素の集合を扱えるようになったので、読者はもう相当複雑な処理をするプログラムでも書けるようになった。処理が複雑になってくると増えるのがバグだ。</p>
<p>この章では、伝統ある<code>printfデバッグ</code>を紹介する。</p>
<p><code>printfデバッグ</code>とは、プログラムの実行中に知りたい情報を出力することだ。<code>printf</code>とはC言語の伝統ある出力用のライブラリに由来する名前だが、本書では<code>iostream</code>を使う。</p>
<h2 id="実践例">実践例</h2>
<p>例えば前章で実装したように<code>vector</code>の要素を選択ソートでソートしたいとする。</p>
<p>選択ソートとは、要素の集合の中から0番目に来るべき要素の場所を探し、0番目の要素と交換し、1番目に来るべき要素の場所を探し、1番目の要素と交換し・・・を要素の数だけ繰り返すことによって要素全体をソートする方法だ。</p>
<p>以下のように書いたとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">3</span>,<span class="dv">8</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">4</span>,<span class="dv">1</span>,<span class="dv">7</span> } ;
    <span class="kw">auto</span> size = v.size() ;

    <span class="kw">for</span> ( std::size_t head = <span class="dv">0</span> ; head != size ; ++head )
    {
        <span class="kw">auto</span> min = head ;
        <span class="kw">for</span> ( std::size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
        {
            <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
                min = index ;
        }
        
        <span class="kw">auto</span> temp = v.at(head) ;
        v.at(head) = v.at(min) ;
        v.at(min) = v.at(head) ;
    }

    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != size ; ++i )
    {
        std::cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
    }
}</code></pre></div>
<p>さっそく実行してみよう。</p>
<pre><code>$ make run
1 1 1 1 1 1 1 1 7</code></pre>
<p>コンパイルはできるが、なぜかうまく動かない。コードのどこかが間違っているのはわかる。しかしどこが間違っているのかはわからない。さっそく<code>printfデバッグ</code>により問題のある箇所を特定してみよう。</p>
<p><code>printfデバッグ</code>を行うには、まずコード中の間違っていそうな箇所にアタリをつける必要がある。</p>
<p>問題がどこにあるかわからないが、ループのどこかで間違っていそうだ。一番外側のループにアタリをつけよう。ループが実行されるごとに変数<code>v</code>の中身を表示してみる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( std::size_t head = <span class="dv">0</span> ; head != size ; ++head )
{
    <span class="co">// printfデバッグ</span>
        std::cout &lt;&lt; <span class="st">&quot;debug: head = &quot;</span>s &lt;&lt; head &lt;&lt; <span class="st">&quot;, v = { &quot;</span>s;
        <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != v.size() ; ++i )
        {
            std::cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot; &quot;</span>s ;
        }
        std::cout &lt;&lt; <span class="st">&quot;}</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    <span class="co">// printfデバッグ</span></code></pre></div>
<p>そして実行した結果が以下だ。</p>
<pre><code>$ make run
debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
1 1 1 1 1 1 1 1 7 </code></pre>
<p>なぜか<code>1</code>が増えている。明らかにおかしい。しかしまだ問題の特定にまでは至らない。</p>
<p>内側のループにも<code>printfデバッグ</code>を追加してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> min = head ;
<span class="kw">for</span> ( std::size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
{
    <span class="co">// printfデバッグ</span>
        std::cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot;, &quot;</span>s ;
    <span class="co">// printfデバッグ</span>

    <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
        min = index ;
}
<span class="co">// printfデバッグ</span>
    std::cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ</span></code></pre></div>
<p>そして実行する。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
8, 2, 5, 6, 9, 4, 1, 7, 
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
2, 5, 6, 9, 4, 1, 7, 
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
5, 6, 9, 4, 1, 7, 
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
6, 9, 4, 1, 7, 
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
9, 4, 1, 7, 
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
4, 1, 7, 
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
1, 7, 
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
7, 
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }

1 1 1 1 1 1 1 1 7 </code></pre>
<p>あまりいい情報は得られないようだ。問題はここではないらしい。</p>
<p>ひょっとしたら大小比較が間違っているのかもしれない。確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( std::size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
{

    <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
    {
        std::cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &lt; &quot;</span>s &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        min = index ;
    }
    <span class="kw">else</span>
    {
        std::cout &lt;&lt; v.at(index) &lt;&lt; <span class="st">&quot; &gt;= &quot;</span>s &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>実行結果は長いので一部だけ記載しておく。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
8 &gt;= 3
2 &lt; 3
5 &gt;= 2
6 &gt;= 2
9 &gt;= 2
4 &gt;= 2
1 &lt; 2
7 &gt;= 1

debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
2 &lt; 8
5 &gt;= 2
6 &gt;= 2
9 &gt;= 2
4 &gt;= 2
1 &lt; 2
7 &gt;= 1</code></pre>
<p>大小比較も問題ないようだ。では最終的に見つけた最も小さい値は、本当に最も小さい値だろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 最小値を探すループ</span>
<span class="kw">for</span> ( std::size_t index = head<span class="dv">+1</span> ; index != size ; ++index )
{
    <span class="co">// より小さい値があればそれを現在の最小値とする</span>
    <span class="kw">if</span> ( v.at(index) &lt; v.at(min) )
        min = index ;
}

<span class="co">// printfデバッグ</span>
    std::cout &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ </span></code></pre></div>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 6, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 9, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 4, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
1
debug: v = { 1, 1, 1, 1, 1, 1, 1, 1, 7, }
7
1 1 1 1 1 1 1 1 7 </code></pre>
<p>見つけた値は最も小さいようだ。しかし毎回<code>1</code>になる。<code>1</code>が残っているのだから当然だが、なぜ残っているのだろう。</p>
<p>ひょっとしたら要素の交換が間違っているのかもしれない。<code>printfデバッグ</code>してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// printfデバッグ </span>
    std::cout &lt;&lt; <span class="st">&quot;debug before: &quot;</span>s &lt;&lt;  v.at(head) &lt;&lt; <span class="st">&quot;,  &quot;</span> &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ</span>

v.at(head) = v.at(min) ;
v.at(min) = v.at(head) ;

<span class="co">// printfデバッグ</span>
    std::cout &lt;&lt; <span class="st">&quot;debug after : &quot;</span>s &lt;&lt; v.at(head) &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; v.at(min) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
<span class="co">// printfデバッグ</span></code></pre></div>
<p><code>&quot;debug before:&quot;</code>は交換前、<code>&quot;debug after:&quot;</code>は交換後の2つの要素の値だ。</p>
<p>以下は実行結果の一部だ。</p>
<pre><code>debug: v = { 3, 8, 2, 5, 6, 9, 4, 1, 7, }
debug before: 3,  1
debug after : 1, 1
debug: v = { 1, 8, 2, 5, 6, 9, 4, 1, 7, }
debug before: 8,  1
debug after : 1, 1
debug: v = { 1, 1, 2, 5, 6, 9, 4, 1, 7, }
debug before: 2,  1
debug after : 1, 1
debug: v = { 1, 1, 1, 5, 6, 9, 4, 1, 7, }</code></pre>
<p>これを見ると、要素の値の交換が正しく行われていないことがわかる。</p>
<p>問題の場所がわかったので、さっそくコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">v.at(head) = v.at(min) ;
v.at(min) = v.at(head) ;</code></pre></div>
<p>これは要するに以下のコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">0</span> ;
<span class="dt">int</span> b = <span class="dv">1</span> ;

a = b ; <span class="co">// a = 1</span>
b = a ; <span class="co">// b = 1</span></code></pre></div>
<p>変数<code>a</code>, <code>b</code>の値を交換したい場合、変数<code>a</code>に変数<code>b</code>を代入したあとに、変数<code>b</code>に変数<code>a</code>を代入する処理は誤りだ。なぜならば、変数<code>b</code>の代入のときには、変数<code>a</code>の値は変数<code>b</code>の値になってしまっているからだ。</p>
<p>前章で学んだように、こういう場合、別の変数に値を代入して退避させておく。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">0</span> ;
<span class="dt">int</span> b = <span class="dv">1</span> ;

<span class="dt">int</span> temp = a ;
a = b ;
b = temp ;</code></pre></div>
<p>こうして<code>printfデバッグ</code>によって問題が解決した。</p>
<h2 id="stdcerr"><code>std::cerr</code></h2>
<p><code>printfデバッグ</code>として標準出力である<code>std::cout</code>に出力すると、プログラムの通常の標準出力と混ざって見づらくなる。例えば以下のプログラムを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1 * 2 * 3 * ... * nを計算するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="dt">int</span> n{} ;
    std::cin &gt;&gt; n ;
    <span class="kw">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="kw">return</span> <span class="dv">-1</span> ;

    <span class="dt">int</span> sum = <span class="dv">1</span> ;  
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">2</span> ; i &lt;= n ; ++i )
    {
        sum *= i ;

        <span class="co">// printfデバッグ</span>
            std::cout &lt;&lt; <span class="st">&quot;debug: &quot;</span>s &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="co">// printfデバッグ</span>
    }

    std::cout &lt;&lt; sum ;
}</code></pre></div>
<p>この場合、標準エラー出力を使うとプログラムの通常の出力と<code>printfデバッグ</code>用の出力を分けることができる。</p>
<p>標準エラー出力を使うには、<code>std::cout</code>の代わりに<code>std::cerr</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 標準出力</span>
    std::cout &lt;&lt; <span class="st">&quot;standard output</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="co">// 標準エラー出力</span>
    std::cerr &lt;&lt; <span class="st">&quot;standard error output</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このプログラムを実行すると一見すべて同じように出力されているように見える。</p>
<pre><code>$ make run
standard output
standard error output</code></pre>
<p>違いはリダイレクトやパイプを使うとわかる。</p>
<pre><code>$ ./program &gt; /dev/null
standard error output
$ ./program | grep error
standard error output </code></pre>
<p>標準出力には<code>&quot;standard output\n&quot;</code>しか出力されていない。通常のリダイレクトやパイプで扱われるのも標準出力だけだ。そのため、<code>/dev/null</code>にリダイレクトすると標準エラー出力しか見えないし、<code>grep</code>にパイプしても標準出力しか受け取らない。</p>
<p>標準出力と標準エラー出力を別々にリダイレクトする方法もある。</p>
<pre><code>$ ./program &gt; cout.txt 2&gt; cerr.txt</code></pre>
<p>これを実行すると、ファイル<code>cout.txt</code>には<code>&quot;standard output\n&quot;</code>が、ファイル<code>cerr.txt</code>には<code>&quot;standard error output\n&quot;</code>が出力されている。</p>
<p>これを使って先ほどのプログラムを書き直すと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1 * 2 * 3 * ... * nを計算するプログラム</span>
<span class="dt">int</span> main()
{
    <span class="dt">int</span> n{} ;
    std::cin &gt;&gt; n ;
    <span class="kw">if</span> ( n &lt; <span class="dv">1</span> )
        <span class="kw">return</span> <span class="dv">-1</span> ;

    <span class="dt">int</span> sum = <span class="dv">1</span> ;  
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">2</span> ; i &lt;= n ; ++i )
    {
        sum *= i ;

        <span class="co">// printfデバッグ</span>
            <span class="co">// 標準エラー出力</span>
            std::cerr &lt;&lt; <span class="st">&quot;debug: &quot;</span>s &lt;&lt; i &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; sum &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
        <span class="co">// printfデバッグ</span>
    }
    <span class="co">// 標準出力</span>
    std::cout &lt;&lt; sum ;
}</code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p><code>printfデバッグ</code>はコード中のどこに問題があるかを絞り込むための方法だ。プログラムに問題が存在し、問題の発生の有無はプログラムの状態を調べることで判断できるが、コード中のどこに問題が存在するかわからないとき、<code>printfデバッグ</code>で問題の箇所を絞り込むことができる。</p>
<p><code>printfデバッグ</code>のやり方は以下のとおり。</p>
<ol style="list-style-type: decimal">
<li>コード中の間違っていそうな箇所にアタリをつける</li>
<li>プログラムの状態を出力する</li>
<li>出力結果が期待どおりかどうかを調べる</li>
</ol>
<p><code>printfデバッグ</code>は原始的だが効果的なデバッグ方法だ。あとの章ではデバッガーというより高級でプログラマーらしいデバッグ方法も紹介するが、そのような高級なデバッグ方法が使えない環境でも、<code>printfデバッグ</code>ならば使えることは多い。</p>
<h1 id="整数">整数</h1>
<p>始めに書いておくがこの章はユーモア欠落症患者によって書かれており極めて退屈だ。しかし、整数の詳細はすべてのプログラマーが理解すべきものだ。心して読むとよい。</p>
<h2 id="整数リテラル">整数リテラル</h2>
<p>整数リテラルとは整数の値を直接ソースファイルに記述する機能だ。本書ではここまで何の説明もなくリテラルを使っていた。例えば以下のように。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">123</span> ;
    <span class="dt">int</span> b = <span class="dv">0</span> ;
    <span class="dt">int</span> c = <span class="dv">-123</span> ;
}</code></pre></div>
<p>ここでは、<code>'123'</code>, <code>'0'</code>がリテラルだ。<code>'-123'</code>というのは演算子<code>operator -</code>に整数リテラル<code>123</code>を適用したものだ。リテラルは<code>123</code>だけだ。ただしこれは細かい詳細なのでいまはそれほど気にしなくてもよい。</p>
<h3 id="進数リテラル">10進数リテラル</h3>
<p>10進数リテラルは最も簡単で我々が日常的に使っている数の表記方法と同じものだ。接頭語は何も使わず数字には<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で123</span>
<span class="dt">int</span> decimal = <span class="dv">123</span> ;</code></pre></div>
<p>ただし、10進数リテラルの先頭を<code>0</code>にしてはならない。これは8進数リテラルになってしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で83</span>
<span class="dt">int</span> octal = <span class="bn">0123</span> ;</code></pre></div>
<h3 id="進数リテラル-1">2進数リテラル</h3>
<p>2進数リテラルは接頭語<code>'0b'</code>, <code>'0B'</code>から始まる。数字には<code>0</code>, <code>1</code>を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で5</span>
<span class="dt">int</span> binary = <span class="bn">0b1010</span> ;

<span class="co">// 0bと0Bは同じ</span>
<span class="dt">int</span> a = <span class="bn">0B1010</span> ;</code></pre></div>
<h3 id="進数リテラル-2">8進数リテラル</h3>
<p>8進数リテラルは接頭語<code>'0'</code>から始まる。数字には<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で83</span>
<span class="dt">int</span> octal = <span class="bn">0123</span> ;

<span class="co">// 10進数で342391</span>
<span class="dt">int</span> a = <span class="bn">01234567</span> ;</code></pre></div>
<h3 id="進数リテラル-3">16進数リテラル</h3>
<p>16進数リテラルは接頭語<code>'0x'</code>, <code>'0X'</code>から始まる。数字には<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, <code>9</code>, <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>, <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>が使える。ローマ字の大文字と小文字は意味が同じだ。<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>がそれぞれ<code>10</code>, <code>11</code>, <code>12</code>, <code>13</code>, <code>14</code>, <code>15</code>を意味する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10進数で291</span>
<span class="dt">int</span> hexadecimal = <span class="bn">0x123</span> ;

<span class="co">// 0xと0Xは同じ</span>
<span class="dt">int</span> a = <span class="er">0X123</span> ;

<span class="co">// 10進数で10</span>
<span class="dt">int</span> b = <span class="bn">0xa</span> ;

<span class="co">// 10進数で15</span>
<span class="dt">int</span> c = <span class="bn">0xf</span> ;</code></pre></div>
<h3 id="数値区切り">数値区切り</h3>
<p>長い整数リテラルは読みにくい。例えば<code>10000000</code>と<code>100000000</code>はどちらが大きくて具体的にどのくらいの値なのかがわからない。C++には整数リテラルを読みやすいように区切ることのできる数値区切りという機能がある。整数リテラルはシングルクオート文字(<code>'</code>)で区切ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a =   <span class="dv">1000&#39;0000</span> ;
    <span class="dt">int</span> b = <span class="dv">1&#39;0000&#39;0000</span> ;
}</code></pre></div>
<p>区切り幅は何文字でもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1&#39;22&#39;333&#39;4444&#39;55555</span> ;
}</code></pre></div>
<p>10進数整数リテラル以外でも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> a = <span class="bn">0b10101010&#39;11110000&#39;00001111</span> ;
    <span class="kw">auto</span> b = <span class="bn">07&#39;7&#39;5</span> ;
    <span class="kw">auto</span> c = <span class="bn">0xde&#39;ad&#39;be&#39;ef</span> ;
}</code></pre></div>
<h2 id="整数の仕組み">整数の仕組み</h2>
<h3 id="情報の単位">情報の単位</h3>
<p>0から100までの整数を表現するには101種類の状態を表現できる必要がある。コンピューターはどうやって整数を表現しているのかをここで学ぶ。</p>
<p>情報の最小単位はビット(bit)だ。ビットは2種類の状態を表現できる。たとえば<code>bool</code>型は<code>true</code>/<code>false</code>という2種類の状態を表現できる。</p>
<p>しかし、2種類の状態しか表現できない整数は使いづらい。0もしくは1しか表現できない整数とか、100もしく1000しか表現できない整数は使い物にならない。</p>
<p>また、ビットという単位も扱いづらい。コンピューターは膨大な情報を扱うので、ビットをいくつかまとめたバイト(byte)を単位として情報を扱っている。1バイトが何ビットであるかは環境により異なる。本書では最も普及している1バイトは8ビットを前提にする。</p>
<p>1ビットは2種類の状態を表現できるので、1バイトの中の8ビットは<span class="math inline">\(2^8 = 256\)</span>種類の状態を表現できる。2バイトならば16ビットとなり、<span class="math inline">\(2^{16} = 65536\)</span>種類の状態を表現できる。</p>
<h3 id="バイトで表現された整数">1バイトで表現された整数</h3>
<p>整数の表現方法について理解するために、1バイトで表現された整数を考えよう。</p>
<p>1バイトは8ビットであり256種類の状態を表現できる。整数を0から正の方向の数だけ表現したいとすると、0から255までの値を表現できることになる。</p>
<p>その場合、1バイトの整数の中の8ビットはちょうど2進数8桁で表現できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 0</span>
<span class="kw">auto</span> zero = <span class="bn">0b00000000</span> ;
<span class="co">// 255</span>
<span class="kw">auto</span> max  = <span class="bn">0b11111111</span> ;</code></pre></div>
<p>一番左側の桁が最上位桁で、一番右側の桁が最下位桁だ。これを最上位ビット、最下位ビットともいう。</p>
<p>正数だけを表現するならば話は簡単だ。1バイトの整数は0から255までの値を表現できる。これを符号なし整数(unsigned integer)という。</p>
<p>では負数を表現するにはどうしたらいいだろう。正数と負数を両方扱える整数表現のことを、符号付き整数(signed integer)という。1バイトは256種類の状態しか表現できないので、もし<span class="math inline">\(-1\)</span>を表現したい場合、<span class="math inline">\(-1\)</span>から254までの値を扱えることになる。</p>
<p><span class="math inline">\(-1\)</span>しか扱えないのでは実用的ではないので、負数と正数を同じ種類ぐらい表現したい。256の半分は128だが、1バイトで表現された整数は<span class="math inline">\(-128\)</span>から128までを表現することはできない。0があるからだ。0を含めると、1バイトの整数は最大で<span class="math inline">\(-128\)</span>から127までか、<span class="math inline">\(-127\)</span>から128までを表現できる。どちらかに偏ってしまう。</p>
<p>では実際に1バイトで負数も表現できる整数表現を考えてみよう。</p>
<h4 id="符号ビット">符号ビット</h4>
<p>誰でも思いつきそうな表現方法に、符号ビットがある。これは最上位ビットを符号の有無を管理するフラグとして用いることにより、下位7ビットの値の符号を指定する方法だ。</p>
<p>符号ビット表現では<span class="math inline">\(-1\)</span>と1は以下のように表現できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1</span>
<span class="bn">0b0&#39;0000001</span>
<span class="co">// -1</span>
<span class="bn">0b1&#39;0000001</span></code></pre></div>
<p>最上位ビットが0であれば正数、1であれば負数だ。</p>
<p>この一見わかりやすい表現方法には問題がある。まず表現できる値の範囲は<span class="math inline">\(-127\)</span>から<span class="math inline">\(+127\)</span>だ。先ほど、1バイトで正負になるべく均等に値を割り振る場合、<span class="math inline">\(-128\)</span>から<span class="math inline">\(+127\)</span>、もしくは<span class="math inline">\(-127\)</span>から<span class="math inline">\(+128\)</span>までを扱えると書いた。しかし符号ビット表現では<span class="math inline">\(-127\)</span>から<span class="math inline">\(+127\)</span>しか扱えない。残りの1はどこにいったのか。</p>
<p>答えはゼロにある。符号ビット表現ではゼロに2通りの表現がある。<span class="math inline">\(+0\)</span>と<span class="math inline">\(-0\)</span>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// +0</span>
<span class="bn">0b0&#39;0000000</span>
<span class="co">// -0</span>
<span class="bn">0b1&#39;0000000</span></code></pre></div>
<p><span class="math inline">\(+0\)</span>も<span class="math inline">\(-0\)</span>もゼロには違いない。しかし符号ビットが独立して存在しているために、ゼロが2種類ある。</p>
<p>符号ビットは電子回路で実装するには複雑という問題もある。</p>
<h4 id="の補数">1の補数</h4>
<p>1の補数は負数を絶対値を2進数で表したときの各ビットを反転させた値で表現する。たとえば<span class="math inline">\(-1\)</span>は1(<code>0b00000001</code>)の1の補数の<code>0b11111110</code>で表現される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// -1</span>
<span class="bn">0b11111110</span>

<span class="co">// -2</span>
<span class="bn">0b11111101</span></code></pre></div>
<p><span class="math inline">\(-1\)</span>と<span class="math inline">\(-2\)</span>を足すと結果は<span class="math inline">\(-3\)</span>だ。この計算を1の補数で行うとどうなるか。</p>
<p>まず1の補数表現による<span class="math inline">\(-1\)</span>と<span class="math inline">\(-2\)</span>を足す。</p>
<pre><code>   11111110
+) 11111101
-----------
 1&#39;11111011</code></pre>
<p>この結果は9ビットになる。この整数は8ビットなので、9ビット目を表現することはできない。ただし1の補数表現の計算では、もし9ビット目が繰り上がった場合は、演算結果に1を足す取り決めがある。</p>
<pre><code>   11111011
+)        1
-----------
   11111100</code></pre>
<p>1の補数による<span class="math inline">\(-3\)</span>は3の各ビットを反転したものだ。3は<code>0b00000011</code>で、そのビットを反転させたものは<code>0b11111100</code>だ。上の計算結果は<span class="math inline">\(-3\)</span>の1の補数表現になった。</p>
<p>もう1つ例を見てみよう。5と<span class="math inline">\(-2\)</span>を足すと3になる。</p>
<pre><code>   00000101
+) 11111101
-----------
 1&#39;00000010</code></pre>
<p>繰り上がりが発生したので1を足すと</p>
<pre><code>   00000010
+)        1
-----------
   00000011</code></pre>
<p>3になった。</p>
<p>1の補数は引き算も足し算で表現できるので電子回路での実装が符号ビットよりもやや簡単になる。</p>
<p>ただし、1の補数にも問題がある。0の表現だ。0というのは<code>0b00000000</code>だが1の補数では<span class="math inline">\(-x\)</span>は<span class="math inline">\(x\)</span>の各ビット反転ということを適用すると、<span class="math inline">\(-0\)</span>は<code>0b11111111</code>になる。すると、符号ビット表現と同じく、<span class="math inline">\(+0\)</span>と<span class="math inline">\(-0\)</span>が存在することになる。したがって、1の補数8ビットで表現できる範囲は<span class="math inline">\(-127\)</span>から<span class="math inline">\(+127\)</span>になる。</p>
<h4 id="の補数-1">2の補数</h4>
<p>符号ビットと1の補数による負数表現にある問題は、2の補数表現で解決できる。</p>
<p>2の補数表現による負数は1の補数表現の負数に、繰り上がり時に足すべき1を加えた値になる。</p>
<p><span class="math inline">\(-1\)</span>は1の補数表現では、1(<code>0b00000001</code>)の各ビットを反転させた値になる(<code>0b11111110</code>)。2の補数表現では、1の補数表現に1を加えた値になるので、<code>0b11111111</code>になる。</p>
<p>同様に、<span class="math inline">\(-2\)</span>は<code>0b11111110</code>に、<span class="math inline">\(-3\)</span>は<code>0b11111101</code>になる。</p>
<!--
00000011
11111100
-->
<p>2の補数表現の<span class="math inline">\(-1\)</span>と<span class="math inline">\(-2\)</span>を足すと以下のようになる。</p>
<pre><code>   11111111
+) 11111110
-----------
 1&#39;11111101</code></pre>
<p>9ビット目の繰り上がりを無視すると、計算結果は<code>0b11111101</code>になる。これは2の補数表現による<span class="math inline">\(-3\)</span>と同じだ。</p>
<p>5と<span class="math inline">\(-2\)</span>の計算も見てみよう。</p>
<pre><code>   00000101
+) 11111110
-----------
 1&#39;00000011</code></pre>
<p>結果は3(<code>0b00000011</code>)だ。</p>
<p>2の補数表現は引き算も足し算で実装できる上に、ゼロの表現方法は1つで、<span class="math inline">\(+0\)</span>と<span class="math inline">\(-0\)</span>が存在しない。8ビットの2の補数表現された整数の範囲は<span class="math inline">\(-128\)</span>から<span class="math inline">\(+127\)</span>になる。とても便利な負数の表現方法なのでほとんどのコンピューターで採用されている。</p>
<h2 id="整数型">整数型</h2>
<p>C++にはさまざまな整数型が存在する。C++はCから引き継いだ歴史的な経緯により、整数型の文法がわかりにくくなっている。</p>
<p>基本的には、符号付き整数型と符号なし整数型に分かれている。</p>
<p>符号付き整数型としては、<code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, <code>long long int</code>が存在する。符号付き整数型は負数を表現できる。</p>
<p>符号なし整数型としては、<code>unsigned char</code>, <code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code>, <code>unsigned long long int</code>が存在する。符号なし整数型は負数を表現できない。</p>
<h3 id="int型">int型</h3>
<p><code>int型</code>は最も基本となる整数型だ。C++で数値を扱う場合、多くは<code>int</code>型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x = <span class="dv">123</span> ;</code></pre></div>
<p>整数リテラルの型は通常は<code>int</code>型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">auto</span> x = <span class="dv">123</span> ;</code></pre></div>
<p><code>unsigned int型</code>は符号のない<code>int</code>型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">unsigned</span> <span class="dt">int</span> x = <span class="dv">123</span> ;</code></pre></div>
<p>整数リテラルの末尾に<code>u</code>/<code>U</code>と書いた場合、<code>unsigned int</code>型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">auto</span> x = <span class="dv">123</span> ;
<span class="co">// unsigned int</span>
<span class="kw">auto</span> y = <span class="dv">123u</span> ;</code></pre></div>
<p>特殊なルールとして、単に<code>signed</code>と書いた場合、それは<code>int</code>になる。<code>unsigned</code>と書いた場合は、<code>unsigned int</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="dt">signed</span> a = <span class="dv">1</span> ;
<span class="co">// unsigned int</span>
<span class="dt">unsigned</span> b = <span class="dv">1</span> ;</code></pre></div>
<p><code>signed int</code>と書いた場合、<code>int型</code>になる。<code>signed int</code>は<code>int</code>の冗長な書き方だ。</p>
<h3 id="long-int型">long int型</h3>
<p><code>long int型</code>は<code>int型</code>以上の範囲の整数を扱える型だ。具体的な整数型の値の範囲は実装依存だが、<code>long int型</code>は<code>int型</code>の表現できる整数の範囲はすべて表現でき、かつ<code>int型</code>以上の範囲の整数型を表現できるかもしれない型だ。</p>
<p><code>unsigned long int型</code>は符号なしの<code>long int</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">long</span> <span class="dt">int</span> a = <span class="dv">123</span> ;
<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">int</span> b = <span class="dv">123</span> ;</code></pre></div>
<p>特殊なルールとして、単に<code>long</code>と書いた場合、それは<code>long int</code>になる。<code>unsigned long</code>と書いた場合、<code>unsigned long int</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// long int</span>
<span class="dt">long</span> a = <span class="dv">1</span> ;
<span class="co">// unsigned long int</span>
<span class="dt">unsigned</span> <span class="dt">long</span> b = <span class="dv">1</span> ;</code></pre></div>
<p>通常、<code>int</code>を省略して単に<code>long</code>と書くことが多い。</p>
<p>整数リテラルの値が<code>int型</code>で表現できない場合、<code>long型</code>になる。例えば、<code>int型</code>で100億を表現できないが、<code>long型</code>では表現できる実装の場合、以下の変数<code>a</code>は<code>long型</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 100億</span>
<span class="kw">auto</span> a = <span class="dv">100&#39;0000&#39;0000</span> ;</code></pre></div>
<p>整数リテラルの値が<code>long</code>では表現できないが<code>unsigned long</code>では表現できる場合、<code>unsigned long型</code>になる。</p>
<p>整数リテラルの末尾に<code>l</code>/<code>L</code>と書いた場合、値にかかわらず<code>long型</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">auto</span> a = <span class="dv">123</span> ;
<span class="co">// long</span>
<span class="kw">auto</span> b = <span class="dv">123l</span> ;
<span class="co">// long</span>
<span class="kw">auto</span> c = <span class="dv">123L</span> ;</code></pre></div>
<p>符号なし整数型を意味する<code>u</code>/<code>U</code>と組み合わせることもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// unsigned long</span>
<span class="kw">auto</span> a = <span class="dv">123ul</span> ;
<span class="kw">auto</span> b = <span class="dv">123lu</span> ;</code></pre></div>
<p>順番と大文字小文字の組み合わせは自由だ。</p>
<h3 id="long-long-int型">long long int型</h3>
<p><code>long long int型</code>は<code>long int型</code>以上の範囲の整数を扱える型だ。<code>long</code>と同じく<code>long long</code>は<code>long long int</code>と同じで、<code>unsigned long long int</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// long long int</span>
<span class="dt">long</span> <span class="dt">long</span> a = <span class="dv">1</span> ;
<span class="co">// unsigned long long int</span>
<span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> b = <span class="dv">1</span> ;</code></pre></div>
<p>整数リテラルの値が<code>long型</code>でも表現できないときは、<code>long long</code>が使われる。<code>long long</code>でも表現できない場合は<code>unsigned long long</code>が使われる。</p>
<p>整数リテラルの末尾に<code>ll</code>/<code>LL</code>と書くと<code>long long int型</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// long long int</span>
<span class="kw">auto</span> a = <span class="dv">123ll</span> ;
<span class="co">// long long int</span>
<span class="kw">auto</span> b = <span class="dv">123LL</span> ;
<span class="co">// unsigned long long int</span>
<span class="kw">auto</span> c = <span class="dv">123ull</span> ;</code></pre></div>
<h3 id="short-int型">short int型</h3>
<p><code>short int型</code>は<code>int型</code>より小さい範囲の値を扱う整数型だ。<code>long</code>, <code>long long</code>と同様に、<code>unsigned short int</code>型もある。単に<code>short</code>と書くと、<code>short int</code>と同じ意味になる。</p>
<p>整数リテラルで<code>short int</code>型を表現する方法はない。</p>
<h3 id="char型">char型</h3>
<p><code>char型</code>はやや特殊で、<code>char</code>, <code>signed char</code>, <code>unsigned char</code>の3種類の型がある。<code>signed char</code>と<code>char</code>は別物だ。<code>char型</code>は整数型であり、あとで説明するように文字型でもある。<code>char型</code>の符号の有無は実装ごとに異なる。</p>
<h2 id="整数型のサイズ">整数型のサイズ</h2>
<p>整数型を含む変数のサイズは、<code>sizeof演算子</code>で確認することができる。<code>sizeof(T)</code>は<code>T</code>に型名や変数名を入れることで、サイズを取得することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="kw">sizeof</span>(<span class="dt">int</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    <span class="dt">int</span> x{} ;
    std::cout &lt;&lt; <span class="kw">sizeof</span>(x) ;
}</code></pre></div>
<p><code>sizeof演算子</code>は<code>std::size_t型</code>を返す。<code>vector</code>の章でも出てきたこの型は実装依存の符号なし型であると定義されている。単位はバイトだ。</p>
<p>以下が各種整数型のサイズを出力するプログラムだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = []( std::size_t s )
    { std::cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">sizeof</span>(<span class="dt">char</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">short</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">int</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">long</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">long</span> <span class="dt">long</span> ) ) ;
}</code></pre></div>
<p>このプログラムを筆者の環境で実行した結果が以下になる。</p>
<pre><code>1
2
4
8
8</code></pre>
<p>どうやら筆者の環境では、<code>char</code>が1バイト、<code>short</code>が2バイト、<code>int</code>が4バイト、<code>long</code>と<code>long long</code>が8バイトのようだ。この結果は環境ごとに異なるので読者も自分で<code>sizeof</code>演算子をさまざまな型に適用して試してほしい。</p>
<h2 id="整数型の表現できる値の範囲">整数型の表現できる値の範囲</h2>
<p>整数型の表現できる値の最小値と最大値は<code>std::numeric_limits&lt;T&gt;</code>で取得できる。最小値は<code>::min()</code>を、最大値は<code>::max()</code>で得られる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; std::numeric_limits&lt;<span class="dt">int</span>&gt;::min() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; std::numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;
}</code></pre></div>
<p>実行結果</p>
<pre><code>-2147483648
2147483647</code></pre>
<p>どうやら筆者の環境では<code>int</code>型は<span class="math inline">\(−21億4748万3648\)</span>から21億4748万3647までの範囲の値を表現できるようだ。</p>
<p><code>unsigned int</code>はどうだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; std::numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::min() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; std::numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::max() ;
}</code></pre></div>
<p>実行結果</p>
<pre><code>0
4294967295</code></pre>
<p>どうやら筆者の環境では<code>unsigned int</code>型は0から42億9496万7295までの範囲の値を表現できるようだ。<code>sizeof(int)</code>が4バイトであり、1バイトが8ビットの筆者の環境では自然な値だ。符号なしの4バイト整数型は0から<span class="math inline">\(2^{32}-1\)</span>までの範囲の値を表現できる。符号付き4バイト整数型は<span class="math inline">\(-2^{31}\)</span>から<span class="math inline">\(2^{31}-1\)</span>までの範囲の値を表現できる。</p>
<p>整数の最小値を<span class="math inline">\(-1\)</span>したり、最大値を<span class="math inline">\(+1\)</span>した場合、何が起こるのだろうか。</p>
<p>符号なし整数型の場合は簡単だ。最小値<span class="math inline">\(-1\)</span>は最大値になる。最大値<span class="math inline">\(+1\)</span>は最小値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">unsigned</span> <span class="dt">int</span> min = std::numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::min() ;
    <span class="dt">unsigned</span> <span class="dt">int</span> max = std::numeric_limits&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;::max() ;

    <span class="dt">unsigned</span> <span class="dt">int</span> min_minus_one = min - <span class="dv">1u</span> ;
    <span class="dt">unsigned</span> <span class="dt">int</span> max_plus_one = max + <span class="dv">1u</span> ;

    std::cout &lt;&lt; min &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; max &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; min_minus_one &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; max_plus_one ;
}</code></pre></div>
<p>8ビットの符号なし整数型があるとして、最小値は<code>0b00000000</code>(0)になるが、この値を<span class="math inline">\(-1\)</span>すると<code>0b11111111</code>(255)となり、これは最大値になる。逆に、最大値である<code>0b11111111</code>(255)に<span class="math inline">\(+1\)</span>すると<code>0b00000000</code>(0)となり、これは最小値になる。</p>
<p>これを数学的に厳密に書くと、「符号なし整数は算術モジュロ<span class="math inline">\(2^n\)</span>の法に従う。ただし<span class="math inline">\(n\)</span>は整数を表現する値のビット数である」となる。</p>
<p>符号付き整数型の場合、挙動は定められていない。ただし、一般に普及している2の補数表現の場合は、以下のような挙動になることが多い。</p>
<p>符号付き整数型の最小値を<span class="math inline">\(-1\)</span>すると最大値になり、最大値を<span class="math inline">\(+1\)</span>すると最小値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
     <span class="dt">int</span> min = std::numeric_limits&lt;<span class="dt">int</span>&gt;::min() ;
     <span class="dt">int</span> max = std::numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;

     <span class="dt">int</span> min_minus_one = min - <span class="dv">1</span> ;
     <span class="dt">int</span> max_plus_one = max + <span class="dv">1</span> ;

    std::cout &lt;&lt; min &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; max &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; min_minus_one &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; max_plus_one ;
}</code></pre></div>
<p>これはなぜか。2の補数表現の8ビットの符号付き整数の最小値は<code>0b10000000</code>(<span class="math inline">\(-128\)</span>)だが、これを<span class="math inline">\(-1\)</span>すると<code>0b01111111</code>(127)となり、これは最大値となる。逆に最大値<code>0b01111111</code>(127)を<span class="math inline">\(+1\)</span>すると<code>0b10000000</code>(<span class="math inline">\(-128\)</span>)となり、これは最小値となる。</p>
<h2 id="整数型の変換">整数型の変換</h2>
<p>整数型にはここで紹介しただけでも、さまざまな型がある。同じ型同士を使った方がよい。</p>
<p>以下は型が一致している例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">123</span> ;
    <span class="dt">long</span> b = <span class="dv">123l</span> ;
    <span class="dt">long</span> <span class="dt">long</span> c = <span class="dv">123ll</span> ;

    <span class="dt">unsigned</span> <span class="dt">int</span> d = <span class="dv">123u</span> ; 
}</code></pre></div>
<p>以下は型が一致していない例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// intからshort</span>
    <span class="dt">short</span> a = <span class="dv">123</span> ;
    <span class="co">// longからint</span>
    <span class="dt">int</span> b = <span class="dv">123l</span> ;

    <span class="co">// intからunsigned int</span>
    <span class="dt">unsigned</span> <span class="dt">int</span> c = <span class="dv">123</span> ;
    <span class="co">// unsigned intからint</span>
    <span class="dt">int</span> d = <span class="dv">123u</span> ;
}</code></pre></div>
<p>代入や演算で整数型が一致しない場合、整数型の変換が行われる。</p>
<p>整数型の変換で注意すべきこととしては、変換元の値を変換先の型で表現できない場合の挙動だ。</p>
<p>たとえば<code>short</code>型と<code>int</code>型の表現できる最大値を調べるプログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;short: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">short</span>&gt;::max() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;int: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">int</span>&gt;::max() ;
}</code></pre></div>
<p>これを実行すると筆者の環境では以下のようになる。</p>
<pre><code>short: 32767
int: 2147483647</code></pre>
<p>どうやら筆者の環境では<code>short</code>型は約3万、<code>int</code>型は約21億ぐらいの値を表現できるようだ。</p>
<p>では約3万までしか表現できない<code>short</code>型に4万を代入しようとするとどうなるのか。これは1つ前の整数型の表現できる値の範囲で説明したものと同じことが起こる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">short</span> x = <span class="dv">40000</span> ;
    std::cout &lt;&lt; x ;
}</code></pre></div>
<p>このプログラムを実行した結果は実装ごとに異なる。例えば筆者の環境では以下のようになる。</p>
<pre><code>-25536</code></pre>
<p>整数型の変換は暗黙的に行われるが、明示的に行うこともできる。明示的な変換には<code>static_cast&lt;T&gt;(e)</code>を使う。<code>static_cast</code>は値<code>e</code>を型<code>T</code>の値に変換する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">123</span> ;
    <span class="dt">short</span> y = <span class="kw">static_cast</span>&lt;<span class="dt">short</span>&gt;(x) ;
}</code></pre></div>
<h1 id="浮動小数点数">浮動小数点数</h1>
<p>浮動小数点数の型には<code>float</code>, <code>double</code>, <code>long double</code>がある。<code>float</code>が最も精度が低く、<code>double</code>は<code>float</code>と同等以上の精度を持ち、<code>long double</code>は<code>double</code>と同等以上の精度を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">float</span> f = <span class="fl">1.0</span> ;
<span class="dt">double</span> d = <span class="fl">1.0</span> ;
<span class="dt">long</span> <span class="dt">double</span> ld = <span class="fl">1.0</span> ;</code></pre></div>
<p>以下は浮動小数点数型の変数のサイズを調べるコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = [](std::size_t s )
    { std::cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    print( <span class="kw">sizeof</span>(<span class="dt">float</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">double</span>) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">long</span> <span class="dt">double</span>) ) ;
}</code></pre></div>
<p>筆者の環境では以下のように出力される。</p>
<pre><code>4
8
16</code></pre>
<p>浮動小数点数は一見整数と同じように扱える上、小数点以下の値も扱える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> a = <span class="fl">1.23</span> ;
<span class="dt">double</span> b = <span class="fl">0.00001</span> ;</code></pre></div>
<p>浮動小数点数が表現できる最大値は実装依存だが、通常はかなり大きな値を表現できる。</p>
<p>しかし、浮動小数点数は値を正確に表現しているわけではない。例えば以下のコードを実行してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 1万</span>
    <span class="dt">float</span> a = <span class="fl">10000.0</span> ;
    <span class="co">// 1万分の1</span>
    <span class="dt">float</span> b = <span class="fl">0.0001</span> ;

    <span class="co">// 1万足す1万分の1</span>
    <span class="dt">float</span> c = a + b ;

    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; b &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; c ;
}</code></pre></div>
<p>変数<code>a</code>の値は1万、変数<code>b</code>の値は1万分の1だ。変数<code>c</code>の値は<code>a+b</code>で<code>10000.0001</code>となるはずだが結果はどうだろう。</p>
<pre><code>10000
0.0001
10000</code></pre>
<p>変数<code>c</code>の値は<code>10000.0001</code>ではない。この謎は浮動小数点数を学べば明らかになる。</p>
<h2 id="浮動小数点数リテラル">浮動小数点数リテラル</h2>
<h3 id="進浮動小数点数リテラル">10進浮動小数点数リテラル</h3>
<p>浮動小数点数リテラルの最も簡単な書き方は10進数で整数部を書き、小数点<code>'.'</code>を書き、続けて小数部を書く。末尾が<code>f</code>/<code>F</code>なら<code>float</code>型、末尾がなければ<code>double</code>型、末尾が<code>l</code>/<code>L</code>なら<code>long double</code>型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// float</span>
<span class="kw">auto</span> a = <span class="fl">123.456f</span> ;
<span class="kw">auto</span> b = <span class="fl">123.456F</span> ;

<span class="co">// double</span>
<span class="kw">auto</span> c = <span class="fl">123.456</span> ;

<span class="co">// long double</span>
<span class="kw">auto</span> d = <span class="fl">123.456l</span> ;
<span class="kw">auto</span> e = <span class="fl">123.456L</span> ;</code></pre></div>
<h3 id="進数の仮数と指数による表記">10進数の仮数と指数による表記</h3>
<p><code>123.456</code>という値について考えてみよう。この値は以下のように表現することができる。</p>
<p><span class="math display">\[1.23456 \times 10^{2}\]</span></p>
<p>あるいは以下のように表現することもできる。</p>
<p><span class="math display">\[123456 \times 10^{-3}\]</span></p>
<p>あるいは以下のようにも表現できる。</p>
<p><span class="math display">\[123.456 \times 10^{0}\]</span></p>
<p>一般に、値は以下のように表現できるということだ。</p>
<p><span class="math display">\[a \times 10^{b}\]</span></p>
<p>浮動小数点数リテラルのもう1つの文法として、この<code>a</code>と<code>b</code>を指定するものがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 値はすべて123.456</span>
<span class="kw">auto</span> a = <span class="fl">1.23456e2</span> ;
<span class="kw">auto</span> b = <span class="fl">123456e-3</span> ;
<span class="kw">auto</span> c = <span class="fl">123.456e0</span> ;
<span class="kw">auto</span> d = <span class="fl">123.456E0</span> ;</code></pre></div>
<p>この文法は、<code>a</code>と<code>b</code>に<code>e</code>/<code>E</code>を挟むことによって浮動小数点数の値を指定する。</p>
<p>この<code>a</code>を仮数部(fractional part)、<code>b</code>を指数部(exponent part)という。仮数のことはほかにも、coefficient, significand, mantissaなどと呼ばれたりもする。</p>
<p>そして、指数は底が10になる。</p>
<p>浮動小数点数は、値を正確に表現しているのではなく、仮数と指数の組み合わせで表現している。浮動小数点数が浮動と呼ばれる理由は、指数の存在によって小数点数が浮いているかのように動くからだ。</p>
<p>例えば、仮数と指数がともに符号付き1バイトの整数で表現された2バイトの浮動小数点数があるとする。指数、仮数ともに、<span class="math inline">\(-128\)</span>から127までの範囲の整数を表現できる。この浮動小数点数は10000(1万)も100000000(1億)も1000000000000(1兆)も表現できる。それぞれ、<code>1e4</code>, <code>1e8</code>, <code>1e12</code>だ。</p>
<p>しかし、この浮動小数点数では1000100010000(1兆1億1万)を表現できない。なぜならば、この値を正確に表現するには、<code>100010001e4</code>を表現できる必要があるが、仮数は100010001を表現できないからだ。</p>
<p>浮動小数点数は値を必ずしも正確に表現できない。その代わり、とても大きな値や、とても小さな値を表現できる。</p>
<p>浮動小数点数の型を表す末尾の<code>f</code>/<code>F</code>/<code>l</code>/<code>L</code>は同じように使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// float</span>
<span class="kw">auto</span> a = <span class="fl">1.0e0f</span> ;
<span class="co">// double</span>
<span class="kw">auto</span> b = <span class="fl">1.0e0</span> ;
<span class="co">// long double</span>
<span class="kw">auto</span> c = <span class="fl">1.0e0l</span> ;</code></pre></div>
<h3 id="進数の仮数と指数による表記-1">16進数の仮数と指数による表記</h3>
<p>浮動小数点数の仮数部と指数部によるリテラルは、16進数で記述することもできる。</p>
<p>文法は、<code>0x</code>から始め、16進数の仮数部を書き、<code>e</code>/<code>E</code>の代わりに<code>p</code>/<code>P</code>を使い、指数部を10進数で指定する。このときの指数部の底は2になる。</p>
<p>値は</p>
<p><span class="math display">\[仮数 \times 2^{指数}\]</span></p>
<p>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 5496</span>
<span class="dt">double</span> a = <span class="bn">0xabc</span><span class="fl">.0</span>p0 ;
<span class="co">// 7134</span>
<span class="dt">double</span> b = <span class="bn">0xde</span>.fp5 ;</code></pre></div>
<h2 id="浮動小数点数の表現と特性">浮動小数点数の表現と特性</h2>
<p>浮動小数点数は指数と仮数で表現される。浮動小数点数の表現はさまざまだが、多くのアーキテクチャーでは国際標準規格のISO/IEC/IEEE 60559:2011が使われている。これは米国電気電子学会の規格IEEE 754-2008と同じ内容になっている。その大本はIntelが立案した規格、IEEE 754-1985だ。一般にはIEEE 754(アイトリプルイー 754)という名称で知られている。</p>
<p>IEEE 754では、浮動小数点数は符号ビット、仮数部、指数部からなる。本書ではIEEE 754を前提として、浮動小数点数で気を付けるべき特性を説明する。</p>
<h3 id="と-0.0"><span class="math inline">\(+0.0\)</span>と<span class="math inline">\(-0.0\)</span></h3>
<p>IEEE 754では符号ビットがあるので、ゼロには2種類ある。正のゼロと負のゼロだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="fl">0.0</span> &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; <span class="fl">-0.0</span> ;
}</code></pre></div>
<p><span class="math inline">\(+0.0\)</span>と<span class="math inline">\(-0.0\)</span>の違いを浮動小数点数で表現することはできるが、値を比較すると同じものだとみなされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// a, bは異なるビットパターンを持つ</span>
    <span class="dt">double</span> a = <span class="fl">+0.0</span> ;
    <span class="dt">double</span> b = <span class="fl">-0.0</span> ;

    <span class="co">// true</span>
    <span class="dt">bool</span> c = a == b ;
}</code></pre></div>
<h3 id="と-無限大"><span class="math inline">\(+∞\)</span>と<span class="math inline">\(-∞\)</span>(無限大)</h3>
<p>IEEE 754の浮動小数点数は正の無限と負の無限を表現できる。</p>
<p>浮動小数点数の値としての無限は、計算の結果として現れるほか、<code>numeric_limits&lt;T&gt;::infinity()</code>を使って取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> a = std::numeric_limits&lt;<span class="dt">double</span>&gt;::infinity() ;
    <span class="dt">double</span> b = -std::numeric_limits&lt;<span class="dt">double</span>&gt;::infinity() ;

    std::cout &lt;&lt; a &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s &lt;&lt; b ;
}</code></pre></div>
<h3 id="nannot-a-number">NaN(Not a Number)</h3>
<p>NaN(Not a Number)は計算結果が未定義の場合を表現する浮動小数点数の特別な値だ。</p>
<p>計算結果が未定義な場合とは、例えばゼロで除算する場合だ。</p>
<p>値としてのNaNは<code>numeric_limits&lt;T&gt;::quiet_NaN()</code>で取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> NaN = std::numeric_limits&lt;<span class="dt">double</span>&gt;::quiet_NaN() ;
    std::cout &lt;&lt; NaN ;
}</code></pre></div>
<p>NaNとの比較結果はすべて<code>false</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> NaN = std::numeric_limits&lt;<span class="dt">double</span>&gt;::quiet_NaN() ;

    <span class="co">// すべてfalse</span>
    <span class="dt">bool</span> a = NaN == <span class="fl">0.0</span> ;
    <span class="dt">bool</span> b = NaN != <span class="fl">0.0</span> ;
    <span class="dt">bool</span> c = NaN == NaN ;
    <span class="dt">bool</span> d = NaN != NaN ;
    <span class="dt">bool</span> e = NaN &lt; <span class="fl">0.0</span> ;
}</code></pre></div>
<p>整数であれば、<code>'a == b'</code>が<code>false</code>であるならば、<code>'a != b'</code>なのだと仮定してもよいが、こと浮動小数点数の場合、NaNの存在があるために必ずしもそうとは限らない。上の例でわかるように、NaNとの比較はすべて<code>false</code>になる。</p>
<h3 id="有効桁数">有効桁数</h3>
<p>浮動小数点数は正確な値のすべての桁数を表現できない。表現できるのは仮数部が何桁を正確に表現できるかに依存している。この有効桁数は、<code>numeric_limits&lt;T&gt;::digits10</code>で取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; <span class="st">&quot;float: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">float</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;double: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;long double: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">long</span> <span class="dt">double</span>&gt;::digits10 &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>浮動小数点数型<code>T</code>の<code>numeric_limits&lt;T&gt;</code>にはもう1つ、<code>max_digits10</code>がある。これは浮動小数点数を10進数表記にして、その10進数表記を浮動小数点数に戻したときに、浮動小数点数としての値を精度が落ちることなく再現できる桁数のことだ。</p>
<p>もう1つ興味深い値としては、<code>numeric_limits&lt;T&gt;::epsilon()</code>がある。これは浮動小数点数の1と比較可能な最小の値との差だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout
        &lt;&lt; <span class="st">&quot;float: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">float</span>&gt;::epsilon() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;double: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">double</span>&gt;::epsilon() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s
        &lt;&lt; <span class="st">&quot;long double: &quot;</span>s &lt;&lt; std::numeric_limits&lt;<span class="dt">long</span> <span class="dt">double</span>&gt;::epsilon() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<h2 id="浮動小数点数同士の変換">浮動小数点数同士の変換</h2>
<p>浮動小数点数型は相互に変換できる。変換先の浮動小数点数型が変換元の値を完全に表現できるならばその値に、できないのであれば近い値に変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> a = <span class="fl">1.23456789</span> ;

    <span class="co">// 変換</span>
    <span class="dt">float</span> b = a ;
    <span class="co">// 変換</span>
    <span class="dt">long</span> <span class="dt">double</span> c = a ;
}</code></pre></div>
<p>異なる浮動小数点数同士を演算すると、<code>float</code>&lt;<code>double</code>&lt;<code>long double</code>の順で大きい浮動小数点数型に合わせて変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// float</span>
    <span class="kw">auto</span> a = <span class="fl">1.0f</span> + <span class="fl">1.0f</span> ;
    <span class="co">// double</span>
    <span class="kw">auto</span> b = <span class="fl">1.0f</span> + <span class="fl">1.0</span> ;
    <span class="co">// long double</span>
    <span class="kw">auto</span> c = <span class="fl">1.0f</span> + <span class="fl">1.0l</span> ;
}</code></pre></div>
<h2 id="浮動小数点数と整数の変換">浮動小数点数と整数の変換</h2>
<p>浮動小数点数型を整数型に変換すると、小数部が切り捨てられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">double</span> a = <span class="fl">1.9999</span> ;
    <span class="co">// 1</span>
    <span class="dt">int</span> x = a ;
}</code></pre></div>
<p>変換元の浮動小数点数から小数部を切り捨てた値が変換先の整数型で表現できなかった場合は、何が起こるかわからない。</p>
<p>整数型を浮動小数点数型に変換すると、変換元の整数の値が変換先の浮動小数点数型で正確に表現できる場合はその値に、そうでない場合は表現できる最も近い値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="co">// 1.0</span>
    <span class="dt">double</span> b = a ;
}</code></pre></div>
<p>浮動小数点数と整数を演算した場合、浮動小数点数型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// double</span>
    <span class="kw">auto</span> a = <span class="fl">1.0</span> + <span class="dv">1</span> ;
    <span class="kw">auto</span> b = <span class="dv">1</span> + <span class="fl">1.0</span> ;

    <span class="co">// float</span>
    <span class="kw">auto</span> c = <span class="fl">1.0f</span> + <span class="dv">1</span> ;
}</code></pre></div>
<h1 id="名前">名前</h1>
<p>プログラミング言語C++にはさまざまな名前が出てくる。変数、関数、型など、さまざまなものに名前が付いている。この章では名前について学ぶ。</p>
<h2 id="キーワード">キーワード</h2>
<p>一部の名前はキーワードとして予約され、特別な意味を持つ。キーワードは名前として使うことができない。</p>
<p>キーワードの一覧は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">alignas</span>         <span class="kw">alignof</span>     <span class="kw">asm</span>         <span class="kw">auto</span>        <span class="dt">bool</span>            <span class="kw">break</span>
<span class="kw">case</span>            <span class="kw">catch</span>       <span class="dt">char</span>        <span class="dt">char16_t</span>    <span class="dt">char32_t</span>        <span class="kw">class</span>
concept         <span class="dt">const</span>       <span class="kw">constexpr</span>   <span class="kw">const_cast</span>  <span class="kw">continue</span>        <span class="kw">decltype</span>
<span class="kw">default</span>         <span class="kw">delete</span>      <span class="kw">do</span>          <span class="dt">double</span>      <span class="kw">dynamic_cast</span>    <span class="kw">else</span>
<span class="kw">enum</span>            <span class="kw">explicit</span>    <span class="kw">export</span>      <span class="dt">extern</span>      <span class="kw">false</span>           <span class="dt">float</span>
<span class="kw">for</span>             <span class="kw">friend</span>      <span class="kw">goto</span>        <span class="kw">if</span>          <span class="kw">inline</span>          <span class="dt">int</span>
<span class="dt">long</span>            <span class="dt">mutable</span>     <span class="kw">namespace</span>   <span class="kw">new</span>         <span class="kw">noexcept</span>        <span class="kw">nullptr</span>
<span class="kw">operator</span>        <span class="kw">private</span>     <span class="kw">protected</span>   <span class="kw">public</span>      <span class="dt">register</span>        <span class="kw">reinterpret_cast</span>
requires        <span class="kw">return</span>      <span class="dt">short</span>       <span class="dt">signed</span>      <span class="kw">sizeof</span>          <span class="dt">static</span>
<span class="kw">static_assert</span>   <span class="kw">static_cast</span> <span class="kw">struct</span>      <span class="kw">switch</span>      <span class="kw">template</span>        <span class="kw">this</span>
<span class="dt">thread_local</span>    <span class="kw">throw</span>       <span class="kw">true</span>        <span class="kw">try</span>         <span class="kw">typedef</span>         <span class="kw">typeid</span>
<span class="kw">typename</span>        <span class="kw">union</span>       <span class="dt">unsigned</span>    <span class="kw">using</span>       <span class="kw">virtual</span>         <span class="dt">void</span>
<span class="dt">volatile</span>        <span class="dt">wchar_t</span>     <span class="kw">while</span></code></pre></div>
<h2 id="名前に使える文字">名前に使える文字</h2>
<p>名前というのは根本的には識別子と呼ばれる文字列で成り立っている。</p>
<p>C++では識別子にラテンアルファベット小文字、大文字、アラビア数字、アンダースコア、を使うことができる。以下がその文字の一覧だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span>
_</code></pre></div>
<p>小文字と大文字は区別される。名前<code>a</code>と名前<code>A</code>は別の名前だ。</p>
<p>ただし、名前はアラビア数字で始まってはならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> <span class="er">123abc</span> = <span class="dv">0</span> ; <span class="co">// エラー</span></code></pre></div>
<p>名前にダブルアンダースコア(<code>__</code>)が含まれているものは予約されているので使ってはならない。ダブルアンダースコアとはアンダースコア文字が2つ連続したものをいう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 使ってはならない</span>
<span class="co">// すべてダブルアンダースコアを含む</span>
<span class="dt">int</span> __ = <span class="dv">0</span> ;
<span class="dt">int</span> a__ = <span class="dv">0</span> ;
<span class="dt">int</span> __a = <span class="dv">0</span> ;</code></pre></div>
<p>アンダースコアに大文字から始まる名前も予約されているので使ってはならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 使ってはならない</span>
<span class="co">// アンダースコアに大文字から始まる</span>
<span class="dt">int</span> _A = <span class="dv">0</span> ;</code></pre></div>
<p>アンダースコアに小文字から始まる名前もグローバル名前空間で予約されているので使ってはならない。グローバル名前空間についてはこのあと説明する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 使ってはならない</span>
<span class="co">// アンダースコアに小文字から始まる</span>
<span class="dt">int</span> _a = <span class="dv">0</span> ;</code></pre></div>
<p>予約されているというのは、C++コンパイラーがその名前をC++の実装のために使うかもしれないということだ。例えばC++コンパイラーは<code>_A</code>という名前を特別な意味を持つものとして使うかもしれないし、その名前の変数や関数をプログラムに追加するかもしれない。</p>
<h2 id="宣言と定義">宣言と定義</h2>
<p>C++では、名前は使う前に宣言しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ; <span class="co">// 宣言</span>
    x = <span class="dv">1</span> ; <span class="co">// 使用</span>
}</code></pre></div>
<p>宣言する前に使うことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、名前xは宣言されていない。</span>
    x = <span class="dv">1</span> ; 

    <span class="dt">int</span> x = <span class="dv">0</span> ;
}</code></pre></div>
<p>C++では多くの名前は宣言と定義に分かれている。宣言と定義の分離は関数が一番わかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 関数の宣言</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ;

<span class="co">// 関数の定義</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) <span class="co">// 宣言部分</span>
<span class="co">// 定義部分</span>
<span class="co">// 関数の本体</span>
{
    <span class="kw">return</span> x + <span class="dv">1</span> ;
}</code></pre></div>
<p>関数の定義は宣言を兼ねる。</p>
<p>宣言は何度でも書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// 初出</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// OK</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ; <span class="co">// OK</span></code></pre></div>
<p>定義はプログラム中に一度しか書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 定義</span>
<span class="dt">int</span> odr() { }

<span class="co">// エラー、定義の重複</span>
<span class="dt">int</span> odr() { }</code></pre></div>
<p>名前を使うのに事前に必要なのは宣言だ。定義は名前を使ったあとに書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宣言</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x ) ;

<span class="dt">int</span> main()
{
    plus_one( <span class="dv">1</span> ) ;
}

<span class="co">// 定義</span>
<span class="dt">int</span> plus_one( <span class="dt">int</span> x )
{
    <span class="kw">return</span> x + <span class="dv">1</span> ;
}</code></pre></div>
<p>ほとんどの変数は宣言と定義が同時に行われる。変数でも宣言と定義を分割して行う方法もあるのだが、解説は分割コンパイルの章で行う。</p>
<h2 id="名前空間">名前空間</h2>
<p>本書をここまで読んだ読者は、一部の型名の記述が少し変なことに気が付いているだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::string a ;
std::vector&lt;<span class="dt">int</span>&gt; b ;</code></pre></div>
<p>コロンやアングルブラケットは名前に使える文字ではない。信じられない読者は試してみるとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="dt">int</span> :: = <span class="dv">0</span> ;
<span class="dt">int</span> &lt;<span class="dt">int</span>&gt; = <span class="dv">0</span> ;</code></pre></div>
<p>莫大なエラーが表示されるだろうが、すでに学んだようにとてもいいことだ。コンパイラーが間違いを見つけてくれたのだから。わからないことがあったらどんどんコンパイルエラーを出すとよい。</p>
<p>実は<code>std</code>というのは名前空間(namespace)の名前だ。ダブルコロン(<code>::</code>)は名前空間を指定する文法だ。</p>
<p>名前空間の文法は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
<span class="co">// コード</span>
}</code></pre></div>
<p>名前空間の中の名前を参照するには<code>::</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ns::name ;</code></pre></div>
<p>名前空間の中には変数も書ける。この変数は関数の内部に限定されたローカル変数とは違い、どの関数からでも参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
    <span class="dt">int</span> name{} ;
}

<span class="dt">int</span> f()
{
    <span class="kw">return</span> ns::name ;
}

<span class="dt">int</span> main()
{
    ns::name = <span class="dv">1</span> ;
}</code></pre></div>
<p>名前空間の中で宣言された名前は、名前空間を指定しなければ使えなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    ns::f() ;

    f() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>異なる名前空間名の下の名前は別の名前になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> a {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}


<span class="kw">namespace</span> b {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">1</span> ; }
}

<span class="dt">int</span> main()
{
    a::f() ; <span class="co">// 0</span>
    b::f() ; <span class="co">// 1</span>
}</code></pre></div>
<p>これだけを見ると、名前空間というのはわざわざ名前空間名を指定しなければ使えない面倒な機能に見えるだろう。名前空間の価値は複数人で同じプログラムのソースファイルを編集するときに出てくる。</p>
<p>例えば、アリスとボブがプログラムを共同で開発しているとする。あるプログラムのソースファイル<code>f</code>という名前の関数を書いたとする。ここで、同じプログラムを共同開発している他人も<code>f</code>という名前の関数を書いたらどうなるか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// アリスの書いた関数f</span>
<span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="co">// ボブの書いた関数f</span>
<span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">1</span> ; }</code></pre></div>
<p>すでに宣言と定義で学んだように、このコードはエラーになる。なぜならば、同じ名前に対して定義が2つあるからだ。</p>
<p>名前空間なしでこの問題を解決するためはに、アリスとボブが事前に申し合わせて、名前が衝突しないように調整する必要がある。</p>
<p>しかし名前空間があるC++では、そのような面倒な調整は必要がない。アリスとボブが別の名前空間を使えばいいのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// アリスの名前空間</span>
<span class="kw">namespace</span> alice {
    <span class="co">// アリスの書いた関数f</span>
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="co">// ボブの名前空間</span>
<span class="kw">namespace</span> bob {
    <span class="co">// ボブの書いた関数f</span>
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">1</span> ; }
}</code></pre></div>
<p><code>alice::f</code>と<code>bob::f</code>は別の名前なので定義の衝突は起こらない。</p>
<h3 id="グローバル名前空間">グローバル名前空間</h3>
<p>名前空間に包まれていないソースファイルのトップレベルの場所は、実はグローバル名前空間(global name space)という名前のない名前空間で包まれているという扱いになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間</span>
<span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="kw">namespace</span> ns {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">1</span> ; }
}

<span class="dt">int</span> main()
{
    f() ; <span class="co">// 0</span>
    ns::f() ; <span class="co">// 1</span>
}</code></pre></div>
<p>グローバル名前空間は名前の指定のない単なる<code>::</code>で指定することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x { } ;

<span class="dt">int</span> main()
{
    x ; <span class="co">// ::xと同じ</span>
    ::x ;
}</code></pre></div>
<p>すでに名前空間の中では変数を宣言できることは学んだ。グローバル名前空間は名前空間なので同じように変数を宣言できる。</p>
<p><code>main</code>関数はグローバル名前空間に存在しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間</span>
<span class="dt">int</span> main() { }</code></pre></div>
<h3 id="名前空間のネスト">名前空間のネスト</h3>
<p>名前空間の中に名前空間を書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A { <span class="kw">namespace</span> B { <span class="kw">namespace</span> C {
    <span class="dt">int</span> name {} ;
} } }

<span class="dt">int</span> main()
{
    A::B::C::name = <span class="dv">0</span> ;
}</code></pre></div>
<p>名前空間のネストは省略して書くこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A::B::C {
    <span class="dt">int</span> name { } ;
}

<span class="dt">int</span> main()
{
    A::B::C::name = <span class="dv">0</span> ;
}</code></pre></div>
<h3 id="名前空間名の別名を宣言する名前空間エイリアス">名前空間名の別名を宣言する名前空間エイリアス</h3>
<p>名前空間名には別名を付けることができる。これを名前空間エイリアスと呼ぶ。</p>
<p>たとえば名前空間名が重複することを恐れるあまり、とても長い名前空間名を付けたライブラリがあるとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> very_long_name {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    very_long_name::f() ;
}</code></pre></div>
<p>この関数<code>f</code>を使うために毎回<code>very_long_name::f</code>と書くのは面倒だ。こういうときには名前空間エイリアスを使うとよい。名前空間エイリアスは名前空間名の別名を宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> 別名 = 名前空間名 ;</code></pre></div>
<p>使い方。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> very_long_name {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    <span class="co">// 名前空間エイリアス</span>
    <span class="kw">namespace</span> vln = very_long_name ;
    <span class="co">// vlnはvery_long_nameのエイリアス</span>
    vln::f() ;
}</code></pre></div>
<p>名前空間エイリアスは元の名前空間名と同じように使える。意味も同じだ。</p>
<p>名前空間エイリアスはネストされた名前空間にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A::B::C {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> main()
{
    <span class="kw">namespace</span> D = A::B::C ;
    <span class="co">// DはA::B::Cのエイリアス</span>
    D::f() ;
}</code></pre></div>
<p>名前空間エイリアスを関数の中で宣言すると、その関数の中でだけ有効になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A { <span class="dt">int</span> x { } ; }

<span class="dt">int</span> f()
{
    <span class="co">// Bの宣言</span>
    <span class="kw">namespace</span> B = A ;
    <span class="co">// OK、Bは宣言されている</span>
    <span class="kw">return</span> B::x ;
}

<span class="dt">int</span> g()
{
    <span class="co">// エラー、Bは宣言されていない</span>
    <span class="kw">return</span> B::x ;
}</code></pre></div>
<p>名前空間エイリアスを名前空間の中で宣言すると、宣言以降の名前空間内で有効になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns {
    <span class="kw">namespace</span> A { <span class="dt">int</span> x { } ; }
    <span class="kw">namespace</span> B = A ;

    <span class="co">// OK</span>
    <span class="dt">int</span> f(){ <span class="kw">return</span> B::x ; }
    <span class="co">// OK</span>
    <span class="dt">int</span> g(){ <span class="kw">return</span> B::x ; }

} <span class="co">// end namespace ns</span>

<span class="co">// エラー、Bは宣言されていない</span>
<span class="dt">int</span> h(){ <span class="kw">return</span> B::x ; }</code></pre></div>
<p>グローバル名前空間は名前空間なので、名前空間エイリアスを宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> long_name_is_loooong { }
<span class="kw">namespace</span> cat = long_name_is_loooong ;</code></pre></div>
<h3 id="名前空間名の指定を省略するusingディレクティブ">名前空間名の指定を省略するusingディレクティブ</h3>
<p>名前空間は名前の衝突を防ぐ機能だが、名前空間名をわざわざ指定するのは面倒だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std名前空間のstring</span>
    std::string s ;
    <span class="co">// std名前空間のvector&lt;int&gt;</span>
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// std名前空間のcout</span>
    std::cout &lt;&lt; <span class="dv">123</span> ;
}</code></pre></div>
<p>もし自分のソースファイルが<code>string</code>, <code>vector&lt;int&gt;</code>, <code>cout</code>、その他<code>std</code>名前空間で使われる名前をいっさい使っていない場合、名前の衝突は発生しないことになる。その場合でも名前空間名を指定しなければならないのは面倒だ。</p>
<p>C++では指定した名前空間を省略できる機能が存在する。<code>using</code>ディレクティブだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> 名前空間名 ;</code></pre></div>
<p>これを使えば、先ほどのコードは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> std ;
    <span class="co">// std名前空間のstring</span>
    string s ;
    <span class="co">// std名前空間のvector&lt;int&gt;</span>
    vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// std名前空間のcout</span>
    cout &lt;&lt; <span class="dv">123</span> ;
}</code></pre></div>
<p>では名前が衝突した場合はどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> abc {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">1</span> ; }

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> abc ;

    <span class="co">// エラー、名前が曖昧</span>
    f() ;
}</code></pre></div>
<p>名前<code>f</code>に対してどの名前を使用するのか曖昧になってエラーになる。このエラーを回避するためには、名前空間を直接指定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> abc {
    <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">1</span> ; }

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> abc ;

    <span class="co">// OK、名前空間abcのf</span>
    abc::f() ;

    <span class="co">// OK、グローバル名前空間のf</span>
    ::f() ;
}</code></pre></div>
<p><code>using</code>ディレクティブは関数の中だけではなく、名前空間の中にも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A {
    <span class="dt">int</span> f(){ <span class="kw">return</span> <span class="dv">0</span> ; }
}

<span class="kw">namespace</span> B {
    <span class="kw">using</span> <span class="kw">namespace</span> A ;
    <span class="dt">int</span> g()
    {
        <span class="co">// OK、A::f</span>
        f() ;
    }
}</code></pre></div>
<p>名前空間の中に<code>using</code>ディレクティブを書くと、その名前空間の中では指定した名前空間を省略できる。</p>
<p>グローバル名前空間は名前空間なので<code>using</code>ディレクティブが書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> <span class="kw">namespace</span> std ;</code></pre></div>
<p>ただし、グローバル名前空間の中に<code>using</code>ディレクティブを書くと、それ以降すべての箇所で指定した名前空間の省略ができてしまうので注意が必要だ。</p>
<h3 id="名前空間を指定しなくてもよいinline名前空間">名前空間を指定しなくてもよいinline名前空間</h3>
<p><code>inline名前空間</code>は<code>inline namespace</code>で定義する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="kw">namespace</span> name { }</code></pre></div>
<p><code>inline</code>名前空間内の名前は名前空間名を指定して使うこともできるし、名前空間を指定せずとも使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="kw">namespace</span> A {
    <span class="dt">int</span> a { } ;
}

<span class="kw">namespace</span> B {
    <span class="dt">int</span> b { } ;
}

<span class="dt">int</span> main()
{
    a = <span class="dv">0</span> ;     <span class="co">// A::a</span>
    A::a = <span class="dv">0</span> ;  <span class="co">// A::a</span>

    b = <span class="dv">0</span> ;     <span class="co">// エラー、名前bは宣言されていない</span>
    B::b = <span class="dv">0</span> ;  <span class="co">// B::b</span>
}</code></pre></div>
<p>読者が<code>inline</code>名前空間を使うことはほとんどないだろうが、ライブラリのソースファイルを読むときには出てくるだろう。</p>
<h2 id="型名">型名</h2>
<p>型名とは型を表す名前だ。</p>
<p>型名は<code>int</code>や<code>double</code>のように言語組み込みのキーワードを使うこともあれば、独自に作った型名を使うこともある。この独自に作った型名を専門用語ではユーザー定義された型(user-defined type)という。ユーザー定義された型を作る方法はさまざまだ。具体的に説明するのは本書のだいぶあとの方になるだろう。例としては、<code>std::string</code>や<code>std::vector&lt;T&gt;</code>がある。標準ライブラリによってユーザー定義された型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 組み込みの型名</span>
<span class="dt">int</span> i = <span class="dv">0</span> ;
<span class="dt">double</span> d = <span class="fl">0.0</span> ;

<span class="co">// ユーザー定義された型名</span>
std::string s ;
std::vector&lt;<span class="dt">int</span>&gt; v ;</code></pre></div>
<h3 id="型名の別名を宣言するエイリアス宣言">型名の別名を宣言するエイリアス宣言</h3>
<p>長い名前空間名を書くのが煩わしいように、長い型名を書くのも煩わしい。名前空間名の別名を宣言できるように、型名も別名を宣言できる。</p>
<p>型名の別名を宣言するにはエイリアス宣言を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> 別名 = 型名 ;</code></pre></div>
<p>使い方。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エイリアス宣言</span>
    <span class="kw">using</span> Number = <span class="dt">int</span> ;

    <span class="co">// Numberはintの別名</span>
    Number x = <span class="dv">0</span> ;
}</code></pre></div>
<p>型名の別名は型名と同じように使える。意味も同じだ。</p>
<p>歴史的な経緯により、エイリアス宣言による型名の別名のことを、<code>typedef名</code>(typedef name)という。これは<code>typedef</code>名を宣言する文法が、かつては<code>typedef</code>キーワードを使ったものだったからだ。<code>typedef</code>キーワードを使った<code>typedef</code>名の宣言方法は、昔のコードによく出てくるので現代でも覚えておく必要はある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span> 型名 typedef名 ;</code></pre></div>
<p>使い方。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// typedef名による型名の宣言</span>
    <span class="kw">typedef</span> <span class="dt">int</span> Number ;

    Number x = <span class="dv">0</span> ;
}</code></pre></div>
<p>これは変数の宣言と同じ文法だ。変数の宣言が以下のような文法で、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">型名 変数名 ;</code></pre></div>
<p>これに<code>typedef</code>キーワードを使えば<code>typedef</code>名の宣言になる。</p>
<p>しかし<code>typedef</code>キーワードによる<code>typedef</code>名の宣言はわなが多い。例えば熟練のC++プログラマーでも、以下のコードが合法だということに驚くだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> <span class="kw">typedef</span> Number ;
    Number x = <span class="dv">0</span> ;
}</code></pre></div>
<p>しかし本書ではまだ教えていない複雑な型名について、このようなコードを書こうとするとコンパイルエラーになることに熟練のC++プログラマーは気が付くはずだ。その理由はとても難しい。</p>
<p>エイリアス宣言にはこのようなわなはない。</p>
<h2 id="スコープ">スコープ</h2>
<p>スコープ(scope)というのはやや説明が難しい概念だ。名前空間や関数はスコープを持っている。とてもおおざっぱに説明するとカーリブラケット<code>{}</code>で囲まれた範囲がスコープだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns
{ <span class="co">// 名前空間スコープの始まり</span>
} <span class="co">// 名前空間スコープの終わり</span>

<span class="dt">void</span> f()
{ <span class="co">// 関数スコープの始まり</span>

} <span class="co">// 関数スコープの終わり</span></code></pre></div>
<p>これとは別にブロック文のスコープもある。ブロックとは関数の中で複数の文を束ねて1つの文として扱う機能だ。覚えているだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{ <span class="co">// 関数スコープ</span>

    { <span class="co">// 外側のブロックスコープ</span>
        { <span class="co">// 内側のブロックスコープ</span>
        }
    }
}</code></pre></div>
<p>スコープは<code>{</code>に始まり<code>}</code>に終わる。</p>
<p>なぜスコープという概念について説明したかというと、宣言された名前が有効な範囲は、宣言された最も内側のスコープの範囲だからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> ns
{<span class="co">// aの所属するスコープ</span>
    <span class="dt">int</span> a {} ;

    <span class="dt">void</span> f()
    { <span class="co">// bの所属するスコープ</span>
        <span class="dt">int</span> b {} ;

        { <span class="co">// cの所属するスコープ</span>
            <span class="dt">int</span> c {} ;
        }<span class="co">// cの範囲終わり</span>

        
    }<span class="co">// bの範囲終わり</span>

} <span class="co">// aの範囲終わり</span></code></pre></div>
<p>名前が有効な範囲は、宣言された最も内側のスコープだ。</p>
<p>外側のスコープで宣言された名前は内側のスコープで使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="dt">int</span> a {} ;
    {<span class="co">// 新たなスコープ</span>
        a = <span class="dv">0</span> ;
    }
}</code></pre></div>
<p>その逆はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    { <span class="dt">int</span> a {} ; }
    <span class="co">// エラー</span>
    a = <span class="dv">0</span> ;
}</code></pre></div>
<p>名前空間も同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間スコープ</span>

<span class="kw">namespace</span> ns {
    <span class="dt">int</span> a {} ;
    <span class="dt">void</span> f()
    {
        a = <span class="dv">0</span> ; <span class="co">// OK</span>
    }
} <span class="co">// 名前空間nsのスコープの終了</span>

<span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    a = <span class="dv">0</span> ;
    <span class="co">// OK </span>
    ns::a ;
}</code></pre></div>
<p>名前空間スコープと関数スコープには違う点もあるが、名前の有効な範囲としては同じスコープだ。</p>
<p>外側のスコープで宣言された名前と同じ名前を内側で宣言すると、内側の名前が外側の名前を隠す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間のf</span>
<span class="kw">auto</span> f =  []()
{ std::cout &lt;&lt; <span class="dv">1</span> ; } ;

<span class="dt">int</span> main()
{
    f() ; <span class="co">// 1</span>

    <span class="co">// 関数mainのf</span>
    <span class="kw">auto</span> f = []()
    { std::cout &lt;&lt; <span class="dv">2</span> ; } ;

    f() ; <span class="co">// 2</span>

    {
        f() ; <span class="co">// 2</span>

        <span class="co">// ブロックのf</span>
        <span class="kw">auto</span> f = []()
        { std::cout &lt;&lt; <span class="dv">3</span> ; } ;
        f() ; <span class="co">// 3</span>
    }

    f() ; <span class="co">// 2</span>
}</code></pre></div>
<p>宣言されている場所に注意が必要だ。名前<code>f</code>は3つある。最初の関数呼び出しの時点ではグローバル名前空間の<code>f</code>が呼ばれる。まだ名前<code>f</code>は関数<code>main</code>の中で宣言されていないからだ。そして関数<code>main</code>のスコープの中で名前<code>f</code>が宣言される。このときグローバル名前空間の<code>f</code>は隠される。そのため、次の関数<code>f</code>の呼び出しでは関数<code>main</code>の<code>f</code>が呼ばれる。次にブロックの中に入る。ここで関数<code>f</code>が呼ばれるが、まだこの<code>f</code>は関数<code>main</code>の<code>f</code>だ。そのあとにブロックの中で名前<code>f</code>が宣言される。すると次の関数<code>f</code>の呼び出しはブロックの<code>f</code>だ。ブロックから抜けたあとの関数<code>f</code>の呼び出しは関数<code>main</code>の<code>f</code>だ。</p>
<p>この章では名前について解説した。名前は難しい。難しいが、プログラミングにおいては名前と向き合わなければならない。</p>
<h1 id="イテレーターの基礎">イテレーターの基礎</h1>
<p><code>vector</code>の章では<code>vector</code>の要素にアクセスする方法としてメンバー関数<code>at(i)</code>を学んだ。<code>at(i)</code>は<code>i</code>番目の要素にアクセスできる。ただし最初の要素は0番目だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="dt">int</span> x = v.at(<span class="dv">2</span>) ; <span class="co">// 3</span>
    v.at(<span class="dv">2</span>) = <span class="dv">0</span> ;
    <span class="co">// vは{1,2,0,4,5}</span>
}</code></pre></div>
<p>この章では<code>vector</code>の要素にアクセスする方法としてイテレーター(iterator)を学ぶ。</p>
<h2 id="イテレーターの取得方法">イテレーターの取得方法</h2>
<p>イテレーターは<code>std::begin(v)</code>で取得する。<code>v</code>は<code>vector</code>の変数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> i = std::begin(v) ;
}</code></pre></div>
<h2 id="イテレーターの参照する要素に対する読み書き">イテレーターの参照する要素に対する読み書き</h2>
<p>イテレーターは<code>vector</code>の先頭の要素を指し示している。イテレーターの指し示す要素を参照するには<code>*</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = std::begin(v) ;

    <span class="dt">int</span> x = *i ; <span class="co">// 1</span>

    *i = <span class="dv">0</span> ;
    <span class="co">// vは{0,2,3,4,5} </span>
}</code></pre></div>
<p><code>*i</code>を読み込むと指し示す要素の値を読むことができ、<code>*i</code>に代入をすると指し示す要素の値を変えることができる。</p>
<h2 id="イテレーターの参照する要素を変更">イテレーターの参照する要素を変更</h2>
<p>現在指している要素の次の要素を指すように変更するには<code>++</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = std::begin(v) ;

    *i ; <span class="co">// 1</span>
    ++i ;
    *i ; <span class="co">// 2</span>
    ++i ;
    *i ; <span class="co">// 3</span>
}</code></pre></div>
<p>現在指している要素の前の要素を指すように変更するには<code>--</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = std::begin(v) ;

    *i ; <span class="co">// 1</span>
    ++i ;
    *i ; <span class="co">// 2</span>
    --i ;
    *i ; <span class="co">// 1</span>
}</code></pre></div>
<p><code>vector</code>の全要素を先頭からイテレーターでアクセスするには、要素数だけ<code>++i</code>すればよいことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> iter = std::begin(v) ;

    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != std::size(v) ; ++i, ++iter )
    {
        std::cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>これは動く。ただしもっとマシな方法がある。イテレーターの比較だ。</p>
<h2 id="イテレーターの比較">イテレーターの比較</h2>
<p>イテレーターは比較できる。同じ順番の要素を指すイテレーターは等しく、そうではないイテレーターは等しくない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> x = std::begin(v) ;
    <span class="kw">auto</span> y = x ;

    <span class="co">// x, yは0番目の要素を指す</span>

    <span class="dt">bool</span> b1 = (x == y) ; <span class="co">// true</span>
    <span class="dt">bool</span> b2 = (x != y) ; <span class="co">// false</span>

    ++x ; <span class="co">// xは1番目の要素を指す。</span>

    <span class="dt">bool</span> b3 = (x == y) ; <span class="co">// false</span>
    <span class="dt">bool</span> b4 = (x != y) ; <span class="co">// true</span>
}</code></pre></div>
<h2 id="最後の次の要素へのイテレーター">最後の次の要素へのイテレーター</h2>
<p><code>std::begin(v)</code>は<code>vector</code>の変数<code>v</code>の最初の要素を指し示すイテレーターを取得する。</p>
<p><code>std::end(v)</code>は<code>vector</code>の変数<code>v</code>の最後の次の要素を指し示すイテレーターを取得する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> };

    <span class="co">// 最後の次の要素を指し示すイテレーター</span>
    <span class="kw">auto</span> i = std::end(v) ;
}</code></pre></div>
<p>最後の次の要素とは何か。ある<code>vector&lt;int&gt;</code>の変数の中身が<code>{1,2,3,4,5}</code>のとき、最初の0番目の要素の値は<code>1</code>だ。最後の4番目の要素の値は<code>5</code>だ。最後の次の要素とは、値が<code>5</code>の最後の要素の次の要素だ。そのような要素は実際には存在しないが、<code>std::end</code>は概念として最後の次の要素を返す。</p>
<p>最後の次の要素を指し示すイテレーターに対して、<code>*</code>で要素にアクセスを試みるとエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = std::end(v) ;

    *i ; <span class="co">// エラー</span>
}</code></pre></div>
<p>最後の次の要素を<code>++</code>しようとするとエラーになる。<code>--</code>することはできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> i = std::end(v) ;

    --i ;   <span class="co">// 最後の要素を指す</span>
    *i ;    <span class="co">// 5</span>
    ++i ;   <span class="co">// 最後の次の要素を指す</span>
    *i ;    <span class="co">// エラー</span>
}</code></pre></div>
<p>実際には存在しない最後の次の要素を指し示すイテレーターは何の役に立つのか。答えはイテレーターの比較だ。</p>
<p>実際には存在しない最後の次の要素を指すイテレーターに<code>'*'</code>を使って要素にアクセスするのはエラーだが、イテレーター同士の比較はできる。すでに説明したように、イテレーターの比較は同じ要素を指す場合は<code>true</code>、違う要素を指す場合は<code>false</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="co">// xは最初の要素を指す</span>
    <span class="kw">auto</span> x = std::begin(v) ;
    <span class="co">// yは最後の次の要素を指す</span>
    <span class="kw">auto</span> y = std::end(v) ;


    x == y ; <span class="co">// false</span>
    ++x ; <span class="co">// xは最初の次の要素を指す</span>
    x == y ; <span class="co">// false</span>
    ++x ; <span class="co">// xは最後の要素を指す</span>
    x == y ; <span class="co">// false</span>
    ++x ; <span class="co">// xは最後の次の要素を指す</span>
    x == y ; <span class="co">// true</span>
}</code></pre></div>
<p><code>std::end</code>で取得する最後の次の要素を指すイテレーターと比較することで、イテレーターが最後の次の要素を指し示す状態に到達したことを判定できる。</p>
<p>ということは、<code>vector</code>の要素を先頭から最後まで順番に出力するプログラムは、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">for</span> ( <span class="kw">auto</span> iter = std::begin(v), last = std::end(v) ;
          iter != last ; ++iter )
    {
        std::cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<h2 id="なんでもイテレーター">なんでもイテレーター</h2>
<p>イテレーターというのは要素にアクセスする回りくどくて面倒な方法に見える。イテレーターという面倒なものを使わずに、<code>vector::at(i)</code>で<code>i</code>番目の要素にアクセスする方が楽ではないか。そう考える読者もいるだろう。イテレーターの利点はその汎用性にある。イテレーターの作法に従うことで、さまざまな処理が同じコードで書けるようになるのだ。</p>
<p>たとえば、<code>vector</code>の要素を先頭から順番に出力する処理を振り返ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != std::size(v) ; ++i )
    {
        std::cout &lt;&lt; v.at(i) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>このコードは<code>vector</code>にしか使えないコードだ。イテレーターで書き直してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">for</span> ( <span class="kw">auto</span> iter = std::begin(v), last = std::end(v) ;
          iter != last ; ++iter )
    {
        std::cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
}</code></pre></div>
<p>そして、この要素を先頭から出力する処理を関数にしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> output_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        std::cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
} ;

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    output_all( std::begin(v), std::end(v) ) ;
}</code></pre></div>
<p>この<code>関数output_all</code>は<code>vector</code>以外のイテレーターにも対応している。C++にはさまざまなイテレーターがある。例えば標準入力から値を受け取るイテレーターがある。さっそく使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::istream_iterator&lt;<span class="dt">int</span>&gt; first( std::cin ), last ;

    output_all( first, last ) ;
}</code></pre></div>
<p>このプログラムは標準入力から<code>int</code>型の値を受け取り、それをそのまま標準出力する。</p>
<p>C++にはほかにも、カレントディレクトリーにあるファイルの一覧を取得するイテレーターがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::filesystem::directory_iterator first(<span class="st">&quot;./&quot;</span>), last ;

    output_all( first, last ) ;
}</code></pre></div>
<p><code>関数output_all</code>のコードは何も変えていないのに、さまざまなイテレーターに対応できる。イテレーターというお作法にのっとることで、さまざまな処理が可能になるのだ。</p>
<p>これは出力にも言えることだ。<code>関数output_all</code>は<code>std::cout</code>に出力していた。これをイテレーターに対する書き込みに変えてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> output_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> output_iter )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter, ++output_iter )
    {
        *output_iter = *iter ;
    }
} ;</code></pre></div>
<p>書き換えた<code>関数output_all</code>は新しく<code>output_iter</code>という引数を取る。これはイテレーターだ。<code>std::cout</code>に出力する代わりに、このイテレーターに書き込むように変更している。</p>
<p>こうすることによって、出力にもさまざまなイテレーターが使える。</p>
<p>標準出力に出力するイテレーターがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    
    output_all( std::begin(v), std::end(v),
                std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cout) ) ;
}</code></pre></div>
<p><code>vector</code>も出力先にできる。つまり<code>vector</code>のコピーだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;

    output_all( std::begin(source), std::end(source), std::begin( destination ) ) ;
}</code></pre></div>
<p><code>destination(5)</code>というのは、<code>vector</code>にあらかじめ5個の要素を入れておくという意味だ。あらかじめ入っている要素の値は<code>int</code>の場合ゼロになる。</p>
<p>このほかにもイテレーターはさまざまある。自分でイテレーターを作ることもできる。そして、<code>関数output_all</code>はイテレーターにさえ対応していればさまざまな処理にコードを1行たりとも変えずに使えるのだ。</p>
<h2 id="イテレーターと添字の範囲">イテレーターと添字の範囲</h2>
<p>イテレーターは順序のある値の集合を表現するために、最初の要素への参照と、最後の次の要素への参照のペアを用いる。</p>
<p>たとえば、<code>{1,2,3,4,5}</code>という順序の値の集合があった場合、イテレーターは最初の要素である<code>1</code>と最後の1つ次の要素である5の次の架空の要素を指し示す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> i = std::begin(v) ;
    <span class="kw">auto</span> j = std::end(v) ;
}</code></pre></div>
<p>このようにして範囲を表現することを、<code>半閉鎖(half-closed)</code>とか、<code>[i,j)</code>などと表現する。</p>
<p>この状態から<code>{2,3,4,5}</code>のような値の集合を表現したい場合、イテレーター<code>i</code>をインクリメントすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">++i ;</code></pre></div>
<p>これで<code>[i,j)</code>は<code>{2,3,4,5}</code>になった。</p>
<p>このような範囲の表現方法に疑問を感じる読者もいるだろう。なぜ最後の次の要素という本来存在しない架空の要素をあたかも参照しているかのようなイテレーターが必要なのか。最後の要素を参照するのではだめなのか。</p>
<p>そのような範囲の表現方法は、<code>閉鎖(closed)</code>とか<code>[i,j]</code>などと表現する。</p>
<p>実はこの方法は<code>vector</code>の要素の順番を指定する方法と同じなのだ。</p>
<p><code>{1,2,3,4,5}</code>と5個の順序ある要素からなる<code>vector</code>では、最初の要素は0番目で、最後の要素は4番目だ。1番目から5番目ではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    v.at(<span class="dv">0</span>) ; <span class="co">// 最初の要素: 1</span>
    v.at(<span class="dv">4</span>) ; <span class="co">// 最後の要素: 5</span>
}</code></pre></div>
<p>ではなぜなのか。なぜ<code>vector</code>では<span class="math inline">\(n\)</span>個の要素の順番を0番目から<span class="math inline">\(n-1\)</span>番目として表現するのか。</p>
<p>実はC++に限らず、現在使われているすべてのプログラミングはインデックスを<code>0</code>から始めている。かつてはインデックスを<code>1</code>から始める言語も存在したが、そのような言語はいまは使われていない。</p>
<p>この疑問はエドガー・ダイクストラ(Edsger Wybe Dijkstra)が&quot;Why numbering should start at zero&quot;(EWD831)で解説している。</p>
<p>2, 3, ..., 12の範囲の自然数を表現するのに、慣習的に以下の4つの表記がある。</p>
<p><span class="math display">\[
a) 2 \le i \lt 13
\]</span></p>
<p><span class="math display">\[
b) 1 \lt i \le 12
\]</span></p>
<p><span class="math display">\[
c) 2 \le i \le 12
\]</span></p>
<p><span class="math display">\[
d) 1 \lt i \lt 13
\]</span></p>
<p>C++のイテレーターはa)を元にしている。</p>
<p>この4つのうち、a)とb)は上限から下限を引くと、範囲にある自然数の個数である11になる。</p>
<p>この性質はとても便利なのでC++でも、イテレーター同士の引き算ができるようになっている。イテレーター<code>i</code>, <code>j</code>(<span class="math inline">\(i \le j\)</span>)で<code>j - i</code>をした結果はイテレーターの範囲の要素の個数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>} ;

    <span class="kw">auto</span> i = std::begin(v) ;
    <span class="kw">auto</span> j = std::end(v) ;

    <span class="co">// 11</span>
    <span class="co">// イテレーターの範囲の要素の個数</span>
    std::cout &lt;&lt; j - i &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    ++i ; <span class="co">// 先頭の次の要素を指す</span>
    <span class="co">// 10</span>
    std::cout &lt;&lt; j - i ; 
}</code></pre></div>
<p>a)とb)はどちらがいいのだろうか。b)を元にイテレーターを設計すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// b)案を採用する場合</span>
<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 最初の1つ前の架空の要素を指す</span>
    <span class="kw">auto</span> i = std::begin(v) ;
    <span class="co">// 最後の要素を指す</span>
    <span class="kw">auto</span> j = std::end(v) ;

    <span class="co">// 最初の要素を指すようにする。</span>
    ++i ;

    <span class="co">// iが最後の要素を指すとループを抜ける</span>
    <span class="kw">for</span> ( ; i != j ; ++i )
    {
        std::cout &lt;&lt; *i ;
    }
    <span class="co">// 最後の要素を処理する</span>
    std::cout &lt;&lt; *i ;
    

}</code></pre></div>
<p>a)の方がよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a)案を採用する場合</span>
<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 最初の要素を指す</span>
    <span class="kw">auto</span> i = std::begin(v) ;
    <span class="co">// 最後の次の要素を指す</span>
    <span class="kw">auto</span> j = std::end(v) ;

    <span class="co">// iが最後の次の要素を指すとループを抜ける</span>
    <span class="kw">for</span> ( ; i != j ; ++i )
    {
        std::cout &lt;&lt; *i ;
    }

    <span class="co">// すべての要素について処理を終えている</span>
}</code></pre></div>
<p>b)案では末尾から先頭まで後ろ向きに要素を一巡する操作はやりやすいが、実際には先頭から末尾まで一巡する操作の方が多い。</p>
<p>C++では要素の順番を数値で指し示すとき、最初の要素は0番目であり、次の要素は1番目であり、<span class="math inline">\(N\)</span>個目の要素は<span class="math inline">\(N-1\)</span>番目になっている。この数値で指し示すことを<code>添字</code>とか<code>インデックス</code>というがなぜ最初の要素を1番目にしないのか。</p>
<p>C++ではさまざまなところでa)を採用している。これを添字に適用すると、最初の要素が1番目から始まる場合、<span class="math inline">\(N\)</span>個の要素を参照する添字の範囲は<span class="math inline">\(1 \le i \lt N+1\)</span>になる。そのような場合、以下のようなコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 最初の要素が1番目の場合</span>
<span class="dt">int</span> main()
{
    <span class="co">// 5個の要素を持つvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// iの値の範囲は1から5まで</span>
    <span class="kw">for</span> ( std::size_t i = <span class="dv">1</span> ; i &lt; <span class="dv">6</span> ; ++i )
    {
        std::cout &lt;&lt; v.at(i) ;
    }    
}</code></pre></div>
<p>要素数は5個なのに<code>6</code>が出てくる。最初の要素が0番目の場合、<span class="math inline">\(N\)</span>個の要素を参照する添字の範囲は<span class="math inline">\(0 \le i \lt N\)</span>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 最初の要素が0番目の場合</span>
<span class="dt">int</span> main()
{
    <span class="co">// 5個の要素を持つvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// iの値の範囲は0から5まで</span>
    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i &lt; <span class="dv">5</span> ; ++i )
    {
        std::cout &lt;&lt; v.at(i) ;
    }    
}</code></pre></div>
<p>一貫性のために最初の要素は0番目となっている。</p>
<p>また、空の集合にも対応できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 空</span>
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="co">// 空なので何も出力されない</span>
    <span class="kw">for</span> (   <span class="kw">auto</span> i = std::begin(v), j = std::end(v) ;
            i != j ; ++i )
    {
        std::cout &lt;&lt; *i ;
    }
}</code></pre></div>
<p>変数<code>v</code>は空なので<code>i != j</code>は<code>false</code>となり、<code>for</code>文の中の文は一度も実行されない。</p>
<h1 id="lvalueリファレンスとconst">lvalueリファレンスとconst</h1>
<pre><code>ポップカルチャーリファレンスというのは流行の要素をさり気なく作品中に取り入れることで、流行作品を知っている読者の笑いを誘う手法である
-- キャプテン・オブビウス、ポップカルチャーリファレンスについて</code></pre>
<h2 id="lvalueリファレンス">lvalueリファレンス</h2>
<p>変数に変数を代入すると、代入元の値が代入先にコピーされる。代入先の値を変更しても、コピーされた値が変わるだけで、代入元にはいっさい影響がない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">2</span> ;

    b = a ;
    <span class="co">// b == 1</span>

    b = <span class="dv">3</span> ;
    <span class="co">// a == 1</span>
    <span class="co">// b == 3</span>
}</code></pre></div>
<p>これは関数も同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> assign_3( <span class="dt">int</span> x )
{
    x = <span class="dv">3</span> ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    assign_3( a ) ;

    <span class="co">// a == 1</span>
}</code></pre></div>
<p>しかし、ときには変数の値を直接書き換えたい場合がある。このとき<code>lvalue</code>リファレンス(reference)が使える。<code>lvalue</code>リファレンスは変数に<code>&amp;</code>を付けて宣言する</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> &amp; ref = a ;

    ref = <span class="dv">3</span> ;

    <span class="co">// a == 3</span>
    <span class="co">// refはaなので同じく3</span>
}</code></pre></div>
<p>この例で、変数<code>ref</code>は変数<code>a</code>への参照(リファレンス)なので、変数<code>a</code>と同じように使える。</p>
<p><code>lvalue</code>リファレンスは必ず初期化しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    <span class="dt">int</span> &amp; ref ;
}</code></pre></div>
<p><code>lvalue</code>リファレンスは関数でも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> &amp; x )
{
    x = <span class="dv">3</span> ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    f( a ) ;

    <span class="co">// a == 3</span>
}</code></pre></div>
<p>選択ソートで2つの変数の値を交換する必要があったことを覚えているだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 0番目と2番目の要素を交換したい</span>
    <span class="kw">auto</span> temp = v.at(<span class="dv">0</span>) ;
    v.at(<span class="dv">0</span>) = v.at(<span class="dv">2</span>) ;
    v.at(<span class="dv">2</span>) = temp ;
}</code></pre></div>
<p>いちいち交換のために別の変数<code>temp</code>を作って3回代入を書くのは面倒だ。これを関数にしてしまいたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 値を交換</span>
swap( v.at(<span class="dv">0</span>), v.at(<span class="dv">2</span>) ) ;</code></pre></div>
<p>このような関数<code>swap</code>は普通に書くことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// この実装は正しくない</span>
<span class="kw">auto</span> swap = []( <span class="kw">auto</span> a, <span class="kw">auto</span> b )
{
    <span class="kw">auto</span> temp = a ;
    a = b ;
    b = temp ;
} ;</code></pre></div>
<p>この実装では、変数は単にコピーされるだけなので、関数の呼び出し元には何の影響もない。</p>
<p>これを<code>lvalue</code>リファレンスに変えると、関数の呼び出し元の変数の値を交換する関数<code>swap</code>が作れる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lvalueリファレンス</span>
<span class="kw">auto</span> swap = []( <span class="kw">auto</span> &amp; a, <span class="kw">auto</span> &amp; b )
{
    <span class="kw">auto</span> temp = a ;
    a = b ;
    b = temp ;
} ;</code></pre></div>
<p>C++の標準ライブラリには<code>std::swap</code>があるので、読者はわざわざこのような関数を自作する必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">2</span> ;

    std::swap( a, b ) ;

    <span class="co">// a == 2</span>
    <span class="co">// b == 1</span>
}</code></pre></div>
<p>ところで、この章では一貫して<code>lvalue</code>リファレンスと書いているのに気が付いただろうか。<code>lvalue</code>とは何なのか、<code>lvalue</code>ではないリファレンスはあるのか。その疑問はあとの章で解決する。</p>
<h2 id="const">const</h2>
<p>値を変更したくない変数は、<code>const</code>を付けることで変更を禁止できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    x = <span class="dv">1</span> ; <span class="co">// OK、変更できる</span>

    <span class="dt">const</span> <span class="dt">int</span> y = <span class="dv">0</span> ;
    y = <span class="dv">0</span> ; <span class="co">// エラー、変更できない。</span>
}</code></pre></div>
<p><code>const</code>はちょっと文法が変わっていて混乱する。例えば、<code>const int</code>でも<code>int const</code>でも意味が同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 意味は同じ</span>
    <span class="dt">const</span> <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="dt">int</span> <span class="dt">const</span> y = <span class="dv">0</span> ;
}</code></pre></div>
<p><code>const</code>は<code>lvalue</code>リファレンスと組み合わせることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;

    <span class="dt">int</span> &amp; ref = x ;
    <span class="co">// OK</span>
    ++ref ;

    <span class="dt">const</span> <span class="dt">int</span> &amp; const_ref = x ;

    <span class="co">// エラー</span>
    ++const_ref ;
}</code></pre></div>
<p><code>const</code>は本当に文法が変わっていて混乱する。<code>const int &amp;</code>と<code>int const &amp;</code>は同じ意味だが、<code>int &amp; const</code>はエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">0</span> ;

    <span class="co">// OK、意味は同じ</span>
    <span class="dt">const</span> <span class="dt">int</span> &amp; b = a ;
    <span class="dt">int</span> <span class="dt">const</span> &amp; c = a ;

    <span class="co">// エラー</span>
    <span class="dt">int</span> &amp; <span class="dt">const</span> d = a ;
}</code></pre></div>
<p>これはとても複雑なルールで決まっているので、こういうものだとあきらめて覚えるしかない。</p>
<p><code>const</code>が付いていない型のオブジェクトを<code>const</code>な<code>lvalue</code>リファレンスで参照することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// constの付いていない型のオブジェクト</span>
    <span class="dt">int</span> x = <span class="dv">0</span> ;

    <span class="co">// OK</span>
    <span class="dt">int</span> &amp; ref = x ;
    <span class="co">// OK、constは付けてもよい</span>
    <span class="dt">const</span> <span class="dt">int</span> &amp; cref = x ;
}</code></pre></div>
<p><code>const</code>の付いている型のオブジェクトを<code>const</code>の付いていない<code>lvalue</code>リファレンスで参照することはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// constの付いている型のオブジェクト</span>
    <span class="dt">const</span> <span class="dt">int</span> x = <span class="dv">0</span> ;

    <span class="co">// エラー、constがない</span>
    <span class="dt">int</span> &amp; ref = x ;

    <span class="co">// OK、constが付いている</span>
    <span class="dt">const</span> <span class="dt">int</span> &amp; cref = x ;
}</code></pre></div>
<p><code>const</code>の付いている<code>lvalue</code>リファレンスは何の役に立つのかというと、関数の引数を取るときに役に立つ。</p>
<p>例えば以下のコードは非効率的だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( std::vector&lt;<span class="dt">int</span>&gt; v )
{
    std::cout &lt;&lt; v.at(<span class="dv">1234</span>) ;
}

<span class="dt">int</span> main()
{
    <span class="co">// 10000個の要素を持つvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10000</span>) ;

    f( v ) ;
}</code></pre></div>
<p>なぜかというと、関数の引数に渡すときに、変数<code>v</code>はコピーされるからだ。</p>
<p>リファレンスを使うと不要なコピーをしなくて済む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( std::vector&lt;<span class="dt">int</span>&gt; &amp; v )
{
    std::cout &lt;&lt; v.at(<span class="dv">1234</span>) ;
}</code></pre></div>
<p>しかし、リファレンスで受け取ると、うっかり変数を変更してしまった場合、その変更が関数の呼び出し元に反映されてしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 値を変更するかもしれない</span>
<span class="dt">void</span> f( std::vector&lt;<span class="dt">int</span>&gt; &amp; v ) ;

<span class="dt">int</span> main()
{
    <span class="co">// 要素数10000のvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10000</span>) ;

    f(v) ;

    <span class="co">// 値は変更されているかもしれない</span>
}</code></pre></div>
<p>このとき、<code>const</code>な<code>lvalue</code>リファレンスを使うと、引数に取った値を変更しないことを保証できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( std::vector&lt;<span class="dt">int</span>&gt; <span class="dt">const</span> &amp; v ) ;</code></pre></div>
<h1 id="アルゴリズム">アルゴリズム</h1>
<p>アルゴリズムは難しい。アルゴリズム自体の難しさに加え、アルゴリズムを正しくコードで表記するのも難しい。そこでC++ではアルゴリズム自体をライブラリにしている。ライブラリとしてのアルゴリズムを使うことで、読者はアルゴリズムを自前で実装することなく、すでに正しく実装されたアルゴリズムを使うことができる。</p>
<h2 id="for_each">for_each</h2>
<p>例えば<code>vector</code>の要素を先頭から順番に標準出力するコードを考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">for</span> (
        <span class="kw">auto</span> i = std::begin(v),
             j = std::end(v) ;
        i != j ;
        ++i  )
    {
        std::cout &lt;&lt; *i ;
    }
}</code></pre></div>
<p>このコードを書くのは難しい。このコードを書くには、イテレーターで要素の範囲を取り、ループを実行するごとにイテレーターを適切にインクリメントし、イテレーターが範囲内であるかどうかの判定をしなければならない。</p>
<p>アルゴリズムを理解するだけでも難しいのに、正しくコード書くのはさらに難しい。例えば以下はコンパイルが通る完全に合法なC++だが間違っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">for</span> (
        <span class="kw">auto</span> i = std::begin(v),
             j = std::end(v) ;
        i == j ;
        ++i  )
    {
        std::cout &lt;&lt; i ;
    }
}</code></pre></div>
<p>間違っている箇所がわかるだろうか。</p>
<p>まず比較の条件が間違っている。<code>i != j</code>となるべきところが<code>i == j</code>となっている。出力する部分も間違っている。イテレーター<code>i</code>が指し示す値を得るには<code>*i</code>としなければならないところ、単に<code>i</code>としている。</p>
<p>毎回このようなイテレーターのループをする<code>for</code>文を書くのは間違いの元だ。ここで重要なのは、要素のそれぞれに対して<code>std::cout &lt;&lt; *i ;</code>を実行するということだ。要素を先頭から末尾まで順番に処理するというのはライブラリにやってもらいたい。</p>
<p>そこでこの処理を関数に切り出してみよう。イテレーター<code>[first,last)</code>を渡すと、イテレーターを先頭から末尾まで順番に処理してくれる関数は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> print_all = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="co">// ループ</span>
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        <span class="co">// 重要な処理</span>
        std::cout &lt;&lt; *iter ;
    }
} ; 

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    print_all( std::begin(v), std::end(v) ) ;
}</code></pre></div>
<p>関数<code>print_all</code>は便利だが、重要な処理がハードコードされている。例えば要素の集合のうち100以下の値だけ出力したいとか、値を2倍して出力したいとか、値を出力するたびに改行を出力したいという場合、それぞれに関数を書く必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 値が100以下なら出力</span>
<span class="kw">auto</span> print_if_le_100 = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    { <span class="co">// 特別な処理</span>
        <span class="kw">if</span> ( *iter &lt;= <span class="dv">100</span> )
            std::cout &lt;&lt; *iter ;
    }
} ;


<span class="co">// 値を2倍して出力</span>
<span class="kw">auto</span> print_twice = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    { <span class="co">// 特別な処理</span>
        std::cout &lt;&lt; <span class="dv">2</span> * (*iter) ;
    }
} ;


<span class="co">// 値を出力するたびに改行を出力</span>
<span class="kw">auto</span> print_with_newline = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    { <span class="co">// 特別な処理</span>
        std::cout &lt;&lt; *iter &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
} ;</code></pre></div>
<p>これを見ると、<code>for</code>文によるイテレーターのループはまったく同じコードだとわかる。</p>
<p>まったく同じ<code>for</code>文を手で書くのは間違いの元だ。同じコードはできれば書きたくない。ここで必要なのは、共通な処理は一度書くだけで済ませ、特別な処理だけを記述すれば済むような方法だ。</p>
<p>この問題を解決するには、問題を分割することだ。問題を「<code>for</code>文によるループ」と「特別な処理」に分けることだ。</p>
<p>ところで、関数は変数に代入できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 変数に代入された関数</span>
    <span class="kw">auto</span> print = []( <span class="kw">auto</span> x ) { std::cout &lt;&lt; x ; } ;

    <span class="co">// 変数に代入された関数の呼び出し</span>
    print(<span class="dv">123</span>) ;
}</code></pre></div>
<p>変数に代入できるということは、関数の引数として関数に渡せるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 関数を引数に取り呼び出す関数</span>
    <span class="kw">auto</span> call_func = []( <span class="kw">auto</span> func )
    {
        func(<span class="dv">123</span>) ;
    } ;

    <span class="co">// 引数を出力する関数</span>
    <span class="kw">auto</span> print = []( <span class="kw">auto</span> x ) { std::cout &lt;&lt; x ; } ;

    call_func( print ) ;

    <span class="co">// 引数を2倍して出力する関数</span>
    <span class="kw">auto</span> print_twice = []( <span class="kw">auto</span> x ) { std::cout &lt;&lt; <span class="dv">2</span>*x ; } ;

    call_func( print_twice ) ;
}</code></pre></div>
<p>すると、要素ごとの特別な処理をする関数を引数で受け取り、要素ごとに関数を適用する関数を書くとどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> for_each = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> f )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        f( *iter ) ;
    }
} ;</code></pre></div>
<p>この関数はイテレーターをループで回す部分だけを実装していて、要素ごとの処理は引数に取った関数に任せている。さっそく使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 引数を出力する関数</span>
    <span class="kw">auto</span> print_value = []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; value ; } ;

    for_each( std::begin(v), std::end(v), print_value ) ;

    <span class="co">// 引数を2倍して出力する関数</span>
    <span class="kw">auto</span> print_twice = []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; <span class="dv">2</span> * value ; } ;

    for_each( std::begin(v), std::end(v), print_twice ) ;

    <span class="co">// 引数を出力したあとに改行を出力する関数</span>
    <span class="kw">auto</span> print_with_newline = []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; value &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;

    for_each( std::begin(v), std::end(v), print_with_newline ) ;
}</code></pre></div>
<p>関数は変数に代入しなくても使えるので、上のコードは以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 引数を出力する</span>
    for_each( std::begin(v), std::end(v),
        []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; value ; } ) ;

    <span class="co">// 引数を2倍して出力する</span>
    for_each( std::begin(v), std::end(v),
        []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; <span class="dv">2</span> * value ; } ) ;

    <span class="co">// 引数を出力したあとに改行を出力する関数</span>
    for_each( std::begin(v), std::end(v),
        []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; value &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ) ;
}</code></pre></div>
<p>わざわざ<code>for</code>文を書かずに、問題の本質的な処理だけを書くことができるようになった。</p>
<p>このイテレーターを先頭から末尾までループで回し、要素ごとに関数を呼び出すという処理はとても便利なので、標準ライブラリには<code>std::for_each( first, last, f)</code>がある。使い方は同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    std::for_each( std::begin(v), std::end(v),
        []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; value ; } ) ;
}</code></pre></div>
<p>C++17の時点ではまだ使えないが、将来のC++では、イテレーターを渡さずに、<code>vector</code>を直接渡すことができるようになる予定だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// C++20予定</span>

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    std::for_each( v, []( <span class="kw">auto</span> value ) { std::cout &lt;&lt; value ; } ) ;
}</code></pre></div>
<p>ところでもう一度<code>for_each</code>の実装を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> for_each = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> f )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        f( *iter ) ;
    }
} ;</code></pre></div>
<p><code>f(*iter)</code>がとても興味深い。もし関数<code>f</code>がリファレンスを引数に取っていたらどうなるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 引数をリファレンスで取って2倍にする関数</span>
    <span class="kw">auto</span> twice = [](<span class="kw">auto</span> &amp; value){ value = <span class="dv">2</span> * value ; } ;

    std::for_each( std::begin(v), std::end(v), twice ) ;

    <span class="co">// 引数を出力する関数</span>
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> &amp; value){ std::cout &lt;&lt; value &lt;&lt; <span class="st">&quot;, &quot;</span>s ; } ;

    <span class="co">// 2, 4, 6, 8, 10, </span>
    std::for_each( std::begin(v), std::end(v), print ) ;
}</code></pre></div>
<p>元の<code>vector</code>を書き換えることもできる。</p>
<h2 id="all_ofany_ofnone_of">all_of/any_of/none_of</h2>
<p>ほかのアルゴリズムも実装していくことで学んでいこう。</p>
<p><code>all_of(first, last, pred)</code>は、<code>[first,last)</code>の間のイテレーター<code>iter</code>のそれぞれに対して、<code>pred(*iter)</code>がすべて<code>true</code>を返すならば<code>true</code>、そうではないならば<code>false</code>を返すアルゴリズムだ。</p>
<p>この<code>all_of</code>は要素がすべて条件を満たすかどうかを調べるのに使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 要素がすべて偶数かどうか調べる関数</span>
<span class="kw">auto</span> is_all_of_odd = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="kw">return</span> std::all_of( first, last,
        []( <span class="kw">auto</span> value ) { <span class="kw">return</span> value % <span class="dv">2</span> == <span class="dv">0</span> ; } ) ;
} ;

<span class="co">// 要素がすべて100以下かどうか調べる関数</span>
<span class="kw">auto</span> is_all_of_le_100 = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="kw">return</span> std::all_of( first, last,
        []( <span class="kw">auto</span> value ) { <span class="kw">return</span> value &lt;= <span class="dv">100</span>; } ) ;
} ;</code></pre></div>
<p>ところで、もし要素がゼロ個の、つまり空のイテレーターを渡した場合どうなるのだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 空のvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    <span class="dt">bool</span> b = std::all_of( std::begin(v), std::end(v),
        <span class="co">// 特に意味のない関数</span>
        [](<span class="kw">auto</span> value){ <span class="kw">return</span> <span class="kw">false</span> ; } ) ;
}</code></pre></div>
<p>この場合、<code>all_of</code>は<code>true</code>を返す。</p>
<p>実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> all_of = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        <span class="kw">if</span> ( pred( *iter ) == <span class="kw">false</span> )
            <span class="kw">return</span> <span class="kw">false</span> ;
    }

    <span class="kw">return</span> <span class="kw">true</span> ;
} ;</code></pre></div>
<p><code>[first,last)</code>が空かどうかを確認する必要はない。というのも、空であればループは一度も実行されないからだ。</p>
<p><code>any_of(first, last, pred)</code>は<code>[first,last)</code>の間のイテレーター<code>iter</code>それぞれに対して、<code>pred(*iter)</code>が1つでも<code>true</code>ならば<code>true</code>を返す。空の場合、すべて<code>false</code>の場合は<code>false</code>を返す。</p>
<p><code>any_of</code>は要素に1つでも条件を満たすものがあるかどうかを調べるのに使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 要素に1つでも3が含まれているか？</span>
    <span class="co">// true</span>
    <span class="dt">bool</span> has_3 = std::any_of( std::begin(v), std::end(v),
        []( <span class="kw">auto</span> x ) { <span class="kw">return</span> x == <span class="dv">3</span> ;}  ) ;

    <span class="co">// 要素に1つでも10が含まれているか？</span>
    <span class="co">// false</span>
    <span class="dt">bool</span> has_10 = std::any_of( std::begin(v), std::end(v),
        []( <span class="kw">auto</span> x ) { <span class="kw">return</span> x == <span class="dv">10</span> ;}  ) ;
}</code></pre></div>
<p>これも実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> any_of = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        <span class="kw">if</span> ( pred( *iter ) )
            <span class="kw">return</span> <span class="kw">true</span> ;
    }
    <span class="kw">return</span> <span class="kw">false</span> ;
} ;</code></pre></div>
<p><code>none_of(first, last, pred)</code>は<code>[first,last)</code>の間のイテレーター<code>iter</code>それぞれに対して、<code>pred(*iter)</code>がすべて<code>false</code>ならば<code>true</code>を返す。空の場合は<code>true</code>を返す。それ以外は<code>false</code>を返す。</p>
<p><code>none_of</code>はすべての要素が条件を満たさない判定に使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 値は100か？</span>
    <span class="kw">auto</span> is_100 = [](<span class="kw">auto</span> x){ <span class="kw">return</span> x == <span class="dv">100</span> ; } ;

    <span class="dt">bool</span> b = std::none_of( std::begin(v), std::end(v), is_100 ) ;
}</code></pre></div>
<p>これも実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> none_of = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; first != last ; ++iter )
    {
        <span class="kw">if</span> ( pred(*iter) )
            <span class="kw">return</span> <span class="kw">false</span> ;
    }
    <span class="kw">return</span> <span class="kw">true</span> ;
} ;</code></pre></div>
<h2 id="findfind_if">find/find_if</h2>
<p><code>find( first, last, value )</code>はイテレーター<code>[first,last)</code>から<code>value</code>に等しい値を見つけて、そのイテレーターを返すアルゴリズムだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 3を指すイテレーター</span>
    <span class="kw">auto</span> pos = std::find( std::begin(v), std::end(v), <span class="dv">3</span> ) ;

    std::cout &lt;&lt; *pos ;
}</code></pre></div>
<p>要素が見つからない場合は<code>last</code>が返る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> pos = std::find( std::begin(v), std::end(v), <span class="dv">0</span> ) ;

    <span class="kw">if</span> ( pos != std::end(v) )
    {
        std::cout &lt;&lt; <span class="st">&quot;Found.&quot;</span>s ; 
    }
    <span class="kw">else</span>
    {
        std::cout &lt;&lt; <span class="st">&quot;Not found.&quot;</span>s ;
    }
}</code></pre></div>
<p>イテレーターが<code>last</code>かどうかは実際に<code>last</code>と比較すればよい。</p>
<p>アルゴリズムを理解するには、自分で実装してみるとよい。さっそく<code>find</code>を実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> find = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> <span class="dt">const</span> &amp; value )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        <span class="co">// 値を発見したらそのイテレーターを返す</span>
        <span class="kw">if</span> ( *iter == value )
            <span class="kw">return</span> iter ;
    }
    <span class="co">// 値が見つからなければ最後のイテレーターを返す</span>
    <span class="kw">return</span> last ;
} ;</code></pre></div>
<p><code>value</code>が<code>auto const &amp; value</code>になっているのは、リファレンスによってコピーを回避するためと、変更が必要ないためだ。しかし、<code>int</code>や<code>double</code>のような単純な型については、わざわざ<code>const</code>な<code>lvalue</code>リファレンスを使う必要はない。</p>
<p><code>find_if(first, last, pred)</code>はイテレーター<code>[first,last)</code>から、要素を関数<code>pred</code>に渡したときに<code>true</code>を返す要素へのイテレーターを探すアルゴリズムだ。</p>
<p>関数<code>pred</code>についてはもう少し解説が必要だ。<code>pred</code>とは<code>predicate</code>の略で、以下のような形をしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> pred = []( <span class="kw">auto</span> <span class="dt">const</span> &amp; value ) -&gt; <span class="dt">bool</span>
{
    <span class="kw">return</span> <span class="kw">true</span> ;
} ;</code></pre></div>
<p>関数<code>pred</code>は値を1つ引数に取り、<code>bool</code>型を返す関数だ。</p>
<p>さっそく使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>,<span class="dv">16</span>} ;

    <span class="co">// 偶数ならばtrueを返す</span>
    <span class="kw">auto</span> is_even = []( <span class="kw">auto</span> value )
    {
        <span class="kw">return</span> value % <span class="dv">2</span> == <span class="dv">0</span> ;
    } ;
    <span class="co">// 奇数ならばtrueを返す</span>
    <span class="kw">auto</span> is_odd = []( <span class="kw">auto</span> value )
    {
        <span class="kw">return</span> value % <span class="dv">2</span> == <span class="dv">1</span> ;
    } ;

    <span class="co">// 最初の偶数の要素</span>
    <span class="kw">auto</span> even = std::find_if( std::begin(v), std::end(v), is_even ) ;
    <span class="co">// 最初の奇数の要素</span>
    <span class="kw">auto</span> odd = std::find_if( std::begin(v), std::end(v), is_odd ) ;
}</code></pre></div>
<p>実装はどうなるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> find_if = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        <span class="co">// predがtrueを返した最初のイテレーターを返す</span>
        <span class="kw">if</span> ( pred( *iter ) )
            <span class="kw">return</span> iter ;
    }

    <span class="kw">return</span> last ;
} ;</code></pre></div>
<p>値との比較が関数になっただけだ。</p>
<p>つまりある値と比較する関数を渡したならば、<code>find_if</code>は<code>find</code>と同じ動きをするということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 引数が3の場合にtrueを返す関数</span>
    <span class="kw">auto</span> is_3 = []( <span class="kw">auto</span> x ) { <span class="kw">return</span> x == <span class="dv">3</span> ; } ;

    <span class="co">// 最初に関数がtrueを返す要素へのイテレーターを探すfind_if</span>
    <span class="kw">auto</span> i = std::find_if( std::begin(v), std::end(v), is_3 ) ;

    <span class="co">// 最初に3と等しい要素へのイテレーターを返すfind</span>
    <span class="kw">auto</span> j = std::find( std::begin(v), std::end(v), <span class="dv">3</span> ) ;

    <span class="co">// 同じイテレーター</span>
    <span class="dt">bool</span> b = (i == j) ;
}</code></pre></div>
<p>実は、関数は特別な<code>[=]</code>を使うことで、関数の外側の値をコピーして使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> value = <span class="dv">123</span> ;

    <span class="kw">auto</span> f = [=]{ <span class="kw">return</span> value ; } ;

    f() ; <span class="co">// 123</span>
}</code></pre></div>
<p>特別な<code>[&amp;]</code>を使うことで、関数の外側の値をリファレンスで使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> value = <span class="dv">123</span> ;

    <span class="kw">auto</span> f = [&amp;]{ ++value ; } ; 

    f() ;
    std::cout &lt;&lt; value ; <span class="co">// 124</span>
}</code></pre></div>
<p>ということは、<code>find</code>は<code>find_if</code>で実装することもできるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> find = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> value )
{
    <span class="kw">return</span> std::find_if( first, last,
        [&amp;]( <span class="kw">auto</span> elem ) { <span class="kw">return</span> value == elem ; } ) ;
} ;</code></pre></div>
<h2 id="countcount_if">count/count_if</h2>
<p><code>count(first, last, value)</code>は<code>[first,last)</code>の範囲のイテレーター<code>i</code>から<code>*i == value</code>になるイテレーター<code>i</code>の数を数える。</p>
<p><code>count</code>は指定した値と同じ要素の数を数える関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>} ;

    <span class="co">// 3</span>
    <span class="kw">auto</span> a = std::count( std::begin(v), std::end(v), <span class="dv">1</span> ) ;
    <span class="co">// 1</span>
    <span class="kw">auto</span> b = std::count( std::begin(v), std::end(v), <span class="dv">2</span> ) ;
    <span class="co">// 2</span>
    <span class="kw">auto</span> c = std::count( std::begin(v), std::end(v), <span class="dv">3</span> ) ;
}</code></pre></div>
<p>実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> count = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> value )
{
    <span class="kw">auto</span> counter = <span class="dv">0u</span> ;
    <span class="kw">for</span> ( <span class="kw">auto</span> i = first ; i != last ; ++i )
    {
        <span class="kw">if</span> ( *i == value )
            ++counter ;  
    }
    <span class="kw">return</span> counter ;
} ;</code></pre></div>
<p><code>count_if(first, last, pred)</code>は<code>[first, last)</code>の範囲のイテレーター<code>i</code>から<code>pred(*i) != false</code>になるイテレーター<code>i</code>の数を返す。</p>
<p><code>count_if</code>は要素を数える対象にするかどうかを判定する関数を渡せる<code>count</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>} ;

    <span class="co">// 奇数の数: 5</span>
    <span class="kw">auto</span> a = std::count_if( std::begin(v), std::end(v),
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> x%<span class="dv">2</span> == <span class="dv">1</span> ; } ) ;

    <span class="co">// 偶数の数: 1</span>
    <span class="kw">auto</span> b = std::count_if( std::begin(v), std::end(v),
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> x%<span class="dv">2</span> == <span class="dv">0</span> ; } ) ;

    <span class="co">// 2以上の数: 3</span>
    <span class="kw">auto</span> c = std::count_if( std::begin(v), std::end(v),
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> x &gt;= <span class="dv">2</span> ; } ) ;
}</code></pre></div>
<p>実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> count = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )
{
    <span class="kw">auto</span> counter = <span class="dv">0u</span> ;
    <span class="kw">for</span> ( <span class="kw">auto</span> i = first ; i != last ; ++i )
    {
        <span class="kw">if</span> ( pred(*i) != <span class="kw">false</span> )
            ++counter ;  
    }
    <span class="kw">return</span> counter ;
} ;</code></pre></div>
<h2 id="equal">equal</h2>
<p>これまでのアルゴリズムは1つのイテレーターの範囲だけを扱ってきた。アルゴリズムの中には複数の範囲を取るものもある。</p>
<p><code>equal(first1, last1, first2, last2)</code>は<code>[first1, last1)</code>と<code>[first2, last2)</code>が等しい場合に<code>true</code>を返す。「等しい」というのは、要素の数が同じで、各要素がそれぞれ等しい場合を指す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// aと等しい</span>
    std::vector&lt;<span class="dt">int</span>&gt; b = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// aと等しくない</span>
    std::vector&lt;<span class="dt">int</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;
    <span class="co">// aと等しくない</span>
    std::vector&lt;<span class="dt">int</span>&gt; d = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>} ;

    <span class="co">// true</span>
    <span class="dt">bool</span> ab = std::equal(
        std::begin(a), std::end(a),
        std::begin(b), std::end(b) ) ;

    <span class="co">// false</span>
    <span class="dt">bool</span> ac = std::equal(
        std::begin(a), std::end(a),
        std::begin(c), std::end(c) ) ;

    <span class="co">// false</span>
    <span class="dt">bool</span> ad = std::equal(
        std::begin(a), std::end(a),
        std::begin(d), std::end(d) ) ;
}</code></pre></div>
<p>実装は、まず要素数を比較し、等しくなければ<code>false</code>を返す。次に各要素を1つずつ比較し、途中で等しくない要素が見つかれば<code>false</code>を、最後まで各要素が等しければ<code>true</code>を返す。</p>
<p>イテレーターの範囲<code>[first, last)</code>の要素数は<code>last-first</code>で取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 最初の要素</span>
    <span class="kw">auto</span> first = std::begin(v) ;
    <span class="co">// 最後の1つ次の要素</span>
    <span class="kw">auto</span> last = std::end(v) ;

    <span class="co">// 要素数: 5</span>
    <span class="kw">auto</span> size = last - first ;

    <span class="co">// 最初の次の要素</span>
    <span class="kw">auto</span> next = first + <span class="dv">1</span> ;

    <span class="co">// 4</span>
    <span class="kw">auto</span> size_from_next = last - next ;
}</code></pre></div>
<p><code>last-first</code>という表記はわかりにくいので、C++には<code>distance(first, last)</code>というライブラリが用意されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> distance = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last )
{
    <span class="kw">return</span> last - first ;
} ;</code></pre></div>
<p>これを使えばわかりやすく書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 最初の要素</span>
    <span class="kw">auto</span> first = std::begin(v) ;
    <span class="co">// 最後の1つ次の要素</span>
    <span class="kw">auto</span> last = std::end(v) ;

    <span class="co">// 要素数: 5</span>
    <span class="kw">auto</span> size = std::distance( first, last ) ;

    <span class="co">// 4</span>
    <span class="kw">auto</span> size_from_next = std::distance( first + <span class="dv">1</span>, last ) ;
}</code></pre></div>
<p>あとは実装するだけだ(この実装は最も効率のいい実装ではない。理由についてはイテレーターの章を参照)。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> equal = []( <span class="kw">auto</span> first1, <span class="kw">auto</span> last1, <span class="kw">auto</span> first2, <span class="kw">auto</span> last2)
{
    <span class="co">// 要素数が等しいことを確認</span>
    <span class="kw">auto</span> size1 = std::distance( first1, last1 ) ;
    <span class="kw">auto</span> size2 = std::distance( first2, last2 ) ;

    <span class="kw">if</span> ( size1 != size2 )
        <span class="co">// 要素数が等しくなかった</span>
        <span class="kw">return</span> <span class="kw">false</span> ;

    <span class="co">// 各要素が等しいことを確認</span>
    <span class="kw">for</span> (   <span class="kw">auto</span> i = first1, j = first2 ;
            i != last1 ; ++i, ++j )
    {
        <span class="kw">if</span> ( *i != *j )
            <span class="co">// 等しくない要素があった</span>
            <span class="kw">return</span> <span class="kw">false</span> ;
    }
    <span class="co">// 各要素がすべて等しかった</span>
    <span class="kw">return</span> <span class="kw">true</span> ;
} ;</code></pre></div>
<p><code>for</code>文の終了条件では<code>i != last1</code>だけを見ていて、<code>j != last2</code>は見ていないが、これは問題がない。なぜならば、この<code>for</code>文が実行されるのは、要素数が等しい場合だけだからだ。</p>
<p>関数<code>pred</code>を取る<code>equal(first1, last1, first2, last2, pred)</code>もある。この<code>pred</code>は<code>pred(a, b)</code>で、<code>a</code>と<code>b</code>が等しい場合に<code>true</code>、そうでない場合に<code>false</code>を返す関数だ。つまり<code>a == b</code>の<code>operator ==</code>の代わりに使う関数を指定する。</p>
<p><code>equal</code>に関数を渡すことにより、例えば小数点以下の値を誤差として切り捨てるような処理が書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">double</span>&gt; v = {<span class="fl">1.3</span>, <span class="fl">2.2</span>, <span class="fl">3.0</span>, <span class="fl">4.9</span>, <span class="fl">5.7</span>} ;
    std::vector&lt;<span class="dt">double</span>&gt; w = {<span class="fl">1.9</span>, <span class="fl">2.4</span>, <span class="fl">3.8</span>, <span class="fl">4.5</span>, <span class="fl">5.0</span>} ;

    <span class="co">// 小数点以下は誤差として切り捨てる比較</span>
    <span class="kw">auto</span> comp = []( <span class="kw">auto</span> a, <span class="kw">auto</span> b )
    {
        <span class="kw">return</span> std::floor(a) == std::floor(b) ;
    } ;

    <span class="dt">bool</span> b = std::equal(
        std::begin(v), std::end(v),
        std::begin(w), std::end(w),
        comp ) ;
}</code></pre></div>
<p><code>std::floor(x)</code>は浮動小数点数<code>x</code>の小数点数以下を切り捨てた結果を返す関数だ。<code>floor(0.999)</code>は<code>0.0</code>に、<code>floor(1.999)</code>は<code>1.0</code>になる。</p>
<p>本書をここまで読んできた読者であれば実装は自力でできるだろう。</p>
<h2 id="search">search</h2>
<p><code>search( first1, last1, first2, last2)</code>はイテレーター<code>[first2, last2)</code>の範囲で示された連続した要素の並びがイテレーター<code>[first1, last1)</code>の範囲に存在すれば<code>true</code>、そうでない場合は<code>false</code>を返す。</p>
<p>こう書くと難しいが、例を見るとわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v1 = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; v2 = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;

    <span class="co">// true</span>
    <span class="dt">bool</span> a = std::search( std::begin(v1), std::end(v1), std::begin(v2), std::end(v2) ) ;

    std::vector&lt;<span class="dt">int</span>&gt; v3 = {<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>} ;
    <span class="co">// false </span>
    <span class="dt">bool</span> a = std::search( std::begin(v1), std::end(v1), std::begin(v3), std::end(v3) ) ;
}</code></pre></div>
<p>この例では、<code>v1</code>の中に<code>v2</code>と同じ並びの<code>{4,5,6}</code>が存在するので<code>true</code>、<code>v3</code>と同じ並びの<code>{1,3,5}</code>は存在しないので<code>false</code>になる。</p>
<p><code>search</code>の実装例はいまの読者にはまだ理解できない。<code>equal</code>や<code>search</code>を効率的に実装するにはイテレーターの詳細な理解が必要だ。</p>
<h2 id="copy">copy</h2>
<p>これまでのアルゴリズムは<code>for_each</code>を除き要素の変更をしてこなかった。<code>copy</code>は要素の変更をするアルゴリズムだ。</p>
<p>イテレーター<code>i</code>は<code>*i</code>で参照する要素の値として使うことができるほか、<code>*i = x</code>で要素に値<code>x</code>を代入できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>} ;

    <span class="kw">auto</span> i = std::begin(v) ;

    <span class="co">// 参照する要素を値として使う</span>
    std::cout &lt;&lt; *i ;
    <span class="co">// 参照する要素に値を代入する。</span>
    *i = <span class="dv">2</span> ;
}</code></pre></div>
<p><code>copy(first, last, result)</code>はイテレーター<code>[first, last)</code>の範囲の値を、先頭から順番にイテレーター<code>result</code>に書き込んでいくアルゴリズムだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// 要素数5のvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;

    std::copy( std::begin(source), std::end(source), std::begin(destination) ) ;

    <span class="co">// destinationの中身は{1,2,3,4,5}</span>
}</code></pre></div>
<p>これは実質的に以下のような操作をしたのと等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;
    <span class="co">// 要素をそれぞれコピー </span>
   destination[<span class="dv">0</span>] = source[<span class="dv">0</span>] ;
   destination[<span class="dv">1</span>] = source[<span class="dv">1</span>] ;
   destination[<span class="dv">2</span>] = source[<span class="dv">2</span>] ;
   destination[<span class="dv">3</span>] = source[<span class="dv">3</span>] ;
   destination[<span class="dv">4</span>] = source[<span class="dv">4</span>] ;
   
}</code></pre></div>
<p>イテレーター<code>result</code>は先頭のイテレーターのみで末尾のイテレーターは渡さない。イテレーター<code>result</code>はイテレーター<code>[first, last)</code>の範囲の要素数をコピーできるだけの要素数の範囲を参照していなければならない。</p>
<p>例えば以下の例はエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// 要素数3のvector</span>
    std::vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">3</span>) ;

    <span class="co">// エラー</span>
    std::copy( std::begin(source), std::end(source), std::begin(destination) ) ;
}</code></pre></div>
<p>要素数が3しかない<code>vector</code>に5個の要素をコピーしようとしている。</p>
<p><code>copy</code>の戻り値は<code>[first,last)</code>の要素数だけ進めたイテレーター<code>result</code>になる。これはつまり、<code>result + (last - first)</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; source = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; destination(<span class="dv">5</span>) ;
    
    <span class="kw">auto</span> first = std::begin(source) ;
    <span class="kw">auto</span> last = std::end(source) ;
    <span class="kw">auto</span> result = std::begin(destination) ;
    
    <span class="kw">auto</span> returned = std::copy( first, last, result ) ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b = (returned == (result + (last - first)) ;
}</code></pre></div>
<p>ここで、<code>last-first</code>は<code>source</code>の要素数の<code>5</code>なので、<code>result + 5</code>は<code>copy</code>の戻り値のイテレーターと等しい。</p>
<p><code>copy</code>には<code>[first,last)</code>の範囲が<code>result</code>から続く範囲とオーバーラップしてはいけないという制約がある。</p>
<p>オーバーラップというのは、同じ要素を参照しているという意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="co">// [first,last)とresultがオーバーラップしている</span>
    std::copy( std::begin(v), std::end(v), std::begin(v) ) ;
}</code></pre></div>
<p>オーバーラップした場合、<code>copy</code>の動作は保証されない。</p>
<p>実装例。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> copy = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> result )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter, ++result )
    { *result = *iter ; }

    <span class="kw">return</span> result ;
} ;</code></pre></div>
<h2 id="transform">transform</h2>
<p><code>transform(first, last, result, op)</code>は<code>copy</code>に似ているが、<code>result</code>へのコピーが<code>*result = *iter ;</code>ではなく、<code>*result = op(*iter) ;</code>になる。<code>op</code>は関数だ。</p>
<p>以下が実装例だ。<code>copy</code>とほぼ同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> transform = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> result, <span class="kw">auto</span> op )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter, ++result )
    { *result = op(*iter) ; }

    <span class="kw">return</span> result ;
} ;</code></pre></div>
<p>使い方は<code>copy</code>と似ているが、値をコピーをする際に関数を適用することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    std::vector&lt;<span class="dt">int</span>&gt; b(<span class="dv">5</span>) ;
    std::transform( std::begin(a), std::end(a), std::begin(b),
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> <span class="dv">2</span>*x ; } ) ;
    <span class="co">// bは{2,4,6,8,10}</span>


    std::vector&lt;<span class="dt">int</span>&gt; c(<span class="dv">5</span>) ;
    std::transform( std::begin(a), std::end(a), std::begin(c),
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> x % <span class="dv">3</span> ; } ) ;
    <span class="co">// cは{1,2,0,1,2}</span>

    
    std::vector&lt;<span class="dt">bool</span>&gt; d(<span class="dv">5</span>) ;
    std::transform( std::begin(a), std::end(a), std::begin(d),
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> x &lt; <span class="dv">3</span> ; } ) ;
    <span class="co">// dは{true,true,false,false,false}</span>
}</code></pre></div>
<p><code>result</code>に代入されるのは関数<code>op</code>の戻り値だ。関数<code>op</code>は値を1つの引数で受け取り値を返す関数だ。</p>
<h2 id="replace">replace</h2>
<p><code>replace(first, last, old_value, new_value)</code>はイテレーター<code>[first,last)</code>の範囲のイテレーターが指す要素の値が<code>old_value</code>に等しいものを<code>new_value</code>に置換する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::replace( std::begin(a), std::end(a), <span class="dv">3</span>, <span class="dv">0</span> ) ;
    <span class="co">// aは{1,2,0,0,4,5,0,4,5}</span>
}</code></pre></div>
<p>実装も簡単。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> replace = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> old_value, <span class="kw">auto</span> new_value )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; first != last ; ++iter )
    {
        <span class="kw">if</span> ( *iter == old_value )
            *iter = new_value ;
    }
} ;</code></pre></div>
<h2 id="fill">fill</h2>
<p><code>fill(first, last, value)</code>はイテレーター<code>[first,last)</code>の範囲をイテレーターが参照する要素に<code>value</code>を代入する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::fill( std::begin(v), std::end(v), <span class="dv">0</span> ) ;
    <span class="co">// vは{0,0,0,0,0}</span>
}</code></pre></div>
<p><code>fill_n(first, n, value)</code>はイテレーター<code>[first, first+n)</code>の範囲のイテレーターが参照する要素に<code>value</code>を代入する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::fill_n( std::begin(v), <span class="dv">5</span>, <span class="dv">0</span> ) ;
    <span class="co">// vは{0,0,0,0,0}</span>
}</code></pre></div>
<p>実装例。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> fill_n = []( <span class="kw">auto</span> first, <span class="kw">auto</span> n, <span class="kw">auto</span> value )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> i = <span class="dv">0</span> ; i != n ; ++i, ++first )
    {
        *first = value ;
    }
} ;</code></pre></div>
<h2 id="generate">generate</h2>
<p><code>generate</code>は<code>fill</code>に似ているが、値として<code>value</code>を取るのではなく、関数<code>gen</code>を取る。</p>
<p><code>generate(first, last, gen)</code>はイテレーター<code>[first, last)</code>の範囲のイテレーターが参照する要素に<code>gen()</code>を代入する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> gen_zero = [](){ <span class="kw">return</span> <span class="dv">0</span> ; } ;
    std::generate( std::begin(v), std::end(v), gen_zero ) ;
    <span class="co">// vは{0,0,0,0,0}</span>
}</code></pre></div>
<p><code>generate_n(first, n, gen)</code>は<code>fill_n</code>の<code>generate</code>版だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> gen_zero = []{ <span class="kw">return</span> <span class="dv">0</span> ; } ;
    std::generate_n( std::begin(v), <span class="dv">5</span>, gen_zero ) ;
    <span class="co">// vは{0,0,0,0,0}</span>
}</code></pre></div>
<p>実装例は単純だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> generate = []( first, last, gen )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    {
        *iter = gen() ;
    }
} ;

<span class="kw">auto</span> generate_n = []( first, n, gen )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> i = <span class="dv">0u</span> ; i != n ; ++i, ++iter )
    {
        *iter = gen() ;
    }
} ;</code></pre></div>
<h2 id="remove">remove</h2>
<p><code>remove(first, last, value)</code>はイテレーター<code>[first,last)</code>の範囲の参照する要素から、値<code>value</code>に等しいものを取り除く。そして新しい終端イテレーターを返す。</p>
<p>アルゴリズム<code>remove</code>が値を取り除くというとやや語弊がある。例えば以下のような数列があり、</p>
<pre><code>1, 2, 3</code></pre>
<p>この中から値<code>2</code>を<code>remove</code>のように取り除く場合、以下のようになる。</p>
<pre><code>1, 3, ?</code></pre>
<p><code>remove</code>は取り除くべき値の入った要素を、後続の値で上書きする。この場合、1番目の<code>2</code>を2番目の<code>3</code>で上書きする。2番目は不定な状態になる。これは、<code>remove</code>アルゴリズムは2番目がどのような値になるかを保証しないという意味だ。</p>
<p>以下のような数列で値<code>2</code>を<code>remove</code>したとき</p>
<pre><code>1,2,2,3,2,2,4</code></pre>
<p>以下のようになる。</p>
<pre><code>1,3,4,?,?,?,?</code></pre>
<p><code>remove</code>の戻り値は、新しいイテレーターの終端を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> last2 = remove( first, last, value ) ;</code></pre></div>
<p>この例では、<code>remove</code>は<code>[first, last)</code>から値<code>value</code>に等しい要素を取り除いたイテレーターの範囲を戻り値として返す。その戻り値が<code>last2</code>だ。<code>[first, last2)</code>が値を取り除いたあとの新しいイテレーターの範囲だ。</p>
<p><code>remove</code>を呼び出しても元の<code>vector</code>の要素数が変わることはない。<code>remove</code>は<code>vector</code>の要素の値を変更するだけだ。</p>
<p>以上を踏まえて、以下が<code>remove</code>を使う例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> last = std::remove( std::begin(v), std::end(v), <span class="dv">2</span> ) ;

    <span class="co">// &quot;13&quot;</span>
    std::for_each( std::begin(v), last,
        [](<span class="kw">auto</span> x) { std::cout &lt;&lt; x ; } ) ;

    std::vector&lt;<span class="dt">int</span>&gt; w = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">4</span>} ;

    <span class="kw">auto</span> last2 = std::remove( std::begin(w), std::end(w), <span class="dv">2</span> ) ;

    <span class="co">// &quot;134&quot;</span>
    std::for_each( std::begin(w), last2,
        [](<span class="kw">auto</span> x) { std::cout &lt;&lt; x ; } ) ;
   
}</code></pre></div>
<p><code>remove_if(first, last, pred)</code>は、<code>[first, last)</code>の範囲の要素を指すイテレーター<code>i</code>のうち、関数<code>pred</code>に渡した結果<code>pred(*i)</code>が<code>true</code>になる要素を取り除くアルゴリズムだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 偶数の場合true、奇数の場合falseを返す関数</span>
    <span class="kw">auto</span> is_even = []( <span class="kw">auto</span> x ) { <span class="kw">return</span> x%<span class="dv">2</span> == <span class="dv">0</span> ; } ;

    std::vector v = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span> } ;
    <span class="co">// 偶数を取り除く</span>
    <span class="kw">auto</span> last = std::remove_if( std::begin(v), std::end(v), is_even ) ;

    <span class="co">// [ std::begin(v), last)は{1,3,5,7,9}</span>
}</code></pre></div>
<p><code>remove</code>は現在知っている知識だけではまだ完全に実装できない。以下は不完全な実装の例だ。<code>remove</code>を完全に理解するためには<code>ムーブセマンティクス</code>の理解が必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> remove_if = []( <span class="kw">auto</span> first, <span class="kw">auto</span> last, <span class="kw">auto</span> pred )
{
    <span class="co">// removeする最初の要素</span>
    <span class="kw">auto</span> removing = std::find_if( first, last, pred ) ;
    <span class="co">// removeする要素がなかった</span>
    <span class="kw">if</span> ( removing == last )
        <span class="kw">return</span> last ;

    <span class="co">// removeする要素の次の要素</span>
    <span class="kw">auto</span> remaining = removing ;
    ++remaining ;

    <span class="co">// removeする要素に上書きする</span>
    <span class="kw">for</span> (  ; remaining != last ; ++remaining )
    {
        <span class="co">// 上書き元も取り除くのであればスキップ</span>
        <span class="kw">if</span> ( pred( *remaining ) == <span class="kw">false</span> )
        {
            *removing = *remaining ;
            ++removing ;
        }

    }
    <span class="co">// 新しい終端イテレーター</span>
    <span class="kw">return</span> removing ;
} ;</code></pre></div>
<h1 id="ラムダ式">ラムダ式</h1>
<p>実は以下の形の関数は、「関数」ではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> function = []( <span class="kw">auto</span> value ) { <span class="kw">return</span> value } ;</code></pre></div>
<p>これは<code>ラムダ式</code>と呼ばれるC++の機能で、関数のように振る舞うオブジェクトを作るための式だ。</p>
<h2 id="基本">基本</h2>
<p><code>ラムダ式</code>の基本の文法は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[](){} ;</code></pre></div>
<p>これを細かく分解すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]  <span class="co">// ラムダ導入子</span>
()  <span class="co">// 引数リスト</span>
{}  <span class="co">// 複合文</span>
;   <span class="co">// 文末</span></code></pre></div>
<p><code>ラムダ導入子</code>はさておく。</p>
<p><code>引数リスト</code>は通常の関数と同じように型名と名前を書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> x, <span class="dt">double</span> d ) { }

[]( <span class="dt">int</span> x, <span class="dt">double</span> d ) { } ;</code></pre></div>
<p><code>ラムダ式</code>では、<code>引数リスト</code>に<code>auto</code>キーワードが使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]( <span class="kw">auto</span> x ) { } ;</code></pre></div>
<p>このように書くとどんな型でも受け取れるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []( <span class="kw">auto</span> x )
    { std::cout &lt;&lt; x ; } ;

    f(<span class="dv">0</span>) ; <span class="co">// int</span>
    f(<span class="fl">1.0</span>) ; <span class="co">// double</span>
    f(<span class="st">&quot;hello&quot;</span>s) ; <span class="co">// std::string</span>
}</code></pre></div>
<p><code>複合文</code>は<code>{}</code>だ。この<code>{}</code>の中に通常の関数と同じように複数の文を書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]()
{
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span>s ;
    <span class="dt">int</span> x = <span class="dv">1</span> + <span class="dv">1</span> ;
} ;</code></pre></div>
<p>最後の<code>文末</code>は<code>文</code>の最後に付けるセミコロンだ。これは<code>&quot;1+1 ;&quot;</code>とするのと変わらない。<code>&quot;1+1&quot;</code>や<code>&quot;[](){}&quot;</code>は<code>式</code>で、<code>文</code>は<code>式</code>を使うことができる。<code>式</code>だけが入った<code>文</code>を専門用語では<code>式文</code>と呼ぶが特に覚える必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span> + <span class="dv">1</span> ; <span class="co">// OK、式文</span>
[](){} ; <span class="co">// OK、式文</span></code></pre></div>
<p><code>ラムダ式</code>は<code>式</code>なので<code>式文</code>の中に書くことができる。</p>
<p><code>ラムダ式</code>は<code>式</code>なので、そのまま<code>関数呼び出し</code>することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( std::string x )
{
    std::cout &lt;&lt; x ;
}

<span class="dt">int</span> main()
{
    f( <span class="st">&quot;hello&quot;</span>s ) ;
    []( <span class="kw">auto</span> x ){ std::cout &lt;&lt; x ; }( <span class="st">&quot;hello&quot;</span>s ) ;
}</code></pre></div>
<p>これはわかりやすくインデントすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f               <span class="co">// 関数</span>
( <span class="st">&quot;hello&quot;</span>s ) ;  <span class="co">// 関数呼び出し</span>

<span class="co">// ラムダ式</span>
[]( <span class="kw">auto</span> x ){ std::cout &lt;&lt; x ; }
( <span class="st">&quot;hello&quot;</span>s ) ;  <span class="co">// 関数呼び出し</span></code></pre></div>
<p>ラムダ式が引数を1つも取らない場合、<code>引数リスト</code>は省略できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 引数を取らないラムダ式</span>
[](){} ;
<span class="co">// 引数リストは省略できる</span>
[]{} ;</code></pre></div>
<p>ラムダ式の戻り値の型は<code>return</code>文から推定される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
[]{ <span class="kw">return</span> <span class="dv">0</span> ; } ;
<span class="co">// double</span>
[]{ <span class="kw">return</span> <span class="fl">0.0</span> ; } ;
<span class="co">// std::string</span>
[]{ <span class="kw">return</span> <span class="st">&quot;hello&quot;</span>s ; } ;</code></pre></div>
<p><code>return</code>文で複数の型を返した場合は推定ができないのでエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]( <span class="dt">bool</span> b )
{
    <span class="kw">if</span> ( b )
        <span class="kw">return</span> <span class="dv">0</span> ;
    <span class="kw">else</span>
        <span class="kw">return</span> <span class="fl">0.0</span> ;
} ;</code></pre></div>
<p>戻り値の型を指定したい場合は<code>引数リスト</code>のあとに<code>-&gt;</code>を書き、型名を書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]( <span class="dt">bool</span> b ) -&gt; <span class="dt">int</span>
{
    <span class="kw">if</span> ( b )
        <span class="kw">return</span> <span class="dv">0</span> ;
    <span class="kw">else</span>
        <span class="co">// doubleからintへの変換</span>
        <span class="kw">return</span> <span class="fl">0.0</span> ;
} ;</code></pre></div>
<p>戻り値の型の推定は通常の関数も同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">auto</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="co">// 戻り値の型の明示的な指定</span>
<span class="kw">auto</span> f() -&gt; <span class="dt">int</span> { <span class="kw">return</span> <span class="dv">0</span> ; }</code></pre></div>
<h2 id="キャプチャー">キャプチャー</h2>
<p><code>ラムダ式</code>は書かれている関数のローカル変数を使うことができる。これを<code>キャプチャー</code>という。<code>キャプチャー</code>は通常の関数にはできない<code>ラムダ式</code>の機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="co">// ローカル関数</span>
    <span class="kw">auto</span> message = <span class="st">&quot;hello&quot;</span>s ;

    [=](){ std::cout &lt;&lt; message ; } ;
}</code></pre></div>
<p><code>キャプチャー</code>には<code>コピーキャプチャー</code>と<code>リファレンスキャプチャー</code>がある。</p>
<h3 id="コピーキャプチャー">コピーキャプチャー</h3>
<p><code>コピーキャプチャー</code>は変数をコピーによってキャプチャーする。</p>
<p><code>コピーキャプチャー</code>をするには、<code>ラムダ式</code>を<code>[=]</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="co">// コピーキャプチャー</span>
    [=]{ <span class="kw">return</span> x ; } ;
}</code></pre></div>
<p><code>コピーキャプチャー</code>した変数はラムダ式の中で変更できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="co">// エラー</span>
    [=]{ x = <span class="dv">0</span> ; } ;
}</code></pre></div>
<p>変更できるようにする方法もあるのだが、通常は使われない。</p>
<h3 id="リファレンスキャプチャー">リファレンスキャプチャー</h3>
<p><code>リファレンスキャプチャー</code>は変数をリファレンスによってキャプチャーする。</p>
<p><code>リファレンス</code>を覚えているだろうか。リファレンスは初期化時の元の変数を参照する変数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="co">// 通常の変数</span>
    <span class="dt">int</span> y = x ;

    <span class="co">// 変数を変更</span>
    y = <span class="dv">1</span> ;
    <span class="co">// xの値は変わらない</span>

    <span class="co">// リファレンス</span>
    <span class="dt">int</span> &amp; ref = x ;

    <span class="co">// リファレンスを変更</span>
    ref = <span class="dv">1</span> ;
    <span class="co">// xの値が変わる</span>
}</code></pre></div>
<p><code>リファレンスキャプチャー</code>を使うには、<code>ラムダ式</code>を<code>[&amp;]</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    [&amp;] { <span class="kw">return</span> x ; } ;
}</code></pre></div>
<p><code>リファレンスキャプチャー</code>した変数を<code>ラムダ式</code>の中で変更すると、元の変数が変更される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="kw">auto</span> f = [&amp;]{ ++x ; } ;

    f() ; <span class="co">// x == 1</span>
    f() ; <span class="co">// x == 2</span>
    f() ; <span class="co">// x == 3</span>
}</code></pre></div>
<p>ラムダ式についてはまだいろいろな機能があるが、本書での解説はここまでとする。</p>
<h1 id="クラスの基本">クラスの基本</h1>
<p>C++はもともとC言語に<code>クラス</code>の機能を追加することを目的とした言語だった。</p>
<p><code>クラス</code>とは何か。クラスにはさまざまな機能があるが、最も基本的な機能としては以下の2つがある。</p>
<ul>
<li>変数をまとめる</li>
<li>まとめた変数に関数を提供する</li>
</ul>
<p>この章は<code>クラス</code>の数ある機能のうち、この2つの機能だけを説明する。</p>
<h2 id="変数をまとめる">変数をまとめる</h2>
<p>2次元座標上の点<code>(x,y)</code>を表現するプログラムを書くとする。</p>
<p>とりあえず<code>int</code>型で表現してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 表現</span>
    <span class="dt">int</span> point_x = <span class="dv">0</span>;
    <span class="dt">int</span> point_y = <span class="dv">0</span>;
}</code></pre></div>
<p>これはわかりやすい。ところでものは相談だが、点は複数表現したい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x1 = <span class="dv">0</span> ;
    <span class="dt">int</span> y1 = <span class="dv">0</span> ;

    <span class="dt">int</span> x2 = <span class="dv">0</span> ;
    <span class="dt">int</span> y2 = <span class="dv">0</span> ;

    <span class="dt">int</span> x3 = <span class="dv">0</span> ;
    <span class="dt">int</span> y3 = <span class="dv">0</span> ;
}</code></pre></div>
<p>これはわかりにくい。ところで点はユーザーがいくつでも入力できるものとしよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; xs ;
    std::vector&lt;<span class="dt">int</span>&gt; ys ;

    <span class="co">// xs.at(i)とys.at(i)は同じ点のための変数</span>

    <span class="dt">int</span> x {} ;
    <span class="dt">int</span> y {} ;
    <span class="kw">while</span> ( std::cin &gt;&gt; x &gt;&gt; y )
    {
        xs.push_back(x) ;
        ys.push_back(y) ;
    }
}</code></pre></div>
<p>これはとてもわかりにくい。</p>
<p>ここで<code>クラス</code>の出番だ。<code>クラス</code>を使うと点を表現するコードは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> point
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="dt">int</span> y = <span class="dv">0</span> ;
} ;

<span class="dt">int</span> main()
{
    point p ;

    std::cout &lt;&lt; p.x &lt;&lt; p.y ;
}</code></pre></div>
<p>点を複数表現するのもわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">point p1 ;
point p2 ;
point p3 ;</code></pre></div>
<p>ユーザーが好きなだけ点を入力できるプログラムもわかりやすく書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> point
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="dt">int</span> y = <span class="dv">0</span> ;
} ;

<span class="dt">int</span> main()
{
    std::vector&lt;point&gt; ps ;

    <span class="dt">int</span> x { } ;
    <span class="dt">int</span> y { } ;

    <span class="kw">while</span>( std::cin &gt;&gt; x &gt;&gt; y )
    {
        ps.push_back( point{ x, y } ) ;
    }    
}</code></pre></div>
<p>これが<code>クラス</code>の変数をまとめる機能だ。</p>
<p><code>クラス</code>を定義するには、キーワード<code>struct</code>に続いて<code>クラス名</code>を書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> class_name 
{

} ;</code></pre></div>
<p>変数は<code>{}</code>の中に書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> a = <span class="dv">0</span> ;
    <span class="dt">double</span> b = <span class="fl">0.0</span> ;
    std::string c = <span class="st">&quot;hello&quot;</span>s ;
} ;</code></pre></div>
<p>このクラスの中に書かれた変数のことを、<code>データメンバー</code>という。正確には変数ではない。</p>
<p>定義した<code>クラス</code>は変数として宣言して使うことができる。<code>クラス</code>の<code>データメンバー</code>を使うには、クラス名に引き続いてドット文字を書きデータメンバー名を書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 名前と年齢を表現するクラスPerson</span>
<span class="kw">struct</span> Person
{
    std::string name ;
    <span class="dt">int</span> age ;
} ;

<span class="dt">int</span> main()
{
    Person john ;
    john.name = <span class="st">&quot;john&quot;</span> ;
    john.age = <span class="dv">20</span> ;
}</code></pre></div>
<p><code>クラス</code>の<code>データメンバー</code>の定義は変数ではない。オブジェクトではない。つまり、それ自体にストレージが割り当てられてはいない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// これは変数ではない</span>
    <span class="dt">int</span> data ;
} ;</code></pre></div>
<p>クラスの変数を定義したときに、その変数のオブジェクトに紐付いたストレージが使われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data ;
} ;

<span class="dt">int</span> main()
{
    S s1 ; <span class="co">// 変数</span>
    <span class="co">// オブジェクトs1に紐付いたストレージ</span>
    s1.data = <span class="dv">0</span> ;

    S s2 ;
    <span class="co">// 別のストレージ</span>
    s2.data = <span class="dv">1</span> ; 

    <span class="co">// false</span>
    <span class="dt">bool</span> b = s1.data == s2.data ;
}</code></pre></div>
<p>クラスの変数を定義するときにデータメンバーを初期化できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x ;
    <span class="dt">int</span> y ;
    <span class="dt">int</span> z ;
} ;

<span class="dt">int</span> main()
{
    S s { <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> } ;
    <span class="co">// s.x == 1</span>
    <span class="co">// s.y == 2</span>
    <span class="co">// s.z == 3</span>
}</code></pre></div>
<p>クラスの初期化で<code>{1,2,3}</code>と書くと、クラスの最初のデータメンバーが<code>1</code>で、次のデータメンバーが<code>2</code>で、その次のデータメンバーが<code>3</code>で、それぞれ初期化される。</p>
<p>クラスをコピーすると、データメンバーがそれぞれコピーされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { <span class="dt">int</span> a ; <span class="dt">double</span> b ; std::string c ; } ;

<span class="dt">int</span> main()
{
    S a{<span class="dv">123</span>, <span class="fl">1.23</span>, <span class="st">&quot;123&quot;</span>} ;
    <span class="co">// データメンバーがそれぞれコピーされる</span>
    S b = a ;
}</code></pre></div>
<h2 id="まとめた変数に関数を提供する">まとめた変数に関数を提供する</h2>
<p>分数を表現するプログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> num = <span class="dv">1</span> ;
    <span class="dt">int</span> denom = <span class="dv">2</span> ;

    <span class="co">// 出力</span>
    std::cout &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(denom) ;
}</code></pre></div>
<p>分子<code>num</code>と分母<code>denom</code>はクラスにまとめることができそうだ。そうすれば複数の分数を扱うのも楽になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;
} ;

<span class="dt">int</span> main()
{
    fractional x{<span class="dv">1</span>, <span class="dv">2</span>} ;

    <span class="co">// 出力</span>
    std::cout &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.denom) ;
}</code></pre></div>
<p>ところで、この出力を毎回書くのが面倒だ。こういう処理は関数にまとめたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> value( fractional &amp; x )
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(x.denom) ;
}

<span class="dt">int</span> main()
{
    fractional x{ <span class="dv">1</span>, <span class="dv">2</span> } ;
    std::cout &lt;&lt; value( x ) ;
}</code></pre></div>
<p>この関数<code>value</code>はクラス<code>fractional</code>専用だ。であれば、この関数をクラス自体に関連付けたい。そこでC++には<code>メンバー関数</code>という機能がある。</p>
<p><code>メンバー関数</code>はクラスの中で定義する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> member_function( <span class="dt">int</span> x )
    {
        <span class="kw">return</span> x ;
    }
} ;</code></pre></div>
<p><code>メンバー関数</code>はクラスの<code>データメンバー</code>を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

    <span class="dt">double</span> value()
    {
        <span class="kw">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(num) / <span class="kw">static_cast</span>&lt;<span class="dt">double</span>&gt;(denom) ;
    }
} ;</code></pre></div>
<p>メンバー関数を呼び出すには、クラスのオブジェクトに続いてドット文字を書き、メンバー関数名を書く。あとは通常の関数のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    fractional x{ <span class="dv">1</span>, <span class="dv">2</span> } ;
    std::cout &lt;&lt; x.value() ;
}</code></pre></div>
<p><code>メンバー関数</code>から使える<code>データメンバー</code>は、メンバー関数が呼ばれたクラスのオブジェクトのデータメンバーだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x ;
    <span class="dt">void</span> print()
    {
        std::cout &lt;&lt; x ;
    }
} ;

<span class="dt">int</span> main()
{
    S s1(<span class="dv">1</span>) ;
    s1.print() ; <span class="co">// 1</span>

    S s2(<span class="dv">2</span>) ;
    s2.print() ; <span class="co">// 2</span>
}</code></pre></div>
<p>この<code>print</code>を非メンバー関数として書くと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> print( S &amp; s )
{
    std::cout &lt;&lt; s.x ;
}</code></pre></div>
<p>メンバー関数は隠し引数としてクラスのオブジェクトを受け取っている関数だ。メンバー関数の呼び出しには、対応するクラスのオブジェクトが必要になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> f() { }
} ;

<span class="dt">int</span> main()
{
    f() ; <span class="co">// エラー</span>
    S s ;
    s.f() ; <span class="co">// OK</span>
}</code></pre></div>
<p><code>メンバー関数</code>はデータメンバーを変更することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> data ;
    <span class="dt">void</span> f()
    {
        data = <span class="dv">3</span> ;
    }
} ;</code></pre></div>
<p>先ほどの分数クラスに値を設定するための<code>メンバー関数</code>を追加してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

    <span class="dt">void</span> set( <span class="dt">int</span> num_ )
    {
        num = num_ ;
        denom = <span class="dv">1</span> ;
    }
    <span class="dt">void</span> set( <span class="dt">int</span> num_, <span class="dt">int</span> denom_ )
    {
        num = num_ ;
        denom = denom_ ;
    }
} ;

<span class="dt">int</span> main()
{
    fractional x ;


    x.set(<span class="dv">5</span>) ;
    <span class="co">// x.num == 5</span>
    <span class="co">// x.denom == 1</span>

    x.set( <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="co">// x.num == 2</span>
    <span class="co">// x.denom == 3</span>
}</code></pre></div>
<p>メンバー関数<code>set(num)</code>を呼び出すと、値が<span class="math inline">\(\frac{num}{1}\)</span>になる。メンバー関数<code>set(num, denom)</code>を呼び出すと、値が<span class="math inline">\(\frac{num}{denom}\)</span>になる。</p>
<p>ところで上のコードを見ると、<code>データメンバー</code>と引数の名前の衝突を避けるために、アンダースコアを使っている。</p>
<p><code>データメンバー</code>と引数の名前が衝突するとどうなるのか。確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x ;
    <span class="dt">void</span> f( <span class="dt">int</span> x )
    {
        x = x ;
    }
} ;

<span class="dt">int</span> main()
{
    S s{<span class="dv">0</span>} ;
    s.f(<span class="dv">1</span>) ;

    std::cout &lt;&lt; s.x ;
}</code></pre></div>
<p>結果は<code>0</code>だ。メンバー関数<code>f</code>の中の名前<code>x</code>は引数名の<code>x</code>だからだ。</p>
<p>すでに名前は<code>スコープ</code>に属するということは説明した。実はクラスも<code>スコープ</code>を持つ。上のコードは以下のようなスコープを持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間スコープ</span>
<span class="dt">int</span> x ;

<span class="kw">struct</span> S
{
    <span class="co">// クラススコープ</span>
    <span class="dt">int</span> x ;

    <span class="dt">void</span> f( <span class="dt">int</span> x )
    {
        <span class="co">// 関数のブロックスコープ</span>
        x = x ;
    }
} ;</code></pre></div>
<p>内側の<code>スコープ</code>は外側の<code>スコープ</code>の名前を隠す。そのため、クラススコープの<code>x</code>はグローバル名前空間スコープ<code>x</code>を隠す。関数のブロックスコープの<code>x</code>はクラススコープの<code>x</code>を隠す。</p>
<p>名前がどのスコープに属するかを明示的に指定することによって、隠された名前を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x ;

<span class="kw">struct</span> S
{
    <span class="dt">int</span> x ;

    <span class="dt">void</span> f( <span class="dt">int</span> x )
    {
        <span class="co">// 関数のブロックスコープのx</span>
        x = <span class="dv">0</span> ;
        <span class="co">// クラススコープのx</span>
        S::x = <span class="dv">0</span> ;
        <span class="co">// グローバル名前空間のスコープ</span>
        ::x = <span class="dv">0</span> ;
    }
} ;</code></pre></div>
<p>名前空間スコープを明示するために<code>namespace_name::name</code>を使うように、クラススコープを明示するために<code>class_name::name</code>を使うことができる。</p>
<p>これを使えば、分数クラスは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

    <span class="dt">void</span> set( <span class="dt">int</span> num, <span class="dt">int</span> denom )
    {
        fractional::num = num ;
        fractional::denom = denom ;
    }
}</code></pre></div>
<h1 id="より自然に振る舞うクラス">より自然に振る舞うクラス</h1>
<p>整数型の<code>int</code>について考えてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = a + a ;
    <span class="dt">int</span> c = a + b ;
}</code></pre></div>
<p>同様のことを、前章の分数クラスで書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;
} ;

fractional add( fractional &amp; l, fractional &amp; r )
{
    <span class="co">// 分母が同じなら</span>
    <span class="kw">if</span> ( l.denom == r.denom )
        <span class="co">// 単に分子を足す</span>
        <span class="kw">return</span> fractional{ l.num + r.num, l.denom } ;

    <span class="co">// 分母を合わせて分子を足す</span>
    <span class="kw">return</span> fractional{ l.num * r.denom + r.num * l.denom, l.denom * r.denom } ;
}

<span class="dt">int</span> main()
{
    fractional a{<span class="dv">1</span>,<span class="dv">1</span>} ;
    fractional b = add(a, a) ;
    fractional c = add(a, b) ;
}</code></pre></div>
<p>これは読みにくい。できれば以下のように書きたいところだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    fractional a = <span class="dv">1</span> ;
    fractional b = a + a ;
    fractional c = a + b ;
}</code></pre></div>
<p>C++ではクラスをこのように自然に振る舞わせることができる。</p>
<h2 id="より自然な初期化">より自然な初期化</h2>
<p><code>int</code>型は初期化にあたって値を設定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">0</span> ;
<span class="dt">int</span> b(<span class="dv">0</span>) ;
<span class="dt">int</span> c{<span class="dv">0</span>} ;</code></pre></div>
<p><code>クラス</code>でこのような初期化をするには、<code>コンストラクター</code>を書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

    <span class="co">// コンストラクター</span>
    fractional( <span class="dt">int</span> num )
        : num(num), denom(<span class="dv">1</span>)
    { }
} ;

<span class="dt">int</span> main()
{
    fractional a = <span class="dv">1</span> ;
    fractional b = <span class="dv">2</span> ;
}</code></pre></div>
<p><code>コンストラクター</code>は<code>クラス</code>の<code>特殊なメンバー関数</code>として定義する。<code>メンバー関数</code>としての<code>コンストラクター</code>は、名前がクラス名で、戻り値の型は記述しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> class_name
{
    <span class="co">// コンストラクター</span>
    class_name() { }
} ;</code></pre></div>
<p><code>コンストラクター</code>は<code>データメンバー</code>の初期化に特別な文法を持っている。関数の本体の前にコロンを書き、データメンバー名をそれぞれカンマで区切って初期化する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> class_name
{
    <span class="dt">int</span> data_member ;

    class_name( <span class="dt">int</span> value )
        : data_member(value)
    { }
    
} ;</code></pre></div>
<p>このとき、引数名とデータメンバー名が同じでもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> class_name
{
    <span class="dt">int</span> x ;
    class_name( <span class="dt">int</span> x )
        : x(x) { }
} ;</code></pre></div>
<p><code>x(x)</code>の最初の<code>x</code>は<code>class_name::x</code>として、次の<code>x</code>は引数名の<code>x</code>として認識される。そのためこのコードは期待どおりに動く。</p>
<p><code>コンストラクター</code>の特別なメンバー初期化を使わずに、<code>コンストラクター</code>の関数の本体で<code>データメンバー</code>を変更してもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> class_name
{
    <span class="dt">int</span> x ;
    class_name( <span class="dt">int</span> x )
    {
        class_name::x = x ;
    }
} ;</code></pre></div>
<p>この場合、<code>x</code>は関数の本体が実行される前に一度初期化され、その後、値を代入されるという挙動の違いがある。</p>
<p>コンストラクターはクラスが初期化されるときに実行される。例えば以下のプログラムを実行すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    S a(<span class="dv">1</span>) ;
    S b(<span class="dv">2</span>) ;
    S c(<span class="dv">3</span>) ;
}</code></pre></div>
<p>以下のように出力される。</p>
<pre><code>123</code></pre>
<p><code>コンストラクター</code>のついでに<code>デストラクター</code>も学んでおこう。<code>コンストラクター</code>はクラスのオブジェクトが初期化されるときに実行されるが、<code>デストラクター</code>はクラスのオブジェクトが破棄されるときに実行される。</p>
<p><code>デストラクター</code>の宣言は<code>コンストラクター</code>と似ている。違う点は、クラス名の前にチルダ文字を書くところだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// デストラクター</span>
    ~S()
    {
        <span class="co">// オブジェクトの破棄時に実行される</span>
    }
} ;</code></pre></div>
<p>関数のローカル変数は、ブロックスコープを抜ける際に破棄される。破棄は構築の逆順に行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a ;
    {
        <span class="dt">int</span> b ;
    <span class="co">// bが破棄される</span>
    }
    <span class="dt">int</span> c ;
<span class="co">// cが破棄される</span>
<span class="co">// aが破棄される</span>
}</code></pre></div>
<p>さっそく初期化時と終了時に標準出力をするクラスで確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> n ;
    S( <span class="dt">int</span> n )
        : n(n)
    {
        std::cout &lt;&lt; <span class="st">&quot;constructed: &quot;</span>s &lt;&lt; n &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }

    ~S()
    {
        std::cout &lt;&lt; <span class="st">&quot;destructed: &quot;</span>s &lt;&lt; n &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }
} ;</code></pre></div>
<p>このクラスを以下のように使うと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    S a(<span class="dv">1</span>) ;
    { S b(<span class="dv">2</span>) ; }
    S c(<span class="dv">3</span>) ;
}</code></pre></div>
<p>以下のように出力される。</p>
<pre><code>constructed: 1
constructed: 2
destructed: 2
constructed: 3
destructed: 3
destructed: 1</code></pre>
<p>この出力は以下のような意味だ。</p>
<ol style="list-style-type: decimal">
<li><code>a</code>が構築される</li>
<li><code>b</code>が構築される</li>
<li><code>b</code>が破棄される</li>
<li><code>c</code>が構築される</li>
<li><code>c</code>が破棄される</li>
<li><code>a</code>が破棄される</li>
</ol>
<p><code>b</code>はブロックスコープの終わりに達したので<code>a</code>の構築のあと、<code>c</code>の構築の前に破棄される。破棄は構築の逆順で行われるので、<code>a</code>よりも先に<code>c</code>が破棄される。</p>
<p><code>コンストラクター</code>と<code>デストラクター</code>は戻り値を返さないので、<code>return文</code>には値を書かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> class_name
{
    class_name()
    {
        <span class="kw">return</span> ;
    }
} ;</code></pre></div>
<p><code>コンストラクター</code>は複数の引数を取ることもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

    fractional( <span class="dt">int</span> num )
        : num(num), denom(<span class="dv">1</span>)
    { }

    fractional( <span class="dt">int</span> num, <span class="dt">int</span> denom )
        : num(num), denom(denom)
    { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// fractional(int)が呼ばれる</span>
    fractional a = <span class="dv">1</span> ;

    <span class="co">// fractional(int,int)が呼ばれる</span>
    fractional b(<span class="dv">1</span>, <span class="dv">2</span>) ;
    fractional c{<span class="dv">1</span>, <span class="dv">2</span>} ;
}</code></pre></div>
<p>複数の引数を取るコンストラクターを呼び出すには<code>&quot;=&quot;</code>は使えない。<code>&quot;()&quot;</code>か<code>&quot;{}&quot;</code>を使う必要がある。</p>
<p>上のコードを見ると、コンストラクターは引数の数以外にやっていることはほとんど同じだ。こういう場合、コンストラクターを1つにする方法がある。</p>
<p>実はコンストラクターに限らず、関数は<code>デフォルト実引数</code>を取ることができる。書き方は仮引数に<code>&quot;=&quot;</code>で値を書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> x = <span class="dv">0</span> )
{ }

<span class="dt">int</span> main()
{
    f() ;  <span class="co">// f(0)</span>
    f(<span class="dv">1</span>) ; <span class="co">// f(1)</span>
}</code></pre></div>
<p><code>デフォルト実引数</code>を指定した関数の仮引数に実引数を渡さない場合、<code>デフォルト実引数</code>で指定した値が渡される。</p>
<p>ところで、<code>仮引数</code>、<code>実引数</code>という聞き慣れない言葉が出てきた。これは関数の引数を区別するための言葉だ。<code>仮引数</code>は関数の宣言の引数。実引数は関数呼び出しのときに引数に渡す値のことを意味する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// xは仮引数</span>
<span class="dt">void</span> f( <span class="dt">int</span> x ) { }

<span class="dt">int</span> main()
{
    <span class="co">// 123は仮引数xに対する実引数</span>
    f( <span class="dv">123</span> ) ;
}</code></pre></div>
<p><code>デフォルト実引数</code>は関数の実引数の一部を省略できる。</p>
<p>ただし、<code>デフォルト実引数</code>を使った以後の仮引数には、すべて<code>デフォルト実引数</code>がなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK</span>
<span class="dt">void</span> f( <span class="dt">int</span> x, <span class="dt">int</span> y = <span class="dv">0</span>, <span class="dt">int</span> z = <span class="dv">0</span> ) { }
<span class="co">// エラー</span>
<span class="co">// zにデフォルト実引数がない</span>
<span class="dt">void</span> g( <span class="dt">int</span> x, <span class="dt">int</span> y = <span class="dv">0</span>, <span class="dt">int</span> z ) { }</code></pre></div>
<p><code>デフォルト実引数</code>で途中の引数だけ省略することはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> x = <span class="dv">0</span>, <span class="dt">int</span> y = <span class="dv">0</span>, <span class="dt">int</span> z = <span class="dv">0</span>) { }

<span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    f( <span class="dv">1</span>, , <span class="dv">2</span> ) ;
}</code></pre></div>
<p><code>デフォルト実引数</code>を使うと、コンストラクターを1つにできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

    fractional( <span class="dt">int</span> num, <span class="dt">int</span> denom = <span class="dv">1</span> )
        : num(num), denom(denom)
    { }
} ;

<span class="dt">int</span> main()
{
    fractional a = <span class="dv">1</span> ;
    fractional b(<span class="dv">1</span>,<span class="dv">2</span>) ;
    fractional c{<span class="dv">1</span>,<span class="dv">2</span>} ;
}</code></pre></div>
<p>コンストラクターの数を減らす方法はもう1つある。<code>デリゲートコンストラクター</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

    fractional( <span class="dt">int</span> num, <span class="dt">int</span> denom )
        : num(num), denom(denom)
    { }

    <span class="co">// デリゲートコンストラクター</span>
    fractional( <span class="dt">int</span> num )
        : fractional( num, <span class="dv">1</span> )
    { }
} ;</code></pre></div>
<p><code>デリゲートコンストラクター</code>は初期化処理を別のコンストラクターにデリゲート(丸投げ)する。丸投げ先のコンストラクターの初期化処理が終わり次第、デリゲートコンストラクターの関数の本体が実行される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    S()
        : S(<span class="dv">1</span>)
    {
        std::cout &lt;&lt; <span class="st">&quot;delegating constructor</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    }

    S( <span class="dt">int</span> n )
    {
        std::cout &lt;&lt; <span class="st">&quot;constructor</span><span class="ch">\n</span><span class="st">&quot;</span> ;
    }
} ;

<span class="dt">int</span> main()
{
    S s ;
}</code></pre></div>
<p>このプログラムを実行すると、以下のように出力される。</p>
<pre><code>constructor
delegating constructor</code></pre>
<p>まず<code>&quot;S()&quot;</code>が呼ばれるが、処理を<code>&quot;S(int)&quot;</code>にデリゲートする。<code>&quot;S(int)&quot;</code>の処理が終わり次第<code>&quot;S()&quot;</code>の関数の本体が実行される。そのためこのような出力になる。</p>
<p>コンストラクターを減らすのはよいが、減らしすぎても不便だ。以下の例を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> A { } ;
<span class="kw">struct</span> B { B(<span class="dt">int</span>) { } } ;

<span class="dt">int</span> main()
{
    A a ; <span class="co">// OK</span>
    B b ; <span class="co">// エラー</span>
}</code></pre></div>
<p>クラス<code>A</code>の変数は問題ないのに、クラス<code>B</code>の変数はエラーになる。これはクラス<code>B</code>には引数を取らないコンストラクターがないためだ。</p>
<p>クラス<code>B</code>に引数を必要としないコンストラクターを書くと、具体的に引数を渡さなくても初期化ができるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> B
{
    B() { }
    B( <span class="dt">int</span> x ) { }
} ;

<span class="dt">int</span> main()
{
    B b ; <span class="co">// OK</span>
}</code></pre></div>
<p>もしくは、デフォルト引数を使ってもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> B
{
    B( <span class="dt">int</span> x = <span class="dv">0</span> ) { }
} ;</code></pre></div>
<p>もちろん、ユーザーが値を指定しなければならないようなクラスは値を指定するべきだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 人間クラス</span>
<span class="co">// 必ず名前が必要</span>
<span class="kw">struct</span> person
{
    std::string name
    person( std::string name )
        : name(name) { }
} ;</code></pre></div>
<h2 id="自然な演算子">自然な演算子</h2>
<p><code>int</code>型は<code>+-*/</code>といった演算子を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">1</span> ;
    a + b ;
    a - b ;
    a * b ;
    a / b ;
}</code></pre></div>
<p>クラスも演算子を使った自然な記述ができる。クラスを演算子に対応させることを、<code>演算子のオーバーロード</code>という。</p>
<p>分数クラスの足し算を考えよう。</p>
<ul>
<li>分母が同じならば分子を足す</li>
<li>分母が異なるならば互いの分母を掛けて、分母をそろえて足す</li>
</ul>
<p>コードにすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> fractional
{
    <span class="dt">int</span> num ;
    <span class="dt">int</span> denom ;

<span class="co">// コンストラクターなど</span>
} ;

fractional add( fractional &amp; l, fractional &amp; r )
{
    <span class="co">// 分母が同じなら</span>
    <span class="kw">if</span> ( l.denom == r.denom )
        <span class="co">// 単に分子を足す</span>
        <span class="kw">return</span> fractional{ l.num + r.num, l.denom } ;

    <span class="co">// 分母を合わせて分子を足す</span>
    <span class="kw">return</span> fractional{ l.num * r.denom + r.num * l.denom, l.denom * r.denom } ;
}</code></pre></div>
<p>しかし、この関数<code>add</code>を使ったコードは以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    fractional a{<span class="dv">1</span>,<span class="dv">2</span>} ;
    fractional b{<span class="dv">1</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> c = add(a, b) ;
}</code></pre></div>
<p>これはわかりにくい。できれば、以下のように書きたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> c = a + b ;</code></pre></div>
<p>C++では演算子は関数として扱うことができる。演算子の名前は<code>operator op</code>で、例えば<code>+演算子</code>の名前は<code>operator +</code>になる。</p>
<p>関数<code>operator +</code>は引数を2つ取り、戻り値を返す関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">fractional <span class="kw">operator</span> +( fractional &amp; l, fractional &amp; r )
{
    <span class="co">// 分母が同じなら</span>
    <span class="kw">if</span> ( l.denom == r.denom )
        <span class="co">// 単に分子を足す</span>
        <span class="kw">return</span> fractional{ l.num + r.num, l.denom } ;
    <span class="kw">else</span>
        <span class="co">// 分母を合わせて分子を足す</span>
        <span class="kw">return</span> fractional{ l.num * r.denom + r.num * l.denom, l.denom * r.denom } ;
}</code></pre></div>
<p>このように<code>operator +</code>を書くと、以下のようなコードが書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> c = a + b ;</code></pre></div>
<p>同様に、引き算は<code>operator -</code>、掛け算は<code>operator *</code>、割り算は<code>operator /</code>だ。</p>
<p>以下に関数の宣言を示すので実際に分数の計算を実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">fractional <span class="kw">operator</span> -( fractional &amp; l, fractional &amp; r ) ;
fractional <span class="kw">operator</span> *( fractional &amp; l, fractional &amp; r ) ;
fractional <span class="kw">operator</span> /( fractional &amp; l, fractional &amp; r ) ;</code></pre></div>
<p>引き算は足し算とほぼ同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">fractional <span class="kw">operator</span> -( fractional &amp; l, fractional &amp; r )
{
    <span class="co">// 分母が同じ</span>
    <span class="kw">if</span> ( l.denom == r.denom )
        <span class="kw">return</span> fractional{ l.num - r.num, l.denom } ;
    <span class="kw">else</span>
        <span class="kw">return</span> fractional{ l.num * r.denom - r.num * l.denom, l.denom * r.denom } ;
}</code></pre></div>
<p>掛け算と割り算は楽だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">fractional <span class="kw">operator</span> *( fractional &amp; l, fractional &amp; r )
{
    <span class="kw">return</span> fractional{ l.num * r.num, l.denom * r.denom } ;
}

fractional <span class="kw">operator</span> /( fractional &amp; l, fractional &amp; r )
{
    <span class="kw">return</span> fractional{ l.num * r.denom, l.denom * r.num } ;
}</code></pre></div>
<h2 id="演算子のオーバーロード">演算子のオーバーロード</h2>
<h3 id="二項演算子">二項演算子</h3>
<p>C++にはさまざまな演算子があるが、多くが<code>二項演算子</code>と呼ばれる演算子だ。<code>二項演算子</code>は2つの引数を取り、値を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a + b ;
a - b ;
a * b ;
a / b ;</code></pre></div>
<p>このような演算子は<code>operator +</code>のように、キーワード<code>operator</code>に続いて演算子の文字を書くことで、関数名とする。あとは通常の関数と変わらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { } ;

S add( S a, S b ) ;
S <span class="kw">operator</span> + ( S a, S b ) ;</code></pre></div>
<p>戻り値の型は何でもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { } ;

<span class="dt">int</span> <span class="kw">operator</span> +( S, S ) { <span class="kw">return</span> <span class="dv">0</span> ; }
<span class="dt">void</span> <span class="kw">operator</span> -( S, S ) { }

<span class="dt">int</span> main()
{
    S s ;
    <span class="dt">int</span> x = s + s ;
    s - s ; <span class="co">// 戻り値はない</span>
}</code></pre></div>
<p>演算子としてではなく、関数と同じように呼び出すこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { } ;

<span class="co">// S f( S, S )のようなもの</span>
S <span class="kw">operator</span> + ( S, S ) { }

<span class="dt">int</span> main()
{
    S s ;
    <span class="co">// f(s,s)のようなもの</span>
    <span class="kw">operator</span> +(s,s) ;
}</code></pre></div>
<p><code>演算子のオーバーロード</code>では、少なくとも1つのユーザー定義された型がなければならない。つまり以下のような演算子のオーバーロードはできないということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">operator</span> +( <span class="dt">int</span>, <span class="dt">int</span> ) ;
<span class="dt">int</span> <span class="kw">operator</span> +( <span class="dt">int</span>, <span class="dt">double</span> ) ;</code></pre></div>
<p>二項演算子には<code>オペランド</code>と呼ばれる式を取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a + b ;</code></pre></div>
<p>この場合、二項演算子<code>operator +</code>には<code>a</code>, <code>b</code>という2つのオペランドがある。</p>
<p>二項演算子をオーバーロードする場合、最初の引数が最初のオペランド、次の引数が次のオペランドに対応する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X { } ;
<span class="kw">struct</span> Y { } ;

<span class="dt">void</span> <span class="kw">operator</span> +( X, Y ) { }

<span class="dt">int</span> main()
{
    X x ;
    Y y ;

    <span class="co">// OK</span>
    x + y ;

    <span class="co">// エラー</span>
    <span class="co">// operator +(Y,X)は存在しない</span>
    y + x ;
}</code></pre></div>
<p>そのため、上の例で<code>&quot;x+y&quot;</code>と<code>&quot;y+x&quot;</code>を両方使いたい場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> <span class="kw">operator</span> +(Y,X) { }</code></pre></div>
<p>も必要だ。</p>
<p>現実のコードでは、二項演算子のオーバーロードは以下のように書くことが多い。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { } ;

<span class="co">// 引数名はさまざま</span>
S <span class="kw">operator</span> +( S <span class="dt">const</span> &amp; left, S <span class="dt">const</span> &amp; right )
{

}</code></pre></div>
<p><code>const &amp;</code>という特別な書き方をする。<code>&amp;</code>についてはすでに学んだように、リファレンスだ。リファレンスを使うことによって値をコピーせずに効率的に使うことができる。</p>
<p><code>const</code>というのは値を変更しない変数を宣言する機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    x = <span class="dv">1</span> ; <span class="co">// OK</span>

    <span class="dt">int</span> <span class="dt">const</span> y = <span class="dv">0</span> ;
    y = <span class="dv">0</span> ; <span class="co">// エラー</span>
}</code></pre></div>
<p><code>const</code>を付けると値を変更できなくなる。</p>
<p>一般に<code>operator +</code>のような演算子は、オペランドに渡した変数を書き換えない処理をすることが期待されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">1</span> ;
    <span class="dt">int</span> b = <span class="dv">1</span> ;

    <span class="co">// a, bは書き換わらない</span>
    <span class="dt">int</span> c = a + b ;
}</code></pre></div>
<p>もちろん、<code>operator +</code>をオーバーロードして引数をリファレンスで取り、値を書き換えるような処理を書くこともできる。ただ、通常はそのような処理をすることはない。</p>
<p>しかし、処理の効率のためにリファレンスは使いたい。</p>
<p>そのようなときに、<code>const</code>かつリファレンスを使うと、効率的で値の変更ができないコードが書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> IntLike{ <span class="dt">int</span> data ;} ;

IntLike <span class="kw">operator</span> + ( IntLike <span class="dt">const</span> &amp; l, IntLike <span class="dt">const</span> &amp; r )
{
    <span class="kw">return</span> IntLike{ l.data + r.data }
}</code></pre></div>
<p><code>const</code>リファレンスの変数をうっかり書き換えてしまった場合、コンパイラーが検出してくれるので、バグを未然に発見することができる。</p>
<h3 id="単項演算子">単項演算子</h3>
<p><code>単項演算子</code>はオペランドを1つしか取らない演算子のことだ。</p>
<p><code>単項演算子</code>についてはまだ説明していないものも多い。例えば、<code>operator +</code>や<code>operator -</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    +x ; <span class="co">//  1: operator +</span>
    -x ; <span class="co">// -1: operator -</span>
}</code></pre></div>
<p><code>単項演算子</code>は引数を1つしか取らない関数として書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> IntLike{ <span class="dt">int</span> data ;} ;

IntLike <span class="kw">operator</span> +( IntLike <span class="dt">const</span> &amp; obj )
{
    <span class="kw">return</span> obj ;
}

IntLIke <span class="kw">operator</span> -( IntLike <span class="dt">const</span> &amp; obj )
{
    <span class="kw">return</span> IntLike{ -obj.data } ;
}</code></pre></div>
<h3 id="インクリメントデクリメント">インクリメント/デクリメント</h3>
<p><code>インクリメント演算子</code>と<code>デクリメント演算子</code>はやや変わっている。この演算子には、オペランドの前に書く前置演算子(<code>++i</code>)と、あとに書く後置演算子(<code>i++</code>)がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
    ++i ;
    i++ ;

    --i ;
    i-- ;
}</code></pre></div>
<p>前置演算子を評価すると、演算子を評価したあとの値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i = <span class="dv">0</span> ;
++i ;   <span class="co">// 1</span>
i ;     <span class="co">// 1</span></code></pre></div>
<p>一方、後置演算子を評価すると、演算子を評価する前の値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i = <span class="dv">0</span> ;
i++ ;   <span class="co">// 0</span>
i ;     <span class="co">// 1</span></code></pre></div>
<p>さらに前置演算子を評価した結果はリファレンスになるので代入やさらなる演算子の適用ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i = <span class="dv">0</span> ;
++i = <span class="dv">0</span> ;   <span class="co">// iは0</span>
++++i ;     <span class="co">// iは2</span>

i++ = <span class="dv">0</span> ;   <span class="co">// エラー</span>
i++++ ;     <span class="co">// エラー</span></code></pre></div>
<p>インクリメントとデクリメントの前置演算子は、単項演算子と同じ方法で書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> IntLike { <span class="dt">int</span> data ; } ;

IntLike &amp; <span class="kw">operator</span> ++( IntLike &amp; obj )
{
    ++obj.data ;
    <span class="kw">return</span> obj ;
}
IntLike &amp; <span class="kw">operator</span> --( IntLike &amp; obj )
{
    --obj.data ;
    <span class="kw">return</span> obj ;
}</code></pre></div>
<p>引数を変更するので<code>const</code>ではないリファレンスを使う。戻り値は引数をそのままリファレンスで返す。</p>
<p>もちろん、この実装はインクリメントとデクリメントの挙動を自然に再現したい場合の実装だ。以下のような挙動を実装することも可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { } ;

<span class="dt">void</span> <span class="kw">operator</span> ++( S <span class="dt">const</span> &amp; s )
{
    std::cout &lt;&lt; <span class="st">&quot;increment!</span><span class="ch">\n</span><span class="st">&quot;</span> ;
}

<span class="dt">int</span> main()
{

    S s ;
    ++s ;
}</code></pre></div>
<p>演算子のオーバーロードは演算子の文法で関数を呼べるという機能で、その呼び出した結果の関数が何をしようとも自由だからだ。</p>
<p>後置演算子は少し変わっている。以下が後置演算子の実装だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> IntLike { <span class="dt">int</span> data ; } ;

IntLike <span class="kw">operator</span> ++( IntLike &amp; obj, <span class="dt">int</span> )
{
    <span class="kw">auto</span> temp = obj ;
    ++obj.data ;
    <span class="kw">return</span> temp ;
}
IntLike <span class="kw">operator</span> --( IntLike &amp; obj, <span class="dt">int</span> )
{
    <span class="kw">auto</span> temp = obj ;
    --obj.data ;
    <span class="kw">return</span> temp ;
}</code></pre></div>
<p>後置演算子は2つ目の引数として<code>int</code>型を取る。この引数はダミーで前置演算子と後置演算子を区別する以外の意味はない。意味はないので引数名は省略している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { } ;

<span class="co">// 前置演算子</span>
<span class="dt">void</span> <span class="kw">operator</span> ++( S ) ;
<span class="co">// 後置演算子</span>
<span class="dt">void</span> <span class="kw">operator</span> ++( S, <span class="dt">int</span> ) ;</code></pre></div>
<p>後置演算子はオペランドである引数を変更するが、戻り値は変更する前の値だ。なので変更前の値をまずコピーしておき、そのコピーを返す。</p>
<h3 id="メンバー関数での演算子のオーバーロード">メンバー関数での演算子のオーバーロード</h3>
<p>実は演算子のオーバーロードはメンバー関数で書くことも可能だ。</p>
<p>例えば、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">S s ;
s + s ;</code></pre></div>
<p>を可能にするクラス<code>S</code>に対する<code>operator +</code>は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { }
S <span class="kw">operator</span> + ( S <span class="dt">const</span> &amp;, S <span class="dt">const</span> &amp; ) ;</code></pre></div>
<p>でも実装できるが、メンバー関数としても実装できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    S <span class="kw">operator</span> +( S <span class="dt">const</span> &amp; right )
    {
        <span class="kw">return</span> S{} ;
    }
} ;</code></pre></div>
<p>演算子のオーバーロードをメンバー関数で書く場合、最初のオペランドがメンバー関数の属するクラスのオブジェクト、2つ目のオペランドが1つ目の引数になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> IntLike
{
    <span class="dt">int</span> data ;

    IntLike <span class="kw">operator</span> +( IntLike <span class="dt">const</span> &amp; right )
    {
        <span class="kw">return</span> IntLike { data + right.data } ;
    }
} ;

<span class="dt">int</span> main()
{
    IntLike a(<span class="dv">1</span>) ;
    IntLike b(<span class="dv">2</span>) ;

    IntLike c = a + b ;
}</code></pre></div>
<p>この場合、メンバー関数は変数<code>a</code>に対して呼ばれ、変数<code>b</code>が<code>right</code>となる。</p>
<p>普通のメンバー関数のように呼ぶこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">IntLike c = a.<span class="kw">operator</span> +( b ) ;</code></pre></div>
<p>一見戸惑うかもしれないが、これは普通のメンバー関数呼び出しと何ら変わらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> plus( S <span class="dt">const</span> &amp; other ) { }
    <span class="dt">void</span> <span class="kw">operator</span> +( S <span class="dt">const</span> &amp; other ) { }
} ;

<span class="dt">int</span> main()
{
    S a ;
    S b ;

    <span class="co">// これはメンバー関数呼び出し</span>
    a.plus(b) ;
    <span class="co">// これもメンバー関数呼び出し</span>
    a.<span class="kw">operator</span> +(b) ;
    <span class="co">// 同じくメンバー関数呼び出し</span>
    a + b ;
}</code></pre></div>
<p>演算子のオーバーロードはフリー関数とメンバー関数のどちらで実装すればいいのだろうか。答えはどちらでもよい。ただし、ごく一部の演算子はメンバー関数でしか実装できない。</p>
<p>こうして、この章の冒頭にある演算子を使った自然な四則演算の記述が、自作のクラスでも可能になる。</p>
<h1 id="stdarray">std::array</h1>
<p><code>std::vector&lt;T&gt;</code>を覚えているだろうか。<code>T</code>型の値をいくつでも保持できるクラスだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を10個保持するクラス</span>
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10</span>) ;

    <span class="co">// 0番目の値を1に</span>
    v.at(<span class="dv">0</span>) = <span class="dv">1</span> ;

    <span class="co">// イテレーターを取る</span>
    <span class="kw">auto</span> i = std::begin(v) ;
}</code></pre></div>
<p>この章では、<code>vector</code>と似ているクラス、<code>std::array&lt;T, N&gt;</code>を学ぶ。<code>array</code>は<code>T</code>型の値を<code>N</code>個保持するクラスだ。</p>
<p>その使い方は一見<code>vector</code>と似ている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を10個保持するクラス</span>
    std::array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;

    <span class="co">// 0番目の値を1に</span>
    a.at(<span class="dv">0</span>) = <span class="dv">1</span> ;

    <span class="co">// イテレーターを取る</span>
    <span class="kw">auto</span> i = std::begin(a) ;
}</code></pre></div>
<p><code>vector</code>と違う点は、コンパイル時に要素数が固定されるということだ。</p>
<p><code>vector</code>は実行時に要素数を決めることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::size_t N{} ;
    std::cin &gt;&gt; N ;

    <span class="co">// 要素数N</span>
    std::vector&lt;<span class="dt">int</span>&gt; v(N) ;
}</code></pre></div>
<p>一方、<code>array</code>はコンパイル時に要素数を決める。標準入力から得た値は実行時のものなので、使うことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::size_t N{} ;
    std::cin &gt;&gt; N ;

    <span class="co">// エラー</span>
    std::array&lt; <span class="dt">int</span>, N &gt; a ;
}</code></pre></div>
<p><code>vector</code>は実行時に要素数を変更することができる。メンバー関数<code>push_back</code>は要素数を1増やす。メンバー関数<code>resize(sz)</code>は要素数を<code>sz</code>にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素数5</span>
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">5</span>) ;
    <span class="co">// 要素数6</span>
    v.push_back(<span class="dv">1</span>) ;
    <span class="co">// 要素数2</span>
    v.resize(<span class="dv">2</span>) ;
}</code></pre></div>
<p><code>array</code>は<code>push_back</code>も<code>resize</code>も提供していない。</p>
<p><code>vector</code>も<code>array</code>もメンバー関数<code>at(i)</code>で<code>i</code>番目の要素にアクセスできる。実は、<code>i</code>番目にアクセスする方法はほかにもある。<code>[i]</code>を使う方法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;

    <span class="co">// どちらも0番目の要素に1を代入</span>
    a.at(<span class="dv">0</span>) = <span class="dv">1</span> ;
    a[<span class="dv">0</span>] = <span class="dv">1</span> ;

    <span class="co">// どちらも0番目の要素を標準出力</span>
    std::cout &lt;&lt; a.at(<span class="dv">0</span>) ;
    std::cout &lt;&lt; a[<span class="dv">0</span>] ;
}</code></pre></div>
<p><code>at(i)</code>と<code>[i]</code>の違いは、要素の範囲外にアクセスしたときの挙動だ。<code>at(i)</code>はエラー処理が行われる。<code>[i]</code>は何が起こるかわからない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 10個の要素を持つ</span>
    <span class="co">// 0番目から9番目までが妥当な範囲</span>
    std::array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;

    <span class="co">// エラー処理が行われる</span>
    <span class="co">// プログラムは終了する</span>
    a.at(<span class="dv">10</span>) = <span class="dv">0</span> ;
    <span class="co">// 何が起こるかわからない</span>
    a[<span class="dv">10</span>] = <span class="dv">0</span> ;
}</code></pre></div>
<p>この理由は、<code>[i]</code>は要素数が妥当な範囲かどうかを確認する処理を行っていないためだ。その分余計な処理が発生しないが、間違えたときに何が起こるかわからないという危険性がある。通常は<code>at(i)</code>を使うべきだ。</p>
<p>実はこの<code>[i]</code>は<code>operator []</code>というれっきとした演算子だ。演算子のオーバーロードもできる。例えば以下は任意個の要素を持ち、常にゼロを返す<code>array</code>のように振る舞う意味のないクラスだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 常にゼロを返すクラス</span>
<span class="co">// 何を書き込んでもゼロを返す</span>
<span class="kw">struct</span> null_array
{
    <span class="dt">int</span> dummy ;
    <span class="co">// 引数は無視</span>
    <span class="dt">int</span> &amp; <span class="kw">operator</span> [] ( std::size_t )
    {
        dummy = <span class="dv">0</span> ;
        <span class="kw">return</span> dummy ;
    }
} ;

<span class="dt">int</span> main()
{
    null_array a ;

    <span class="co">// 0</span>
    std::cout &lt;&lt; a[<span class="dv">0</span>] ;
    <span class="co">// 0</span>
    std::cout &lt;&lt; a[<span class="dv">999</span>] ;

    a[<span class="dv">100</span>] = <span class="dv">0</span> ;
    <span class="co">// 0</span>
    std::cout &lt;&lt; a[<span class="dv">100</span>] ;
}</code></pre></div>
<p>なぜ<code>vector</code>という実行時に要素数を設定でき実行時に要素数を変更できる便利なクラスがありながら、<code>array</code>のようなコンパイル時に要素数が決め打ちで要素数の変更もできないようなクラスもあるのだろうか。その理由は<code>array</code>と<code>vector</code>はパフォーマンスの特性が異なるからだ。<code>vector</code>はストレージ(メモリー)の動的確保をしている。ストレージの動的確保は実行時の要素数を変更できるのだが、そのために予測不可能な非決定的なパフォーマンス特性を持つ。<code>array</code>はストレージの動的確保を行わない。この結果実行時に要素数を変更することはできないが、予測可能で決定的なパフォーマンス特性を持つ。</p>
<p>その他の<code>array</code>の使い方は、<code>vector</code>とほぼ同じだ。</p>
<p>さて、これから<code>array</code>を実装していこう。実装を通じて読者はC++のクラスとその他の機能を学んでいくことになる。</p>
<h1 id="プログラマーの三大美徳">プログラマーの三大美徳</h1>
<p>プログラミング言語Perlの作者、Larry Wallは著書『プログラミングPerl』の初版で以下のように宣言した。</p>
<blockquote>
<p>読者はプログラマーの三大美徳である、怠惰、短気、傲慢を会得すべきである。</p>
</blockquote>
<p>第2版の巻末の用語集では、以下のような定義が与えらた。</p>
<dl>
<dt>怠惰</dt>
<dd><p>プログラマーは労力を削減するための労力を惜しまないこと。怠惰のために書いたプログラムは他人にも便利であり、そしてドキュメントを書くことにより自ら他人の質問に答えずに済むようにすること。これがプログラマーの第一の美徳である。これが本書の書かれた理由である。</p>
</dd>
<dt>短気</dt>
<dd><p>コンピューターが怠惰であるときにプログラマーが感ずる怒り。短気によって書かれたプログラムは、単に労力を削減するばかりではなく、事前に解決しておく。少なくとも、すでに解決済みのように振る舞う。これがプログラマーの第二の美徳である。</p>
</dd>
<dt>傲慢</dt>
<dd><p>ゼウスも罰したもう過剰なまでの驕り。他人がそしりを入れられぬほどのプログラムを書く推進剤。これがプログラマーの第三の美徳である。</p>
</dd>
</dl>
<p>これから学ぶ<code>array</code>を実装するためのC++の機能を学ぶときに、このプログラマーの三大美徳のことを頭に入れておこう。</p>
<h1 id="配列">配列</h1>
<h2 id="ナイーブなarray実装">ナイーブなarray実装</h2>
<p><code>std::array</code>を実装してみよう。すでにクラスを作る方法については学んだ。</p>
<p><code>std::array&lt;T,N&gt;</code>は<code>T</code>型の要素を<code>N</code>個保持するクラスだ。この<code>&lt;T,N&gt;</code>についてはまだ学んでいないので、今回は<code>int</code>型を3個確保する。いままでに学んだ要素だけで実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_int_3
{
    <span class="dt">int</span> m0 ;
    <span class="dt">int</span> m1 ;
    <span class="dt">int</span> m2 ;
} ;</code></pre></div>
<p>そして<code>operator []</code>を実装しよう。引数が<code>0</code>なら<code>m0</code>を、<code>1</code>なら<code>m1</code>を、<code>2</code>なら<code>m2</code>を返す。それ以外の値の場合、プログラムを強制的に終了させる標準ライブラリ、<code>std::abort</code>を呼び出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_int_3
{
    <span class="dt">int</span> m0 ; <span class="dt">int</span> m1 ; <span class="dt">int</span> m2 ;

    <span class="dt">int</span> &amp; <span class="kw">operator</span> []( std::size_t i )
    {
        <span class="kw">switch</span>(i)
        {
            <span class="kw">case</span> <span class="dv">0</span> :
                <span class="kw">return</span> m0 ;
            <span class="kw">case</span> <span class="dv">1</span> :
                <span class="kw">return</span> m1 ;
            <span class="kw">case</span> <span class="dv">2</span> :
                <span class="kw">return</span> m2 ;
            <span class="kw">default</span> :
                <span class="co">// 間違った引数</span>
                <span class="co">// 強制終了</span>
                std::abort() ;
        }
    }
} ;</code></pre></div>
<p>これは動く。では要素数を10個に増やした<code>array_int_10</code>はどうなるだろうか。要素数100個はどう書くのだろうか。この方法で実装するとソースコードが膨大になり、ソースコードを出力するソースコードを書かなければならなくなる。これは怠惰で短気なプログラマーには耐えられない作業だ。</p>
<h2 id="配列-1">配列</h2>
<p><code>std::array</code>を実装するには、<code>配列(array)</code>を使う。</p>
<p><code>int</code>型の要素数10の配列<code>a</code>は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a[<span class="dv">10</span>] ;</code></pre></div>
<p><code>double</code>型の要素数5の配列<code>b</code>は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> b[<span class="dv">5</span>] ;</code></pre></div>
<p><code>配列</code>の要素数は<code>std::array&lt;T,N&gt;</code>の<code>N</code>と同じようにコンパイル時定数でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::size_t size ;
    std::cin &gt;&gt; size ;
    <span class="co">// エラー</span>
    <span class="dt">int</span> a[size] ;
}</code></pre></div>
<p>配列は<code>={1,2,3}</code>のように初期化できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
<span class="dt">double</span> b[<span class="dv">3</span>] = {<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span> } ;</code></pre></div>
<p>配列の要素にアクセスするには<code>operator []</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// 4</span>
    std::cout &lt;&lt; a[<span class="dv">3</span>] ;

    a[<span class="dv">2</span>] = <span class="dv">0</span> ;
    <span class="co">// {1,2,0,4,5}</span>
}</code></pre></div>
<p>配列にはメンバー関数はない。<code>at(i)</code>や<code>size()</code>のような便利なメンバー関数はない。</p>
<p>配列のサイズは<code>sizeof</code>で取得できる。配列のサイズは配列の要素の型のサイズ掛けることの要素数のサイズになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> s){ std::cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;
    <span class="dt">int</span> a[<span class="dv">5</span>] ;
    print( <span class="kw">sizeof</span>(a) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">5</span> ) ;

    <span class="dt">double</span> b [<span class="dv">5</span>] ;
    print( <span class="kw">sizeof</span>(b) ) ;
    print( <span class="kw">sizeof</span>(<span class="dt">double</span>) * <span class="dv">5</span> ) ;
}</code></pre></div>
<p><code>sizeof</code>は型やオブジェクトのバイト数を取得するのに対し、<code>vector</code>や<code>array</code>のメンバー関数<code>size()</code>は要素数を取得する。この違いに注意すること。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> print = [](<span class="kw">auto</span> s){ std::cout &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ; } ;
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a ;

    <span class="co">// aのバイト数</span>
    print( <span class="kw">sizeof</span>(a) ) ;
    <span class="co">// 要素数: 5</span>
    print( a.size() ) ;

}</code></pre></div>
<p><code>配列</code>はとても低級な機能だ。その実装はある型を連続してストレージ上に並べたものになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a[<span class="dv">5</span>] ;</code></pre></div>
<p>のような配列があり、<code>int</code>型が4バイトの環境では、20バイトのストレージが確保され、その先頭の4バイトが最初の0番目の要素に、その次の4バイトが1番目の要素になる。最後の4番目の要素は最後の4バイトになる。</p>
<pre><code>配列のストレージ上のイメージ図

□1つが1バイトのストレージ
     1番目のint
    |--|
□□□□□□□□□□□□□□□□□□□□
|--|            |--|
 0番目のint       4番目のint</code></pre>
<p>fig/fig22-01.png</p>
<p>配列にはメンバー関数がない上、コピーもできない。<code>std::array</code>はコピーできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// エラー、コピーできない</span>
    <span class="dt">int</span> b[<span class="dv">5</span>] = a ;

    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// OK、コピーできる</span>
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; d = c ;
}</code></pre></div>
<p><code>配列</code>は低級で使いにくいので、<code>std::array</code>という配列をラップした高級なライブラリが標準で用意されている。</p>
<p>さて、配列の使い方は覚えたので、さっそく<code>std::array_int_10</code>を実装してみよう。</p>
<p>まずクラスのデータメンバーとして配列を宣言する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_int_10
{
    <span class="dt">int</span> storage[<span class="dv">10</span>] ;
} ;</code></pre></div>
<p>配列はコピーできないが、クラスのデータメンバーとして宣言した配列は、クラスのコピーの際に、その対応する順番の要素がそれぞれコピーされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_int_3 { <span class="dt">int</span> storage [<span class="dv">3</span>] ; } ;

<span class="dt">int</span> main()
{
    array_int_3 a = { <span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span> } ;

    array_int_3 b = a ;
    <span class="co">// b.storage[0] == a.storage[0] </span>
    <span class="co">// b.storage[1] == a.storage[1] </span>
    <span class="co">// b.storage[2] == a.storage[2] </span>
}</code></pre></div>
<p>これはあたかも以下のように書いたかのように動く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_int_3
{
    <span class="dt">int</span> storage[<span class="dv">3</span>] ;

    array_int_3( array_int_3 <span class="dt">const</span> &amp; other )
    {
        std::copy(
            std::begin(other.storage), std::end(other.storage),
            std::begin(storage)
        ) ;

    }
}</code></pre></div>
<p><code>operator []</code>も実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_int_10
{
    <span class="dt">int</span> storage[<span class="dv">10</span>] ;

    <span class="dt">int</span> &amp; <span class="kw">operator</span> [] ( std::size_t i )
    {
        <span class="kw">return</span> storage[i] ;
    }
} ;

<span class="dt">int</span> main()
{
    array_int_10 a = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>} ;
    a[<span class="dv">3</span>] = <span class="dv">0</span> ;
    std::cout &lt;&lt; a[<span class="dv">6</span>] ;
}</code></pre></div>
<p><code>std::array</code>にはまださまざまなメンバーがある。1つずつ順番に学んでいこう。</p>
<h1 id="テンプレート">テンプレート</h1>
<h2 id="問題点">問題点</h2>
<p>前章で我々は<code>'std::array'</code>のようなものを実装した。C++を何も知らなかった我々がとうとうクールなキッズは皆やっているというクラスを書くことができた。素晴らしい成果だ。</p>
<p>しかし、我々の書いた<code>'array_int_10'</code>は<code>'std::array'</code>とは異なる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 標準ライブラリ</span>
std::array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; a ;
<span class="co">// 我々のクラス</span>
array_int_10 a ;</code></pre></div>
<p>もし要素数を20個にしたければ<code>array_int_20</code>を新たに書かなければならない。すると<code>array_int_1</code>とか<code>array_int_10000</code>のようなクラスを無数に書かなければならないのだろうか。要素の型を<code>double</code>にしたければ<code>array_double_10</code>が必要だ。</p>
<p>しかし、そのようなクラスはほとんど同じような退屈な記述の羅列になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_int_1
{
    <span class="dt">int</span> storage[<span class="dv">1</span>] ;
    <span class="dt">int</span> &amp; <span class="kw">operator</span> []( std::size_t i )
    { <span class="kw">return</span> storage[i] ; }
} ;

<span class="co">// array_int_2, array_int_3, ...</span>

<span class="kw">struct</span> array_int_10000
{
    <span class="dt">int</span> storage[<span class="dv">10000</span>] ;
    <span class="dt">int</span> &amp; <span class="kw">operator</span> []( std::size_t i )
    { <span class="kw">return</span> storage[i] ; }
} ;

<span class="kw">struct</span> array_double_1
{
    <span class="dt">double</span> storage[<span class="dv">1</span>] ;
    <span class="dt">double</span> &amp; <span class="kw">operator</span> []( std::size_t i )
    { <span class="kw">return</span> storage[i] ; }
} ;

<span class="co">// array_double_2, array_double_3, ...</span></code></pre></div>
<p>これは怠惰で短気なプログラマーには耐えられない作業だ。C++にはこのような退屈なコードを書かなくても済む機能がある。しかしその前に、引数について考えてみよう。</p>
<h2 id="関数の引数">関数の引数</h2>
<p>1を2倍する関数を考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> one_twice()
{
    <span class="kw">return</span> <span class="dv">1</span> * <span class="dv">2</span> ;
}</code></pre></div>
<p>上出来だ。では2を2倍する関数を考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> two_twice()
{
    <span class="kw">return</span> <span class="dv">2</span> * <span class="dv">2</span> ;
}</code></pre></div>
<p>素晴らしい。では3を2倍する関数、4を2倍する関数...と考えていこう。</p>
<p>ここまで読んで<code>three_twice</code>や<code>four_twice</code>を思い浮かべた読者にはプログラマーに備わるべき美徳が欠けている。怠惰で短気で傲慢なプログラマーはそんなコードを書かない。引数を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> twice( <span class="dt">int</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}</code></pre></div>
<p>具体的な値を2倍する関数を値の数だけ書くのは面倒だ。具体的な値は定めず、引数で外部から受け取る。そして引数を2倍して返す。引数は汎用的なコードを任意の値に対して対応させるための機能だ。</p>
<h2 id="関数のテンプレート引数">関数のテンプレート引数</h2>
<p><code>twice</code>をさまざまな型に対応させるにはどうすればいいだろう。例えば<code>int</code>型と<code>double</code>型に対応させてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> twice( <span class="dt">int</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="dt">double</span> twice( <span class="dt">double</span> n )
{
    <span class="kw">return</span> n * <span class="fl">2.0</span> ;
}</code></pre></div>
<p>整数型には<code>int</code>のほかにも、<code>short</code>, <code>long</code>, <code>long long</code>といった型がある。浮動小数点数型には<code>float</code>と<code>long double</code>もある。ということは以下のような関数も必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">short</span> twice( <span class="dt">short</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="dt">long</span> twice( <span class="dt">long</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="dt">long</span> <span class="dt">long</span> twice( <span class="dt">long</span> <span class="dt">long</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="dt">float</span> twice( <span class="dt">float</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="dt">long</span> <span class="dt">double</span> twice( <span class="dt">long</span> <span class="dt">double</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}</code></pre></div>
<p>ところで、整数型には符号付きと符号なしの2種類があるということは覚えているだろうか？</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> twice( <span class="dt">int</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="dt">unsigned</span> <span class="dt">int</span> twice( <span class="dt">unsigned</span> <span class="dt">int</span> n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="co">// short, long, long longに対しても同様</span></code></pre></div>
<p>C++ではユーザーが整数型のように振る舞うクラスを作ることができる。整数型を複数使って巨大な整数を表現できるクラスも作ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 多倍長整数クラス</span>
<span class="co">// unsigned long longが256個分の整数の実装</span>
<span class="kw">struct</span> bigint
{
    <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> storage[<span class="dv">256</span>] ;
} ;

bigint <span class="kw">operator</span> * ( bigint <span class="dt">const</span> &amp; right, <span class="dt">int</span> )
{
    <span class="kw">return</span> <span class="co">// 実装</span>
}</code></pre></div>
<p>このクラスに対応するには当然、以下のように書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">bigint twice( bigint n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}</code></pre></div>
<p>そろそろ怠惰と短気を美徳とするプログラマー読者は耐えられなくなってきただろう。これまでのコードは、単にある型<code>T</code>に対して、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">T twice( T n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}</code></pre></div>
<p>と書いているだけだ。型<code>T</code>がコピーと<code>operator *(T, int)</code>に対応していればいい。型<code>T</code>の具体的な型について知る必要はない。</p>
<p>関数が具体的な値を知らなくても引数によって汎用的なコードを書けるように、具体的な型を知らなくても汎用的なコードを書けるようになりたい。その怠惰と短気に答えるのが<code>テンプレート</code>だ。</p>
<h2 id="テンプレート-1">テンプレート</h2>
<p>通常の関数が値を引数に取ることができるように、テンプレートは型を引数に取ることができる。</p>
<p>テンプレートは以下のように宣言する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
    宣言 </code></pre></div>
<p>テンプレートを関数に使う<code>関数テンプレート</code>は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T twice( T n )
{
    <span class="kw">return</span> n * <span class="dv">2</span> ;
}

<span class="dt">int</span> main()
{
    twice( <span class="dv">123</span> ) ;  <span class="co">// int</span>
    twice( <span class="fl">1.23</span> ) ; <span class="co">// double </span>
}</code></pre></div>
<p><code>template &lt; typename T &gt;</code>は型<code>T</code>を<code>テンプレート引数</code>に取る。テンプレートを使った宣言の中では、<code>T</code>が型として扱える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T f( T n )
{
    T x = n ;
}</code></pre></div>
<p><code>関数</code>が<code>引数</code>を取るように、<code>テンプレート</code>は<code>テンプレート引数</code>を取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// テンプレートはテンプレート引数template_parameterを取る</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> template_parameter &gt;
<span class="co">// 関数は引数function_parameterを取る</span>
<span class="co">// 引数の型はtemplate_parameter</span>
<span class="dt">void</span> f( template_parameter function_parameter )
{
}</code></pre></div>
<p><code>テンプレート</code>が「使われる」ときに、<code>テンプレート引数</code>に対する具体的な型が決定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T <span class="dt">const</span> &amp; x )
{
    std::cout &lt;&lt; x ;
}

<span class="dt">int</span> main()
{
    <span class="co">// Tはint</span>
    f( <span class="dv">0</span> ) ;
    <span class="co">// Tはdouble</span>
    f( <span class="fl">0.0</span> ) ;
    <span class="co">// Tはstd::string</span>
    f( <span class="st">&quot;hello&quot;</span>s ) ;
}</code></pre></div>
<p><code>テンプレート</code>を使うときに自動で<code>テンプレート引数</code>を推定してくれるが、<code>&lt;T&gt;</code>を使うことで明示的に<code>テンプレート引数</code>を<code>T</code>型に指定することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T <span class="dt">const</span> &amp; x )
{
    std::cout &lt;&lt; x ;
}

<span class="dt">int</span> main()
{
    <span class="co">// Tはint</span>
    f&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;

    <span class="co">// Tはdouble</span>
    <span class="co">// int型0からdouble型0.0への変換が行われる</span>
    f&lt;<span class="dt">double</span>&gt;( <span class="dv">0</span> ) ;
}</code></pre></div>
<p><code>テンプレート引数</code>は型ではなく整数型の値を渡すこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="dt">int</span> N &gt;
<span class="dt">void</span> f()
{
    std::cout &lt;&lt; N ;
}

<span class="dt">int</span> main()
{
    <span class="co">// Nは0</span>
    f&lt;<span class="dv">0</span>&gt;() ;
    <span class="co">// Nは123</span>
    f&lt;<span class="dv">123</span>&gt;() ;
}</code></pre></div>
<p>ただし、<code>テンプレート引数</code>はコンパイル時にすべてが決定される。なので<code>テンプレート引数</code>に渡せる値はコンパイル時に決定できるものでなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="dt">int</span> N &gt;
<span class="dt">void</span> f() { }

<span class="dt">int</span> main()
{
    <span class="co">// OK</span>
    f&lt;<span class="dv">1+1</span>&gt;() ;

    <span class="dt">int</span> x{} ;
    std::cin &gt;&gt; x ;
    <span class="co">// エラー</span>
    f&lt;x&gt;() ;
}</code></pre></div>
<p><code>テンプレート引数</code>がコンパイル時に決定されるということは、配列のサイズのようなコンパイル時に決定されなければならない場面でも使えるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; std::size_t N &gt;
<span class="dt">void</span> f()
{
    <span class="dt">int</span> buffer[N] ;
}

<span class="dt">int</span> main()
{
    <span class="co">// 配列bufferのサイズは10</span>
    f&lt;<span class="dv">10</span>&gt;() ;
    <span class="co">// サイズは12</span>
    f&lt;<span class="dv">12</span>&gt;() ;
}</code></pre></div>
<p>テンプレートを使ったコードは、与えられた<code>テンプレート引数</code>に対して妥当でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> vec &gt;
<span class="dt">void</span> f( vec &amp; v )
{
    v.push_back(<span class="dv">0</span>) ;
}

<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// OK</span>
    f( a ) ;
    std::vector&lt;<span class="dt">double</span>&gt; b ;
    <span class="co">// OK</span>
    <span class="co">// intからdoubleへの変換</span>
    f( b ) ;

    std::vector&lt;std::string&gt; c ;
    <span class="co">// エラー</span>
    <span class="co">// intからstd::stringに変換はできない</span>
    f( c ) ;

    <span class="co">// エラー</span>
    <span class="co">// int型はメンバー関数push_backを持っていない</span>
    f( <span class="dv">0</span> ) ;
}</code></pre></div>
<h2 id="クラステンプレート">クラステンプレート</h2>
<p><code>テンプレート</code>は<code>クラス</code>にも使える。<code>関数テンプレート</code>は<code>関数</code>の前に<code>テンプレート</code>を書くように、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="co">// テンプレート</span>
<span class="dt">void</span> f( ) ; <span class="co">// 関数</span></code></pre></div>
<p><code>クラステンプレート</code>は<code>クラス</code>の前に<code>テンプレート</code>を書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="co">// テンプレート</span>
<span class="kw">struct</span> S { } ; <span class="co">// クラス</span></code></pre></div>
<p>関数の中でテンプレート引数名を型や値として使えるように、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, T N &gt;
T value()
{
    <span class="kw">return</span> N :
}

<span class="dt">int</span> main()
{
    value&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt;() ;
    value&lt;<span class="dt">short</span>, <span class="dv">1</span>&gt;() ;
}</code></pre></div>
<p>クラスの中でもテンプレート引数名を型や値として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    T storage[N] ;

    T &amp; <span class="kw">operator</span> [] ( std::size_t i )
    {
        <span class="kw">return</span> storage[i] ;
    }
} ;</code></pre></div>
<p>なんと、もう<code>'std::array'</code>が完成してしまった。</p>
<h1 id="arrayをさらに実装">arrayをさらに実装</h1>
<p><code>'std::array'</code>をもっと実装していこう。前章では以下のような簡単な<code>'array'</code>を実装した。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    T storage[N] ;

    T &amp; <span class="kw">operator</span> [] ( std::size_t i )
    {
        <span class="kw">return</span> storage[i] ;
    }
} ;</code></pre></div>
<p>実は<code>std::array</code>はこのように書かれていない。この章では、<code>'array'</code>の実装を<code>'std::array'</code>に近づけていく。</p>
<h2 id="ネストされた型名">ネストされた型名</h2>
<p>エイリアス宣言を覚えているだろうか。型名に別名を付ける機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> number = <span class="dt">int</span> ;
    number x = <span class="dv">123</span> ;
}</code></pre></div>
<p>エイリアス宣言はクラスの中でも使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="kw">using</span> number = <span class="dt">int</span> ;
    number data ;
} ;

<span class="dt">int</span> main()
{
    S s{<span class="dv">123</span>} ;

    S::number x = s.data ;
}</code></pre></div>
<p>クラスの中で宣言されたエイリアス宣言による型名を、<code>ネストされた型名</code>という。<code>std::array</code>ではテンプレート引数を直接使う代わりに、<code>ネストされた型名</code>が使われている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="kw">using</span> value_type = T ;
    <span class="kw">using</span> reference = T &amp; ;

    <span class="kw">using</span> size_type = std::size_t ;

    value_type storage[N] ;

    reference <span class="kw">operator</span> [] ( size_type i )
    {
        <span class="kw">return</span> storage[i] ;
    }
} ;</code></pre></div>
<p>こうすると、<code>T &amp;</code>のようなわかりにくい型ではなく<code>reference</code>のようにわかりやすい名前を使える。さらに、クラス外部から使うこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> array_type = std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; ;
    array_type a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    array_type::value_type x = <span class="dv">0</span> ;
    array_type::reference ref = a[<span class="dv">0</span>] ;
}</code></pre></div>
<p>もちろんこれは<code>auto</code>で書くこともできるが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> array_type = std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; ;
    array_type a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="kw">auto</span> x = <span class="dv">0</span> ;
    <span class="kw">auto</span> ref = a[<span class="dv">0</span>] ;
}</code></pre></div>
<p>信じられないことに昔のC++には<code>auto</code>がなかったのだ。その他、さまざまな利点があるのだが、そのすべてを理解するには、まだ読者のC++力が足りない。</p>
<h2 id="要素数の取得-size">要素数の取得: size()</h2>
<p><code>std::array&lt;T,N&gt;</code>には<code>size()</code>というメンバー関数がある。要素数を返す。</p>
<p><code>array</code>の場合、<code>N</code>を返せばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a ;
    a.size() ; <span class="co">// 5</span>

    std::array&lt;<span class="dt">int</span>, <span class="dv">10</span>&gt; b ;
    b.size() ; <span class="co">// 10</span>
}</code></pre></div>
<p>さっそく実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="kw">using</span> size_type = std::size_t ;

    size_type size() ;
    <span class="co">// ... 省略</span>
} ;</code></pre></div>
<p>ここでは<code>size</code>の宣言だけをしている。</p>
<p>関数は宣言と定義が分割できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 関数の宣言</span>
<span class="dt">void</span> f() ;
<span class="co">// 関数の定義</span>
<span class="dt">void</span> f() { }</code></pre></div>
<p>メンバー関数も宣言と定義が分割できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// クラスの宣言</span>
<span class="kw">struct</span> S
{
    <span class="co">// メンバー関数の宣言</span>
    <span class="dt">void</span> f() ;
} ;

<span class="co">// メンバー関数の定義</span>
<span class="dt">void</span> S::f() { }</code></pre></div>
<p>メンバー関数の定義をクラス宣言の外で書くには、関数名がどのクラスに属するのかを指定しなければならない。これには<code>クラス名::</code>を使う。この場合、<code>S::f</code>だ。</p>
<h2 id="メンバー関数のconst修飾">メンバー関数のconst修飾</h2>
<p><code>const</code>を付けた変数は値を変更できなくなることはすでに学んだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    x = <span class="dv">1</span> ;
    <span class="dt">int</span> <span class="dt">const</span> cx = <span class="dv">0</span> ;
    cx = <span class="dv">0</span> ; <span class="co">// エラー</span>
}</code></pre></div>
<p><code>const</code>は変更する必要のない場面でうっかり変更することを防いでくれるとても便利な機能だ。<code>'array'</code>は大きいので関数の引数として渡すときにコピーするのは非効率的だ。なのでコピーを防ぐリファレンスで渡したい。</p>
<p><code>std::array&lt;T,N&gt;</code>を受け取って要素をすべて出力する関数を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="dt">void</span> print( Array &amp; c )
{
    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != c.size() ; ++i )
    {
        std::cout &lt;&lt; c[i] ;
    }
}

<span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    print( a ) ;
}</code></pre></div>
<p>関数<code>print</code>がテンプレートなのは任意の<code>T</code>と<code>N</code>を使った<code>std::array&lt;T,N&gt;</code>を受け取れるようにするためだ。</p>
<p>関数のリファレンスを引数として渡すと、関数の中で変更できてしまう。しかし、上の例のような関数<code>print</code>では、引数を書き換える必要はない。この関数を使う人間も、引数を勝手に書き換えないことを期待している。この場合、<code>const</code>を付けることで値の変更を防ぐことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">void</span> print( Container <span class="dt">const</span> &amp; c )
{
    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != c.size() ; ++i )
    {
        std::cout &lt;&lt; c[i] ;
    }
}</code></pre></div>
<p>ではさっそくこれまで実装してきた自作の<code>array</code>クラスを使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    print( a ) ; <span class="co">// エラー</span>
}</code></pre></div>
<p>なぜかエラーになってしまう。</p>
<p>この理由はメンバー関数を呼び出しているからだ。</p>
<p>クラスのメンバー関数はデータメンバーを変更できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data {} ;
    <span class="dt">void</span> f()
    {
        ++data ;
    }
} ;

<span class="dt">int</span> main()
{
    S s ;
    s.f() ; <span class="co">// s.dataを変更</span>
}</code></pre></div>
<p>ということは、<code>const S</code>はメンバー関数<code>f()</code>を呼び出すことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    S s ;
    S <span class="dt">const</span> &amp; ref = s ;

    ++ref.data ;  <span class="co">// エラー</span>
    ref.f() ;     <span class="co">// エラー</span>
}</code></pre></div>
<p>ではメンバー関数<code>f()</code>がデータメンバーを変更しなければいいのだろうか。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data {} ;
    <span class="dt">void</span> f()
    {
        <span class="co">// 何もしない</span>
    }
} ;

<span class="dt">int</span> main()
{
    S <span class="dt">const</span> s ;
    s.f() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>まだエラーになる。この理由を完全に理解するためには、まだ説明していない<code>ポインター</code>という機能について学ばなければならない。ポインターの説明はこの次の章で行うとして、いまはさしあたり必要な機能である<code>メンバー関数のconst修飾</code>を説明する。</p>
<p><code>const</code>を付けていないメンバー関数を<code>const</code>なクラスのオブジェクトから呼び出せない理由は、メンバー関数がデータメンバーを変更しない保証がないからだ。その保証を付けるのが<code>メンバー関数のconst修飾</code>だ。</p>
<p>メンバー関数は関数の引数のあと、関数の本体の前に<code>const</code>を書くことで<code>const</code>修飾できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> f() <span class="dt">const</span>
    { }
} ;

<span class="dt">int</span> main()
{
    S s ;
    s.f() ; <span class="co">// OK</span>

    S <span class="dt">const</span> cs ;
    cs.f() ; <span class="co">// OK</span>

}</code></pre></div>
<p><code>const</code>修飾されたメンバー関数は<code>const</code>なクラスのオブジェクトからでも呼び出すことができる。</p>
<p><code>const</code>修飾されたメンバー関数と、<code>const</code>修飾されていないメンバー関数が両方ある場合、クラスのオブジェクトの<code>const</code>の有無によって適切なメンバー関数が呼び出される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> f() { }        <span class="co">// 1</span>
    <span class="dt">void</span> f() <span class="dt">const</span> { }  <span class="co">// 2</span>
} ;

<span class="dt">int</span> main()
{
    S s ;
    s.f() ;     <span class="co">// 1</span>

    S <span class="dt">const</span> cs ;
    cs.f() ;    <span class="co">// 2</span>
}</code></pre></div>
<p>そしてもう1つ重要なのは、<code>const</code>修飾されたメンバー関数がデータメンバーへのリファレンスを返す場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data {} ;
    <span class="co">// データメンバーへのリファレンスを返す</span>
    <span class="dt">int</span> &amp; get()
    {
        <span class="kw">return</span> data ;
    }
} ;</code></pre></div>
<p><code>const</code>修飾されたメンバー関数は自分のデータメンバーを変更できないので、データメンバーの値を変更可能なリファレンスを返すことはできない。そのため以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data {} ;
    <span class="dt">int</span> &amp; get()
    {
        <span class="kw">return</span> data ;
    }

    <span class="co">// const版</span>
    <span class="co">// constリファレンスを返すので変更不可</span>
    <span class="dt">int</span> <span class="dt">const</span> &amp; get() <span class="dt">const</span>
    {
        <span class="kw">return</span> data ;
    }
} ;</code></pre></div>
<p>自作の<code>'array'</code>の<code>operator []</code>を<code>const</code>に対応させよう。<code>'std::array'</code>は<code>const</code>なリファレンスを<code>const_reference</code>というネストされた型名にしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    T storage[N] ;

    <span class="kw">using</span> reference = T &amp; ;
    <span class="kw">using</span> const_reference = T <span class="dt">const</span> &amp; ;

    <span class="co">// 非const版</span>
    reference <span class="kw">operator</span> [] ( std::size_t i )
    {
        <span class="kw">return</span> storage[i] ;
    }
    <span class="co">// const版</span>
    const_reference <span class="kw">operator</span> [] ( std::size_t i ) <span class="dt">const</span>
    {
        <span class="kw">return</span> storage[i] ;
    }
} ;</code></pre></div>
<p>これで<code>const array</code>にも対応できるようになった。</p>
<h2 id="先頭と末尾の要素frontback">先頭と末尾の要素：front/back</h2>
<p>メンバー関数<code>front</code>は最初の要素へのリファレンスを返す。<code>back</code>は最後の要素へのリファレンスを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="dt">int</span> &amp; f = a.front() ;   <span class="co">// 1</span>
    <span class="dt">int</span> &amp; b = a.back() ;    <span class="co">// 5</span>
}</code></pre></div>
<p><code>front/back</code>には<code>reference</code>を返すバージョンと<code>const_reference</code>を返すバージョンがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    T storage[N] ;

    <span class="kw">using</span> reference = T &amp; ;
    <span class="kw">using</span> const_reference = T <span class="dt">const</span> &amp; ;

    reference front()
    { <span class="kw">return</span> storage[<span class="dv">0</span>] ; }
    const_reference front() <span class="dt">const</span>
    { <span class="kw">return</span> storage[<span class="dv">0</span>] ; }

    reference back()
    { <span class="kw">return</span> storage[N<span class="dv">-1</span>] ; }
    const_reference back() <span class="dt">const</span>
    { <span class="kw">return</span> storage[N<span class="dv">-1</span>] ; }

} ;</code></pre></div>
<h2 id="全要素に値を代入-fill">全要素に値を代入: fill</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    a.fill(<span class="dv">0</span>) ;
    <span class="co">// aは{0,0,0,0,0}</span>
}</code></pre></div>
<p>すでにアルゴリズムで実装した<code>'std::fill'</code>と同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    T storage[N] ;

    <span class="dt">void</span> fill( T <span class="dt">const</span> &amp; u )
    {
        <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != N ; ++i )
        {
            storage[i] = u ;
        }
    }

} ;</code></pre></div>
<p>しかし、せっかく<code>std::fill</code>があるのだから以下のように書きたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> fill( T <span class="dt">const</span> &amp; u )
{
    std::fill( begin(), end(), u ) ;
}</code></pre></div>
<p>残念ながらこれは動かない。なぜならば、自作の<code>array</code>はまだ<code>begin()/end()</code>と<code>イテレーター</code>に対応していないからだ。これは次の章で学ぶ。</p>
<h1 id="arrayのイテレーター">arrayのイテレーター</h1>
<h2 id="イテレーターの中身">イテレーターの中身</h2>
<p>自作の<code>array</code>をイテレーターに対応させる前に、まず<code>'std::array'</code>のイテレーターについてひと通り調べよう。</p>
<p>イテレーターは<code>std::begin/std::end</code>で取得する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> first = std::begin(a) ;
    <span class="kw">auto</span> last = std::end(a) ;
}</code></pre></div>
<p><code>std::begin/std::end</code>は何をしているのか見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std
{
    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;
    <span class="kw">auto</span> begin( C &amp; c )
    { <span class="kw">return</span> c.begin() ; }

    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;
    <span class="kw">auto</span> begin( C <span class="dt">const</span> &amp; c )
    { <span class="kw">return</span> c.begin() ; }

    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;
    <span class="kw">auto</span> end( C &amp; c )
    { <span class="kw">return</span> c.end() ;}

    <span class="kw">template</span> &lt; <span class="kw">typename</span> C &gt;
    <span class="kw">auto</span> end( C <span class="dt">const</span> &amp; c )
    { <span class="kw">return</span> c.end() ;}
}</code></pre></div>
<p>なんと、単に引数に対してメンバー関数<code>begin/end</code>を呼び出してその結果を返しているだけだ。</p>
<p>さっそく確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> iter = a.begin() ;
    std::cout &lt;&lt; *iter ; <span class="co">// 1</span>
    ++iter ;
    std::cout &lt;&lt; *iter ; <span class="co">// 2</span>
}</code></pre></div>
<p>確かに動くようだ。</p>
<p>すると自作の<code>array</code>でイテレーターに対応する方法がわかってきた。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// イテレーターを表現するクラス</span>
<span class="kw">struct</span> array_iterator { } ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="co">// イテレーター型</span>
    <span class="kw">using</span> iterator = array_iterator ;

    <span class="co">// イテレーターを返すメンバー関数</span>
    iterator begin() ;
    iterator end() ;

    <span class="co">// その他のメンバー</span>
} ;</code></pre></div>
<p>イテレーターに対応するには、おおむねこのような実装になるとみていいだろう。おそらく細かい部分で微調整が必要になるが、いまはこれでよしとしよう。ではイテレーターが具体的に何をするかを見ていこう。</p>
<p>すでに学んだように、イテレーターは<code>operator *</code>で参照する要素の値を取得できる。また書き込みもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> iter = a.begin() ;
    <span class="dt">int</span> x = *iter ; <span class="co">// 1</span>
    *iter = <span class="dv">0</span> ;
    <span class="co">// aは{0,2,3,4,5}</span>
}</code></pre></div>
<p>問題を簡単にするために、これまでに作った自作の<code>array</code>で最初の要素にアクセスする方法を考えてみよう</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
<span class="dt">int</span> x = a[<span class="dv">0</span>] ; <span class="co">// 1</span>
a[<span class="dv">0</span>] = <span class="dv">0</span> ;</code></pre></div>
<p>このことから考えると、先頭要素を指すイテレーターは<code>operator *</code>をオーバーロードして先頭要素をリファレンスで返せばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> array_iterator_int_5_begin
{
    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; &amp; a ;

    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt;::reference <span class="kw">operator</span> *()
    {
        <span class="kw">return</span> a[<span class="dv">0</span>] ;
    }
} ;</code></pre></div>
<p>しかし、この実装では<code>array&lt;int,5&gt;</code>にしか対応できない。<code>array&lt;int,7&gt;</code>や<code>array&lt;double, 10&gt;</code>には対応できない。なぜなら、<code>array</code>に渡すテンプレート実引数が違うと、別の型になるからだ。</p>
<p><code>array_iterator</code>でさまざまな<code>array</code>を扱うにはどうすればいいのか。テンプレートを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_iterator_begin
{
    Array &amp; a ;

    array_iterator_begin( Array &amp; a )
        : a( a ) { }

    <span class="co">// エラー</span>
    <span class="co">// Array::referenceは型ではない</span>
    Array::reference <span class="kw">operator</span> *()
    {
        <span class="kw">return</span> a[<span class="dv">0</span>] ;
    }
} ;</code></pre></div>
<p>しかしなぜかエラーだとコンパイラーに怒られる。この理由を説明するのはとても難しい。気になる読者は近所のC++グルに教えを請おう。ここでは答えだけを教える。</p>
<p><code>T::Y</code>において、<code>T</code>がテンプレート引数に依存する名前で、<code>Y</code>がネストされた型名の場合、<code>typename</code>キーワードを付けなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="co">// typenameが必要</span>
    <span class="kw">typename</span> T::Y x = <span class="dv">0</span> ;
}

<span class="kw">struct</span> S
{
    <span class="kw">using</span> Y = <span class="dt">int</span> ;
} ;

<span class="dt">int</span> main()
{
    <span class="co">// T = S</span>
    <span class="co">// T::Y = int</span>
    f&lt;S&gt;() ;
}</code></pre></div>
<p>わかっただろうか。わからなくても無理はない。この問題を理解するにはテンプレートに対する深い理解が必要だ。理解した暁には読者はC++グルとして崇拝されているだろう。</p>
<p>さしあたって必要なのは<code>Array::reference</code>の前に<code>typename</code>キーワードを付けることだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typename</span> Array::reference
array_iterator_begin::<span class="kw">operator</span> * ()
{
    <span class="kw">return</span> a[<span class="dv">0</span>] ;
}</code></pre></div>
<p>どうやら最初の要素を読み書きするイテレーターはできたようだ。<code>array</code>側も実装して試してみよう。</p>
<p><code>array</code>側の実装にはまだ現時点では完全に理解できない黒魔術が必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    T storage[N] ;
    <span class="co">// 黒魔術1: array</span>
    <span class="kw">using</span> iterator = array_iterator_begin&lt;array&gt; ;
    iterator begin()
    <span class="co">// 黒魔術2: *this</span>
    <span class="co">// 黒魔術3: iterator(*this)</span>
    { <span class="kw">return</span> iterator(*<span class="kw">this</span>) ; }
} ;</code></pre></div>
<p>黒魔術1は<code>array_iterator_begin&lt;array&gt;</code>の中にある。この<code>array</code>は<code>array&lt;T,N&gt;</code>と同じ意味になる。つまり全体としては、<code>array_iterator_begin&lt;array&lt;T,N&gt;&gt;</code>と書いたものと同じだ。クラステンプレートの中でクラス名を使うと、テンプレート実引数をそれぞれ指定したものと同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> A, <span class="kw">typename</span> B, <span class="kw">typename</span> C &gt;
<span class="kw">struct</span> S
{
    <span class="dt">void</span> f()
    {
        <span class="co">// S&lt;A,B,C&gt;と同じ</span>
        S s ;
    }
} ;</code></pre></div>
<p>黒魔術2は<code>*this</code>だ。<code>*this</code>はメンバー関数を呼んだクラスのオブジェクトへのリファレンスだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data {} ;
    <span class="co">// *thisはメンバー関数が呼ばれたSのオブジェクト</span>
    S &amp; THIS() { <span class="kw">return</span> *<span class="kw">this</span> ; } 
} ;

<span class="dt">int</span> main()
{
    S s1 ;
    
    s1.THIS().data = <span class="dv">123</span> ;
    <span class="co">// 123</span>
    std::cout &lt;&lt; s1.data ;

    S s2 ;
    s2.THIS().data = <span class="dv">456</span> ;
    <span class="co">// 456</span>
    std::cout &lt;&lt; s2.data ;
}</code></pre></div>
<p>クラスのメンバー関数は対応するクラスのオブジェクトに対して呼ばれる。本来ならばクラスのオブジェクトをリファレンスで取るような形になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data {} ;
    <span class="dt">void</span> set(<span class="dt">int</span> x)
    {
        data = x ;
    }
} ;

<span class="dt">int</span> main()
{
    S object ;
    object.set(<span class="dv">42</span>) ;
}</code></pre></div>
<p>というコードは、ほぼ同じことを以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data {} ;
} ;

<span class="dt">void</span> set( S &amp; object, <span class="dt">int</span> x )
{
    object.data = x ;
}

<span class="dt">int</span> main()
{
    S ojbect ;
    set( object, <span class="dv">42</span> ) ;
}</code></pre></div>
<p>クラスの意義は変数と関数を結び付けることだ。このように変数と関数がバラバラではわかりにくいので、メンバー関数という形で<code>object.set(...)</code>のようにわかりやすく呼び出せるし、その際クラス<code>S</code>のオブジェクトは変数<code>object</code>であることが文法上わかるので、わざわざ関数の実引数の形で書くことは省略できるようにしている。</p>
<p>メンバー関数の中で、メンバー関数が呼ばれているクラスのオブジェクトを参照する方法が<code>*this</code>だ。</p>
<p>しかしなぜ<code>*this</code>なのか。もっとわかりやすいキーワードでもいいのではないか。なぜ<code>*</code>が付いているのか。この謎を理解するためには、これまたポインターの理解が必要になるが、それは次の章で学ぶ。</p>
<p>黒魔術3は<code>iterator(*this)</code>だ。クラス名に<code>()</code>や<code>{}</code>を続けると、コンストラクターを呼び出した結果のクラスの値を得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    S() { }
    S( <span class="dt">int</span> ) { }
    S( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    S a = S() ;
    S b = S(<span class="dv">0</span>) ;
    S c = S(<span class="dv">1</span>,<span class="dv">2</span>) ;

    S d = S{} ;
    S e = S{<span class="dv">0</span>} ;
    S f = S{<span class="dv">1</span>,<span class="dv">2</span>} ;
}</code></pre></div>
<p>黒魔術の解説が長くなった。本題に戻ろう。</p>
<p><code>array_iterator_begin</code>は先頭の要素しか扱えない。イテレーターで先頭以外の別の要素を扱う方法を思い出してみよう。</p>
<p>イテレーターは<code>operator ++</code>で次の要素を参照する。<code>operator --</code>で前の要素を参照する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> iter = a.begin() ;
    *iter ; <span class="co">// 1</span>
    ++iter ;
    *iter ; <span class="co">// 2</span>
    --iter ;
    *iter ; <span class="co">// 1</span>
}</code></pre></div>
<p>この<code>operator ++</code>と<code>operator --</code>はイテレーターへのリファレンスを返す。なぜならば、以下のように書けるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">*++iter ;
*++++iter ;</code></pre></div>
<p>以上を踏まえて、自作の<code>array_iterator</code>の宣言を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_iterator
{
    Array &amp; a ;

    array_iterator( Array &amp; a )
        : a( a ) { }

    <span class="co">// 次の要素を指す</span>
    array_iterator &amp; <span class="kw">operator</span> ++() ;
    <span class="co">// 前の要素を指す</span>
    array_iterator &amp; <span class="kw">operator</span> --() ;
    
    <span class="co">// いま参照している要素へのリファレンスを返す</span>
    Array::reference <span class="kw">operator</span> *() ;
} ;</code></pre></div>
<p>イテレーターの実装で先頭の要素を参照するのは<code>a[0]</code>だった。その次の要素を参照するには<code>a[1]</code>だ。その次の要素は<code>a[2]</code>となり、その前の要素は<code>a[1]</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

<span class="kw">auto</span> iter = a.begin() ; <span class="co">// 最初の要素</span>
*iter ; <span class="co">// 1</span>
++iter ; <span class="co">// 次の要素</span>
*iter ; <span class="co">// 2</span>
--iter ; <span class="co">// 前の要素、つまり最初の要素</span>
*iter ; <span class="co">// 1</span></code></pre></div>
<p>では最初の要素の前の要素や、最後の要素の次の要素を参照しようとするとどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> first = a.begin() ;
--first ;
*first ; <span class="co">// 最初の前の要素？</span>
<span class="kw">auto</span> last = a.end() ;
++last ; <span class="co">//</span>
*last ; <span class="co">// 最後の次の要素？</span></code></pre></div>
<p>これはエラーになる。このようなエラーを起こさないように務めるのはユーザーの責任で、イテレーター実装者の責任ではない。しかし、必要であればイテレーターの実装者はこのようなエラーを防ぐような実装もできる。それはあとの章で学ぶ。ここでは、こういう場合が起こることは考えなくてもよいとしよう。</p>
<p>これを考えていくと、イテレーターの実装をどうすればいいのかがわかってくる。</p>
<p><code>array_iterator</code>の<code>operator *</code>は<code>a[i]</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typename</span> Array::reference array_iterator::<span class="kw">operator</span> *()
{
    <span class="kw">return</span> a[i] ;
}</code></pre></div>
<p><code>i</code>は<code>std::size_t</code>型のデータメンバーで、イテレーターが現在参照している<code>i</code>番目の要素を記録している。</p>
<p>ということは先ほどの<code>array_iterator</code>の宣言にはデータメンバー<code>i</code>を追加する修正が必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_iterator
{
    Array &amp; a ;
    std::size_t i ;

    array_iterator( Array &amp; a, std::size_t i )
        : a( a ), i(i) { }

    <span class="co">// いま参照している要素へのリファレンスを返す</span>
    Array::reference <span class="kw">operator</span> *()
    {
        <span class="kw">return</span> a[i] ;
    }

    <span class="co">// その他のメンバー</span>
} ;</code></pre></div>
<p>そして、<code>array</code>側にも新しい<code>array_iterator</code>への対応が必要になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="kw">using</span> iterator = array_iterator&lt;array&gt; ;

    <span class="co">// 先頭要素のイテレーター</span>
    iterator begin()
    {
        <span class="kw">return</span> array_iterator( *<span class="kw">this</span>, <span class="dv">0</span> ) ;
    }

    <span class="co">// 最後の次の要素へのイテレーター</span>
    iterator end()
    {
        <span class="kw">return</span> array_iterator( *<span class="kw">this</span>, N ) ;
    }
} ;</code></pre></div>
<p>何度も書くように、インデックスは<code>0</code>から始まる。要素が<span class="math inline">\(N\)</span>個ある場合、最初の要素は0番目で、最後の要素は<span class="math inline">\(N-1\)</span>番目だ。</p>
<p>インクリメント演算子<code>operator ++</code>にも対応しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">array_iterator &amp; array_iterator::<span class="kw">operator</span> ++()
{
    ++i ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<p>これで最低限のイテレーターは実装できた。さっそく試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> iter = a.begin() ;

    std::cout &lt;&lt; *iter ; <span class="co">// 1</span>
    ++iter ;
    std::cout &lt;&lt; *iter ; <span class="co">// 2</span>
}</code></pre></div>
<p>実は<code>operator ++</code>は2種類ある。前置演算子と後置演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;

    <span class="co">// 前置</span>
    std::cout &lt;&lt; ++i ;  <span class="co">// 1</span>
    <span class="co">// 後置</span>
    std::cout &lt;&lt; i++ ;  <span class="co">// 1</span>
    std::cout &lt;&lt; i ;    <span class="co">// 2</span>
}</code></pre></div>
<p><code>int</code>型では、前置<code>operator ++</code>はオペランドの値を1加算した値にする。後置<code>operator ++</code>はオペランドの値を1加算するが、式を評価した結果は前のオペランドの値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">++i ; <span class="co">// i+1</span>
i++ ; <span class="co">// i、ただしiの値はi+1</span></code></pre></div>
<p>後置<code>operator ++</code>のオーバーロードは以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> IntLike
{
    <span class="dt">int</span> data {} ;

    <span class="co">// 前置</span>
    IntLike &amp; <span class="kw">operator</span> ++()
    {
        ++data ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
    <span class="co">// 後置</span>
    IntLike <span class="kw">operator</span> ++(<span class="dt">int</span>)
    {
        IntLike copy = *<span class="kw">this</span> ;
        ++*<span class="kw">this</span> ;
        <span class="kw">return</span> copy ;
    }
} ;</code></pre></div>
<p>このコードは慣れないとわかりにくいが、妥当な理由のあるコードだ。順番に説明しよう。</p>
<p>まず演算子オーバーロードの宣言だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 前置</span>
IntLike &amp; <span class="kw">operator</span> ++() ;
<span class="co">// 後置</span>
IntLike <span class="kw">operator</span> ++(<span class="dt">int</span>) ;</code></pre></div>
<p>前置はリファレンスを返す。前置演算子の適用結果はさらに変更できるようにするためだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i { } ;

    ++++i ;
}</code></pre></div>
<p>もちろん、リファレンスを返さない実装は可能だ。そもそも何も値を返さない<code>void</code>を使うことも可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> <span class="kw">operator</span> ++() { }
} ;</code></pre></div>
<p>ただし、その場合<code>operator ++</code>に対して通常期待されるコードが書けなくなる。理由がない限り演算子の自然な挙動を目指すべきだ。</p>
<p>前置と後置は区別できる必要がある。C++はその区別の方法として、<code>int</code>型の仮引数を1つ取る<code>operator ++</code>を後置演算子だと認識する文法を採用した。この<code>int</code>型の実引数は前置と後置を区別するためだけのもので、値に意味はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> <span class="kw">operator</span> ++( <span class="dt">int</span> x )
    {
        <span class="co">// 値に意味はない。</span>
        std::cout &lt;&lt; x ;
    }
} ;

<span class="dt">int</span> main()
{
    S s ;
    <span class="co">// 演算子としての使用</span>
    s++ ;
    <span class="co">// メンバー関数としての使用</span>
    s.<span class="kw">operator</span>++(<span class="dv">123</span>) ;
}</code></pre></div>
<p>値に意味はないが、演算子として使用した場合、値は<code>0</code>になるというどうでもいい仕様がある。メンバー関数として使用すると好きな値を渡せるというこれまたどうでもいい仕様がある。テストには出ないので覚える必要はない。</p>
<p>前置は自然な挙動のためにリファレンスを返すが、後置はリファレンスではなくコピーした値を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 後置</span>
IntLike IntLike::<span class="kw">operator</span> ++(<span class="dt">int</span>)
{
    <span class="co">// コピーを作る</span>
    IntLike copy = *<span class="kw">this</span> ;
    <span class="co">// 演算子が呼ばれたオブジェクトをインクリメントする</span>
    <span class="co">// 前置インクリメント演算子を呼んでいる</span>
    ++*<span class="kw">this</span> ;
    <span class="co">// 値が変更されていないコピーを返す</span>
    <span class="kw">return</span> copy ;
}</code></pre></div>
<p>このように実装すると、後置として自然な挙動が実装できる。</p>
<p><code>++*this</code>は後置インクリメント演算子が呼ばれたオブジェクトに対して前置インクリメント演算子を使用している。わかりにくければ前置インクリメントと同じ処理を書いてもいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">IntLike IntLike::<span class="kw">operator</span> ++(<span class="dt">int</span>)
{
    IntLike copy = *<span class="kw">this</span> ;
    <span class="co">// 同じ処理</span>
    ++data ;
    <span class="kw">return</span> copy ;
}</code></pre></div>
<p><code>IntLike</code>のように簡単な処理であればこれでもいいが、もっと複雑な何行もある処理の場合は、すでに実装した前置インクリメントを呼び出した方が楽だ。コードの重複を省けるのでインクリメントの処理を変更するときに、2箇所に同じ変更をしなくても済む。</p>
<p>以上を踏まえて、<code>array_iterator</code>に後置インクリメント演算子を実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">array_iterator array_iterator::<span class="kw">operator</span> ++(<span class="dt">int</span>)
{
    array_iterator copy = *<span class="kw">this</span> ;
    ++*<span class="kw">this</span> ;
    <span class="kw">return</span> copy ;
}</code></pre></div>
<p>デクリメント演算子<code>operator --</code>の実装はインクリメント演算子<code>operator ++</code>と同じだ。ただ処理がインクリメントではなくデクリメントになっているだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 前置</span>
array_iterator &amp; array_iterator::<span class="kw">operator</span> --()
{
    -- i ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}
<span class="co">// 後置</span>
array_iterator array_iterator::<span class="kw">operator</span> --(<span class="dt">int</span>)
{
    array_iterator copy = *<span class="kw">this</span> ;
    --*<span class="kw">this</span> ;
    <span class="kw">return</span> copy ;
}</code></pre></div>
<p>ここまでくればイテレーターに必要な操作はあと1つ。比較だ。</p>
<p>イテレーターは同じ要素を指している場合に等しい。つまり、オペレーター<code>a</code>と<code>b</code>が同じ要素を指しているならば、<code>a == b</code>は<code>true</code>で<code>a != b</code>は<code>false</code>だ。違う要素を指しているならば<code>a == b</code>は<code>false</code>で<code>a != b</code>は<code>true</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> a = a.begin() ;
    <span class="kw">auto</span> b = a.begin() ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = (a == b) ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b2 = (a != b) ;
    ++a ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b3 = (a == b) ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b4 = (a != b) ;
}</code></pre></div>
<p>イテレーターは比較ができるので、イテレーターが終端に到達するまでループを回すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

            <span class="co">// 変数宣言</span>
    <span class="kw">for</span> (   <span class="kw">auto</span> iter = std::begin(a),
            last = std::end(a) ;
            <span class="co">// 終了条件</span>
            iter != last ;
            <span class="co">// ループごとの処理</span>
            ++iter )
    {
        std::cout &lt;&lt; *iter ;
    }
}</code></pre></div>
<p>イテレーターは比較ができるので、各種アルゴリズムに渡すことができる。</p>
<p><code>array_iterator</code>の比較は、単にデータメンバー<code>i</code>の比較でよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> array_iterator::<span class="kw">operator</span> ==( array_iterator <span class="dt">const</span> &amp; right )
{
    <span class="kw">return</span> i == right.i ;
}
<span class="dt">bool</span> array_iterator::<span class="kw">operator</span> !=( array_iterator <span class="dt">const</span> &amp; right )
{
    <span class="kw">return</span> i != right.i ;
}</code></pre></div>
<p>これで自作の<code>array</code>と<code>array_iterator</code>はアルゴリズムに渡せるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    std::for_each( std::begin(a), std::end(a),
        [](<span class="kw">auto</span> x){ std::cout &lt;&lt; x ; } ) ;
}</code></pre></div>
<h2 id="残りのイテレーターの実装">残りのイテレーターの実装</h2>
<p><code>std::array</code>や<code>std::vector</code>のイテレーターはとても柔軟にできている。</p>
<p>例えばイテレーター<code>i</code>の参照する要素を3つ進めたい場合を考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">++i ; <span class="co">// 1</span>
++i ; <span class="co">// 2</span>
++i ; <span class="co">// 3</span></code></pre></div>
<p>これは非効率的だ。もっと効率的なイテレーターの進め方として、<code>operator +=</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i += <span class="dv">3</span> ;</code></pre></div>
<p><code>i += n</code>はイテレーター<code>i</code>を<code>n</code>回進める。</p>
<p><code>operator +</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> j = i + <span class="dv">3</span> ;</code></pre></div>
<p>イテレーター<code>j</code>の値はイテレーター<code>i</code>を3つ進めた値になる。イテレーター<code>i</code>の値は変わらない。</p>
<p>実装は簡単だ。データメンバー<code>i</code>に対して同じ計算をする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_iterator
{
    Array &amp; a ;
    std::size_t i ;

    array_iterator &amp; <span class="kw">operator</span> += ( std::size_t n )
    {
        i += n ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }

    array_iterator <span class="kw">operator</span> + ( std::size_t n ) <span class="dt">const</span>
    {
        <span class="kw">auto</span> copy = *<span class="kw">this</span> ;
        copy += n ;
        <span class="kw">return</span> copy ;
    }
} ;</code></pre></div>
<p><code>operator +</code>はオペランドの値を変更しないので<code>const</code>にできる。</p>
<p>同様に、<code>operator -=</code>と<code>operator -</code>もある。上を参考に自分で実装してみよう。</p>
<p><code>operator +</code>によって任意の<code>n</code>個先の要素を使うことができるようになったので、イテレーター<code>i</code>の<code>n</code>個先の要素を参照したければ、以下のように<code>*(i+n)</code>も書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    std::cout &lt;&lt; a[<span class="dv">3</span>] ; <span class="co">// 4</span>

    <span class="kw">auto</span> i = a.begin() ;

    std::cout &lt;&lt; *(i + <span class="dv">3</span>) ; <span class="co">// 4</span>
}</code></pre></div>
<p>カッコが必要なのは、演算子の評価順序の都合だ。<code>*i + 3</code>は<code>(*i) + 3</code>であり、<code>i</code>の指す要素に対して<code>+3</code>される。<code>*(i+3)</code>は<code>i</code>の指す要素の3つ先の要素の値を読む。</p>
<p>イテレーター<code>i</code>の<code>n</code>個先の要素を読み書きするのにいちいち<code>*(i+n)</code>と書くのは面倒なので、<code>std::array</code>や<code>std::vector</code>のイテレーターには<code>operator []</code>がある。これを使うと<code>i[n]</code>と書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    std::cout &lt;&lt; a[<span class="dv">3</span>] ; <span class="co">// 4</span>

    <span class="kw">auto</span> i = a.begin() ;

    std::cout &lt;&lt; *(i + <span class="dv">3</span>) ; <span class="co">// 4</span>
}</code></pre></div>
<p><code>operator []</code>の実装は文字どおり<code>*(i+n)</code>と同じことをするだけでよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_iterator
{
    <span class="kw">typename</span> Array::reference
    <span class="kw">operator</span> [] ( std::size_t n ) <span class="dt">const</span>
    {
        <span class="kw">return</span> *( *<span class="kw">this</span> + n ) ;
    }

    <span class="co">// その他のメンバー</span>
} ;</code></pre></div>
<p>この<code>operator []</code>は、<code>array_iterator</code>のデータメンバーを変更しないので<code>const</code>修飾できる。</p>
<p><code>*this</code>というのはこのイテレーターのオブジェクトなので、それに対してすでに実装済みの<code>operator +</code>を適用し、その結果に<code>operator *</code>を適用している。既存の実装を使わない場合、<code>return</code>文は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">return</span> a[i+n] ;</code></pre></div>
<p>こちらの方が一見簡単なように見えるが、<code>operator +</code>や<code>operator *</code>の実装が複雑な場合、この方法では同じコードを複数の箇所に書かなければならず、コードを修正するときは同じ変更を複数の箇所に行わなければならない。すでに実装したメンバー関数は積極的に使って楽をしていこう。</p>
<p>イテレーターは大小比較ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a &lt;  b ;
a &lt;= b ;
a &gt;  b ;
a &gt;= b ;</code></pre></div>
<p>イテレーターの大小はどういう意味を持つのか。<code>array</code>のようにイテレーターが線形に順序のある要素を参照している場合で、前の要素を参照しているイテレーターはあとの要素を参照しているイテレーターより小さい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> a = std::begin(a) ;
    <span class="kw">auto</span> b = a + <span class="dv">1</span> ;

    a &lt;  b ; <span class="co">// true</span>
    a &lt;= b ; <span class="co">// true</span>
    a &gt;  b ; <span class="co">// false</span>
    a &gt;= b ; <span class="co">// false</span>
}</code></pre></div>
<p>自作の<code>array</code>の場合、単にデータメンバー<code>i</code>を比較する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_iterator
{
    Array &amp; a ;
    std::size_t i ;

    <span class="dt">bool</span> <span class="kw">operator</span> &lt; ( array_iterator <span class="dt">const</span> &amp; right ) <span class="dt">const</span>
    {
        <span class="kw">return</span> i &lt; right.i ;
    }
}</code></pre></div>
<p>残りの演算子も同様に実装できる。</p>
<h2 id="constなイテレーター-const_iterator">constなイテレーター: const_iterator</h2>
<p><code>std::array&lt;T,N&gt;</code>は通常のイテレーターである<code>std::array&lt;T,N&gt;::iterator</code>のほかに、<code>const</code>なイテレーターである<code>std::array&lt;T,N&gt;::const_iterator</code>を提供している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// iterator</span>
    std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt;::iterator iter = a.begin() ;
    <span class="co">// const_iterator</span>
    std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt;::const_iterator const_iter = a.cbegin() ;
}</code></pre></div>
<p><code>const_iterator</code>は<code>const iterator</code>ではない。<code>const_iterator</code>とはそれ自体が型名だ。<code>const</code>というのは型名を修飾する別の機能だ。</p>
<p>そのため、<code>const</code>の有無の2種類の状態と、<code>iterator</code>, <code>const_iterator</code>の2つの型を掛け合わせた、以下の型が存在する。</p>
<ul>
<li><code>iterator</code></li>
<li><code>const iterator</code></li>
<li><code>const_iterator</code></li>
<li><code>const const_iterator</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> Array = std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;

    <span class="co">// iterator </span>
    Array::iterator i ;
    <span class="co">// const iterator</span>
    <span class="dt">const</span> Array::iterator c_i ;
    <span class="co">// const_iterator</span>
    Array::const_iterator ci ;
    <span class="co">// const const_iterator</span>
    <span class="dt">const</span> Array::const_iterator c_ci ;
}</code></pre></div>
<p><code>const_iterator</code>は<code>iterator</code>とは別の型だ。自作の<code>array</code>に実装するならば以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="kw">using</span> iterator          = array_iterator&lt;array&gt; ;
    <span class="kw">using</span> const_iterator   = array_const_iterator&lt;array&gt; ;
} ;</code></pre></div>
<p>それぞれの型に対して、<code>const</code>キーワードを付けた型とそうでない型が存在する。</p>
<p><code>const_iterator</code>を得る方法はいくつかある。</p>
<ul>
<li><code>const</code>な<code>array</code>の<code>begin</code>/<code>end</code>を呼び出す</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// constなarray</span>
    <span class="dt">const</span> std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// const_iterator</span>
    <span class="kw">auto</span> i = a.begin() ;
}</code></pre></div>
<ul>
<li><code>cbegin</code>/<code>cend</code>を呼び出す</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// const_iterator</span>
    <span class="kw">auto</span> i = a.cbegin() ;
}</code></pre></div>
<ul>
<li><code>iterator</code>から<code>const_iterator</code>への変換</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> Array = std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;
    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// iterator</span>
    Array::iterator i = a.begin() ;
    <span class="co">// iteratorからconst_iteratorへの変換</span>
    Array::const_iterator j = i ;
}</code></pre></div>
<p><code>const</code>キーワードはすでに学んだように、オブジェクトの値を変更できないようにする機能だ。</p>
<p>なぜ<code>const_iterator</code>が存在するのか。<code>const iterator</code>ではだめなのか。その理由は、<code>const iterator</code>は値の変更ができないためだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> Array = std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;
    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// const iterator</span>
    <span class="dt">const</span> Array::iterator iter = a.begin() ;

    <span class="co">// エラー</span>
    <span class="co">// constなオブジェクトは変更できない</span>
    ++iter ;

    <span class="co">// Ok</span>
    <span class="co">// iterは変更していない</span>
    <span class="kw">auto</span> next_iter = iter + <span class="dv">1</span> ;
}</code></pre></div>
<p><code>const_iterator</code>ならばイテレーター自体の変更はできる。イテレーターが参照する要素の変更はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> Array = std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;
    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="kw">auto</span> citer = a.cbegin() ;

    <span class="co">// OK</span>
    <span class="co">// イテレーター自体の変更</span>
    ++citer ;

    <span class="co">// OK</span>
    <span class="co">// 要素を変更しない</span>
    std::cout &lt;&lt; *citer ;

    <span class="co">// エラー</span>
    <span class="co">// 要素を変更している</span>
    *citer = <span class="dv">0</span> ;
}</code></pre></div>
<p><code>const const_iterator</code>は<code>const_iterator</code>の<code>const</code>だ。<code>const const_iterator</code>は<code>const iterator</code>と同じく、イテレーター自体の変更ができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> Array = std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;
    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// const const_iterator</span>
    <span class="kw">auto</span> <span class="dt">const</span> iter = a.cbegin() ;

    <span class="co">// エラー</span>
    <span class="co">// constなオブジェクトは変更できない</span>
    ++iter ;

    <span class="co">// OK</span>
    <span class="co">// iterは変更していない</span>
    <span class="kw">auto</span> next_iter = iter + <span class="dv">1</span> ;
}</code></pre></div>
<p><code>auto const</code>もしくは<code>const auto</code>を使うと、変数の型を自動で推定してくれるが、<code>const</code>が付くようになる。</p>
<p><code>const_iterator</code>はどう実装するのか。まず<code>array</code>にネストされた型名<code>const_iterator</code>を追加する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="kw">using</span> iterator = array_iterator&lt;array&gt; ;
    <span class="kw">using</span> const_iterator = array_const_iterator&lt;array&gt; ;
} ;</code></pre></div>
<p><code>array</code>に<code>const_iterator</code>を返す<code>cbegin/cend</code>と、<code>const array</code>のときに<code>const_iterator</code>を返す<code>begin</code>/<code>end</code>を追加する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="kw">using</span> iterator = array_iterator&lt;array&gt; ;
    <span class="kw">using</span> const_iterator = array_const_iterator&lt;array&gt; ;

    <span class="co">// const arrayのときにconst_iteratorを返す</span>
    const_iterator begin() <span class="dt">const</span>
    { <span class="kw">return</span> const_iterator(*<span class="kw">this</span>, <span class="dv">0</span>) ; }
    const_iterator end() <span class="dt">const</span>
    { <span class="kw">return</span> const_iterator(*<span class="kw">this</span>, N) ; }

    <span class="co">// 常にconst_iteratorを返す</span>
    const_iterator cbegin() <span class="dt">const</span>
    { <span class="kw">return</span> const_iterator(*<span class="kw">this</span>, <span class="dv">0</span>) ; }
    const_iterator cend() <span class="dt">const</span>
    { <span class="kw">return</span> const_iterator(*<span class="kw">this</span>, N) ; }

    <span class="co">// その他のメンバー</span>
} ;</code></pre></div>
<p>あとは<code>array_const_iterator&lt;array&gt;</code>を実装する。その実装は<code>array_iterator&lt;array&gt;</code>とほぼ同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_const_iterator
{
    Array <span class="dt">const</span> &amp; a ;
    std::size_t i ;

    <span class="co">// コンストラクター</span>
    array_const_iterator( Array <span class="dt">const</span> &amp; a, std::size_t i )
        : a(a), i(i) { }
} ;</code></pre></div>
<p>ただし、<code>const_iterator</code>は<code>iterator</code>から変換できるので、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> Array = std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; ;
    Array a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// iterator</span>
    <span class="kw">auto</span> i = a.begin() ;

    <span class="co">// iteratorからconst_iteratorへの変換</span>
    Array::const_iterator j = i ;
}</code></pre></div>
<p>これに対応するために、<code>const_iterator</code>のコンストラクターは<code>iterator</code>から変換するためのコンストラクターも持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_const_iterator
{
    Array <span class="dt">const</span> &amp; a ;
    std::size_t i ;

    <span class="co">// array_iteratorからの変換コンストラクター</span>
    array_const_iterator( <span class="kw">typename</span> array_iterator&lt;Array&gt;::iterator <span class="dt">const</span> &amp; iter )
        : a( iter.a ), i( iter.i ) { }
} ;</code></pre></div>
<p>残りのメンバー関数は<code>iterator</code>とほぼ同じだ。</p>
<p>例えば<code>operator ++</code>は完全に同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// iterator版</span>
array_iterator &amp; array_iterator::<span class="kw">operator</span>++()
{
    ++i ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}
<span class="co">// const_iterator版</span>
array_const_iterator &amp; array_const_iterator::<span class="kw">operator</span> ++()
{
    ++i ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<p><code>operator *</code>や<code>operator []</code>は<code>const</code>なリファレンスを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typename</span> Array::const_reference <span class="kw">operator</span> *() <span class="dt">const</span>
{
    <span class="kw">return</span> a[i] ;
}

<span class="kw">typename</span> Array::const_reference <span class="kw">operator</span> []( std::size_t i ) <span class="dt">const</span>
{
    <span class="kw">return</span> *(*<span class="kw">this</span> + i) ;
}</code></pre></div>
<p>このために、<code>array</code>クラスにもネストされた型名<code>const_reference</code>を宣言しておく。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    <span class="kw">using</span> const_reference = T <span class="dt">const</span> &amp; ;
} ;</code></pre></div>
<p>残りは<code>iterator</code>の実装を参考に読者が自分で実装してみよう。</p>
<h1 id="傲慢なエラー処理-例外">傲慢なエラー処理: 例外</h1>
<h2 id="例外を投げる">例外を投げる</h2>
<p><code>std::array</code>の実装方法はほとんど解説した。読者は<code>std::array</code>の実装方法を知り、確固たる自信の元に<code>std::array</code>を使えるようになった。ただし、1つだけ問題がある。</p>
<p><code>&quot;std::array&quot;</code>のユーザーはあらかじめ設定した要素数を超える範囲の要素にアクセスすることができてしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 妥当な要素はa[0]のみ</span>
    std::array&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt; a = {<span class="dv">1</span>} ;

    <span class="co">// エラー、範囲外</span>
    a[<span class="dv">1000</span>] = <span class="dv">0</span> ;
}</code></pre></div>
<p><code>array</code>を自力で実装できる傲慢な読者としては、ユーザーごときが間違った使い方をできるのが許せない。間違いを起こした時点でエラーを発生させ、問題を知らしめ、対処できるようにしたい。</p>
<p><code>operator []</code>に範囲外チェックを入れるのは簡単だ。問題は、エラーをユーザーに通知する方法がない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">reference array::<span class="kw">operator</span> [] ( std::size_t i )
{
    <span class="co">// 範囲外チェック</span>
    <span class="kw">if</span> ( i &gt;= size() )
    {
        <span class="co">// エラー検出</span>
        <span class="co">// しかし何をreturnすればいいのだろう</span>
    }

    <span class="kw">return</span> storage[i] ;
}</code></pre></div>
<p><code>operator []</code>は伝統的にエラーチェックをしない要素アクセスをするものだ。</p>
<p><code>vector</code>で一番最初に説明した要素アクセスの方法であるメンバー関数<code>at</code>を覚えているだろうか。実はメンバー関数<code>at</code>はエラーチェックをする。試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt; a = {<span class="dv">1</span>} ;

    std::cout &lt;&lt; a.at(<span class="dv">1000</span>) = <span class="dv">0</span> ;
}</code></pre></div>
<p>以下が実行結果だ。</p>
<pre><code>terminate called after throwing an instance of &#39;std::out_of_range&#39;
  what():  array::at: __n (which is 1000) &gt;= _Nm (which is 1)</code></pre>
<p>何やらよくわからないがエラーのようだ。以下のような意味であることがわかる。</p>
<pre><code>`std::out_of_range`がthrowされたあとにterminateが呼ばれた
  what(): array_at: __n(値は1000) &gt;= _Nm (値は1)</code></pre>
<p>どうやらエラーメッセージのようだ。わかりづらいメッセージだが、なんとなく言わんとすることはわかる。<code>_Nm</code>が<code>array</code>の要素数で、<code>__n</code>がメンバー関数<code>at</code>に渡した実引数だ。要素数<code>_Nm</code>よりも<code>__n</code>が大きい。</p>
<p>このエラー処理は、「例外」を使って行われる。</p>
<p>例外は通常の処理をすっ飛ばして特別なエラー処理をする機能だ。何もエラー処理をしない場合、プログラムは終了する。例外を発生させることを、「例外を投げる」という。</p>
<p>例外は文字どおり投げるという意味の<code>throw</code>キーワードを使い、何らかの値を投げる(throw)。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int型の値123を投げる</span>
<span class="kw">throw</span> <span class="dv">123</span> ;

<span class="co">// double型の値3.14を投げる</span>
<span class="kw">throw</span> <span class="fl">3.14</span> ;

std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; value = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

<span class="co">// std::array&lt;int,5&gt;型の変数valueの値を投げる</span>
<span class="kw">throw</span> value ;</code></pre></div>
<p>この例では、<code>int</code>型、<code>double</code>型、<code>std::array&lt;int,5&gt;</code>型の値を投げている。</p>
<p>一度例外が投げられると、通常の実行はすっ飛ばされる。</p>
<p>以下は<code>0</code>を入力すると例外を投げるプログラムだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 0を入力するなよ、絶対するなよ</span>
    std::cout &lt;&lt; <span class="st">&quot;Don&#39;t type 0. &gt;&quot;</span>s ;

    <span class="dt">int</span> input {} ;
    std::cin &gt;&gt; input ;

    <span class="co">///</span> 入力が0なら例外を投げる
    <span class="kw">if</span> ( input == <span class="dv">0</span> )
        <span class="kw">throw</span> <span class="dv">0</span> ;

    <span class="co">// 通常の処理</span>
    std::cout &lt;&lt; <span class="st">&quot;Success!</span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">s</span> ;
}</code></pre></div>
<p>このプログラムを実行すると、非<code>0</code>を入力した場合、<code>&quot;Success!\n&quot;</code>が出力される。<code>0</code>を入力した場合、例外が投げられる。例外が投げられると、通常の実行はすっ飛ばされる。エラー処理はしていないので、プログラムは終了する。</p>
<p><code>std::array</code>や<code>std::vector</code>のメンバー関数<code>at(n)</code>は<code>n</code>が要素数を超える場合、例外を投げている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">array::reference array::at( std::size_t n )
{
    <span class="kw">if</span> ( n &gt;= size() )
        <span class="kw">throw</span> 何らかの値

    <span class="kw">return</span> storage[n] ;
}</code></pre></div>
<p>投げる例外は、<code>std::out_of_range</code>というクラスの値だ。このクラスを完全に説明するのは現時点では難しいが、以下のように振る舞うと考えておこう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {

<span class="kw">struct</span> out_of_range
{
    <span class="co">// エラー内容の文字列を受け取るコンストラクター</span>
    out_of_range( std::string <span class="dt">const</span> &amp; ) ;
    <span class="co">// エラー内容の文字列を返すメンバー関数</span>
    <span class="kw">auto</span> what() ;
} ;

}</code></pre></div>
<p>とりあえず使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::out_of_range err(<span class="st">&quot;I am error.&quot;</span>) ;

    <span class="co">// I am error.</span>
    std::cout &lt;&lt; err.what() ;
}</code></pre></div>
<p>コンストラクターでエラー内容を表現した文字列を受け取り、メンバー関数<code>what</code>でエラー内容の文字列を取得する。</p>
<p>必要な情報はすべて学んだ。あとはメンバー関数<code>at</code>を実装するだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">array::reference array::at( std::size_t n )
{
    <span class="kw">if</span> ( n &gt;= size() )
        <span class="kw">throw</span> std::out_of_range(<span class="st">&quot;Error: Out of Range&quot;</span>) ;

    <span class="kw">return</span> storage[n] ;
}</code></pre></div>
<h2 id="例外を捕まえる">例外を捕まえる</h2>
<p>現状では、エラーを発見して例外を投げたら即座にプログラムが終了してしまう。投げた例外を途中で捕まえて、プログラムを通常の実行に戻す機能がほしい。その機能が「例外のキャッチ」だ。</p>
<p>例外のキャッチには<code>try</code>キーワードと<code>catch</code>キーワードを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">try</span> {
    <span class="co">// 例外を投げるコード</span>
} <span class="kw">catch</span>( 型 名前 )
{
    エラー処理
}</code></pre></div>
<p><code>try {}</code>ブロックの中で投げられた例外は、<code>catch</code>で型が一致する場合にキャッチされる。例外がキャッチされた場合、<code>catch</code>のブロックが実行される。そして実行が再開される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="kw">try</span> {
        <span class="kw">throw</span> <span class="dv">123</span> ; <span class="co">// int型</span>
    }
    <span class="co">// キャッチする</span>
    <span class="kw">catch</span>( <span class="dt">int</span> e )
    {
        std::cout &lt;&lt; e ;
    }

    <span class="co">// 実行される</span>
    std::cout &lt;&lt; <span class="st">&quot;resumed.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p><code>catch</code>の型と投げられた例外の型が一致しない場合は、キャッチしない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">try</span> {
        <span class="kw">throw</span> <span class="fl">3.14</span> ; <span class="co">// double型</span>
    }
    <span class="co">// キャッチしない</span>
    <span class="kw">catch</span>( <span class="dt">int</span> e ) { }

    <span class="co">// 実行されない</span>
    std::cout &lt;&lt; <span class="st">&quot;You won&#39;t read this.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p><code>catch</code>は複数書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">try</span> {
        <span class="kw">throw</span> <span class="st">&quot;error&quot;</span>s ; <span class="co">// std::string型</span>
    }
    <span class="co">// キャッチしない</span>
    <span class="kw">catch</span>( <span class="dt">int</span> e ) { }
    <span class="co">// キャッチしない</span>
    <span class="kw">catch</span>( <span class="dt">double</span> e ) { }
    <span class="co">// キャッチする</span>
    <span class="kw">catch</span>( std::string &amp; e )
    {
        std::cout &lt;&lt; e ;
    }
}</code></pre></div>
<p><code>tryブロック</code>の中で投げられた例外は、たとえ複雑な関数呼び出しの奥底にある例外でもあますところなくキャッチされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="kw">throw</span> <span class="dv">123</span> ;
}

<span class="dt">void</span> g() { f() ; } 
<span class="dt">void</span> h() { g() ; }


<span class="dt">int</span> main()
{
    <span class="kw">try</span> {
        h() ;
    }
    <span class="co">// キャッチされる</span>
    <span class="kw">catch</span>( <span class="dt">int</span> e ) { }
}</code></pre></div>
<p>関数<code>h</code>は関数<code>g</code>を呼び出し、関数<code>g</code>は関数<code>f</code>を呼び出し、関数<code>f</code>は例外を投げる。このように複雑な関数呼び出しの結果として投げられる例外もキャッチできる。</p>
<p>すでに学んだように、<code>std::array&lt;T&gt;::at</code>に範囲外のインデックスを渡したときは<code>std::out_of_range</code>クラスが例外として投げられる。これをキャッチしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">1</span>&gt; a = {<span class="dv">0</span>} ;

    <span class="kw">try</span> { a[<span class="dv">1000</span>] ; }
    <span class="kw">catch</span>( std::out_of_range &amp; e )
    {
        <span class="co">// エラー内容を示す文字列</span>
        std::cout &lt;&lt; e.what() ;
    }
}</code></pre></div>
<h2 id="例外による巻き戻し">例外による巻き戻し</h2>
<p>例外が投げられた場合、その例外が投げられた場所を囲む<code>try</code>ブロックと対応する<code>catch</code>に到達するまで、関数呼び出しが巻き戻される。これを<code>スタックアンワインディング</code>(stack unwinding)という。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { <span class="kw">throw</span> <span class="dv">0</span> ; } 
<span class="dt">void</span> g() { f() ; }
<span class="dt">void</span> h() { g() ; }

<span class="dt">int</span> main()
{
    <span class="kw">try</span> { h() ; }
    <span class="kw">catch</span>( <span class="dt">int</span> e ) { }

}</code></pre></div>
<p>この例では、関数<code>main</code>が関数<code>h</code>を呼び出し、その結果として最終的に関数<code>f</code>の中で例外が投げられる。投げられた例外は関数呼び出しを巻き戻して関数<code>main</code>の中の<code>try</code>ブロックまで到達し、対応する<code>catch</code>に捕まる。</p>
<p>もし関数<code>main</code>を抜けてもなお対応する<code>catch</code>がない場合はどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">throw</span> <span class="dv">0</span> ;
    <span class="co">// 対応するcatchがない</span>
}</code></pre></div>
<p>その場合、<code>std::terminate()</code>という関数が呼ばれる。この関数が呼ばれた場合、プログラムは終了する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// プログラムは終了する</span>
    std::terminate() ;
}</code></pre></div>
<p><code>tryブロック</code>はネストできる。その場合、対応する<code>catch</code>が見つかるまで巻き戻しが起こる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="kw">try</span> { <span class="kw">throw</span> <span class="dv">0</span> ; }
    <span class="kw">catch</span> ( <span class="dt">double</span> e ) { }
}

<span class="dt">int</span> main()
{
    <span class="kw">try</span> { <span class="co">// try 1</span>
        <span class="kw">try</span> { <span class="co">// try 2</span>
            f() ;
        } <span class="kw">catch</span>( std::string &amp; e ) { }
    } <span class="kw">catch</span> ( <span class="dt">int</span> e )
    {
        <span class="co">// ここで捕まる</span>
    }
}</code></pre></div>
<p>上のコードは複雑な<code>tryブロック</code>のネストが行われている。プログラムがどのように実行されるのかを考えてみよう。</p>
<p>まず関数<code>main</code>が関数<code>f</code>を呼び出す。関数<code>f</code>は例外を投げる。関数<code>f</code>の中の<code>try</code>ブロックは対応する<code>catch</code>がないので関数<code>main</code>に巻き戻る。関数<code>main</code>の内側の<code>try</code>ブロック、ソースコードでは<code>// try 2</code> とコメントをしている<code>try</code>ブロックの<code>catch</code>には対応しない。さらに上の<code>try</code>ブロックに巻き戻る。<code>// try 1</code>の<code>tryブロック</code>の<code>catch</code>は<code>int</code>型なので、この<code>catch</code>に捕まる。</p>
<p>例外が投げられ、<code>スタックアンワインディング</code>による巻き戻しが発生した場合、通常のプログラムの実行は行われない。例えば以下のプログラムは何も出力しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="kw">throw</span> <span class="dv">0</span> ;
    <span class="co">// 例外を投げたあとの実行</span>
    std::cout &lt;&lt; <span class="st">&quot;function f</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">void</span> g()
{
    f() ;
    <span class="co">// 関数fを呼んだあとの実行</span>
    std::cout &lt;&lt; <span class="st">&quot;function g</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    g() ;
    <span class="co">// 関数gを呼んだあとの実行</span>
    std::cout &lt;&lt; <span class="st">&quot;function main</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p><code>スタックアンワインディング</code>中に通常の実行は行われないが、変数の破棄は行われる。これはとても重要だ。変数が破棄されるとき、デストラクターが実行されるのを覚えているだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Object
{
    std::string name ;
    <span class="co">// コンストラクター</span>
    Object( std::string <span class="dt">const</span> &amp; name ) : name(name) 
    { std::cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is constructed.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }

    <span class="co">// デストラクター</span>
    ~Object()
    { std::cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is destructed.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// 変数objが構築される</span>
    Object obj(<span class="st">&quot;obj&quot;</span>s) ;

    <span class="co">// 変数objが破棄される</span>
}</code></pre></div>
<p>実行結果</p>
<pre><code>obj is constructed.
obj is destructed.</code></pre>
<p>例外のスタックアンワインディングでは関数内の変数が破棄される。つまりデストラクターが実行される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    Object obj(<span class="st">&quot;f&quot;</span>s) ;
    <span class="kw">throw</span> <span class="dv">0</span> ;
}

<span class="dt">void</span> g()
{
    Object obj(<span class="st">&quot;g&quot;</span>s) ;
    f() ;
}

<span class="dt">int</span> main()
{
    Object obj(<span class="st">&quot;main&quot;</span>s) ;

    <span class="kw">try</span> {
        g() ;
    } <span class="kw">catch</span>( <span class="dt">int</span> e )
    {
        std::cout &lt;&lt; <span class="st">&quot;caught.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
    }

}</code></pre></div>
<p>このプログラムを実行した結果は以下のようになる。</p>
<pre><code>main is constructed.
g is constructed.
f is constructed.
f is destructed.
g is destructed.
caught.
main is destructed.</code></pre>
<p>なぜこの順番に出力されるか考えてみよう。</p>
<ol style="list-style-type: decimal">
<li>プログラムの実行は関数<code>main</code>から始まる。そのためまず<code>main</code>が構築される</li>
<li>関数<code>main</code>は関数<code>g</code>を呼ぶ。<code>g</code>が構築される</li>
<li>関数<code>g</code>は関数<code>f</code>を呼ぶ。<code>f</code>が構築される</li>
<li>関数<code>f</code>は例外を投げるので、<code>f</code>は破棄される</li>
<li>関数<code>g</code>に巻き戻ったが<code>catch</code>がないのでさらに巻き戻る。<code>g</code>が破棄される</li>
<li>関数<code>main</code>に巻き戻ったところ対応する<code>catch</code>があるのでスタックアンワインディングは停止する</li>
<li><code>caught.</code>が出力される</li>
<li><code>main</code>が破棄される</li>
</ol>
<p>例外が投げられると通常の実行は飛ばされるので、例外が投げられるかもしれない処理のあとに、例外の有無にかかわらず絶対に実行したい処理がある場合は、クラスのデストラクターに書くとよい。</p>
<p>C++20以降では、標準ライブラリに<code>std::scope_exit</code>が追加される予定だ。<code>std::scope_exit</code>は渡した関数オブジェクトをデストラクターで実行してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f()
{
    <span class="kw">auto</span> ptr = <span class="kw">new</span> ;
    std::scope_exit e( [&amp;]{ <span class="kw">delete</span> ptr ; } ) ;

    <span class="co">// 処理</span>
}</code></pre></div>
<p>このように書くと、後続の処理で<code>return</code>で関数から戻ろうが、<code>throw</code>しようが、<code>delete ptr</code>が実行される。</p>
<h1 id="ポインター">ポインター</h1>
<p>ポインターは難しいとよく言われる。世の中にはポインターのためにC言語とC++を挫折し、ほかの軟弱な言語に逃げるプログラマーがいる。ポインターしか解説していない本が出版される。Joel Spolskyがエッセイを書く。</p>
<p>ポインターの理解は優秀なプログラマーとなるために必須である。ポインターを理解できない人間は優秀なプログラマーにはなれない。もし、本書を読んでポインターが理解できない場合、プログラマーには向いていないということだ。</p>
<p>ポインターを難しくしている原因には、意味上のポインターと、文法上のポインターと、ポインターの内部実装がある。いずれも難しいが、本書を読めばポインターは完全に理解できる。</p>
<h2 id="意味上のポインター">意味上のポインター</h2>
<h3 id="リファレンスと同じ機能">リファレンスと同じ機能</h3>
<p>ポインターはオブジェクトを参照するための機能だ。この点ではリファレンスと同じ機能を提供している。</p>
<p>リファレンスを覚えているだろうか。<code>T</code>型へのリファレンスは<code>T</code>型のオブジェクトそのものではなく、<code>T</code>型のオブジェクトへの参照だ。リファレンスへの操作は、参照したオブジェクトへの操作になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型のオブジェクト</span>
    <span class="dt">int</span> object = <span class="dv">0</span> ;

    <span class="co">// オブジェクトを変更</span>
    object = <span class="dv">123</span> ;

    <span class="co">// 123</span>
    std::cout &lt;&lt; object ;

    <span class="co">// T型へのリファレンス</span>
    <span class="co">// objectを参照する</span>
    <span class="dt">int</span> &amp; reference = object ;

    <span class="co">// objectが変更される</span>
    reference = <span class="dv">456</span> ;

    <span class="co">// 456</span>
    std::cout &lt;&lt; object ;

    <span class="co">// referenceはobjectを参照している</span>
    object = <span class="dv">789</span> ;

    <span class="co">// 参照するobjectの値</span>
    <span class="co">// 789</span>
    std::cout &lt;&lt; reference ;
}</code></pre></div>
<p>リファレンスは宣言と同時に初期化する。リファレンスの参照先をあとから変えることはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;

    <span class="co">// rはxを参照する</span>
    <span class="dt">int</span> &amp; r = x ;

    <span class="dt">int</span> y = <span class="dv">1</span> ;

    <span class="co">// xに1が代入される</span>
    r = y ;
}</code></pre></div>
<p>最後の<code>r = y ;</code>はリファレンス<code>r</code>の参照先を<code>y</code>に変えるという意味ではない。リファレンス<code>r</code>の参照先に<code>y</code>の値を代入するという意味だ。</p>
<p>ポインターはリファレンスに似ている。並べてみるとほとんど同じ意味だ。</p>
<ul>
<li><code>T</code>型へのリファレンスは<code>T</code>型のオブジェクトを参照する</li>
<li><code>T</code>型へのポインターは<code>T</code>型のオブジェクトを参照する</li>
</ul>
<p><code>T</code>型へのリファレンス型が<code>T &amp;</code>であるのに対し、<code>T</code>型へのポインター型は<code>T *</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// intへのリファレンス型</span>
<span class="kw">using</span> ref_type = <span class="dt">int</span> &amp; ;
<span class="co">// intへのポインター型</span>
<span class="kw">using</span> ptr_type = <span class="dt">int</span> * ;</code></pre></div>
<p>リファレンスの初期化は、単に参照したい変数名をそのまま書けばよかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> object { } ;
<span class="dt">int</span> &amp; reference = object ;</code></pre></div>
<p>ポインターの場合、参照したい変数名に、<code>&amp;</code>を付ける必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> object { } ;
<span class="dt">int</span> * pointer = &amp;object ;</code></pre></div>
<p>リファレンスを経由してリファレンスが参照するオブジェクトを操作するには、単にリファレンス名を使えばよかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 書き込み</span>
reference = <span class="dv">0</span>
<span class="co">// 読み込み</span>
<span class="dt">int</span> read = reference ;  </code></pre></div>
<p>ポインターの場合、ポインター名に<code>*</code>を付ける必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 書き込み</span>
*pointer = <span class="dv">0</span> ;
<span class="co">// 読み込み</span>
<span class="dt">int</span> read = *pointer ;</code></pre></div>
<p>ポインター名をそのまま使った場合、それは参照先のオブジェクトの値ではなく、ポインターという値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// オブジェクト</span>
<span class="dt">int</span> object { } ;

<span class="co">// オブジェクトのポインター値で初期化</span>
<span class="dt">int</span> * p1 = &amp;object

<span class="co">// p1のポインター値で代入</span>
<span class="co">// つまりobjectを参照する</span>
<span class="dt">int</span> * p2 = p1 ;</code></pre></div>
<p>このように比較すると、ポインターはリファレンスと同じ機能を提供していることがわかる。実際、リファレンスというのはポインターのシンタックスシュガーにすぎない。ポインターの機能を制限して、文法をわかりやすくしたものだ。</p>
<h3 id="リファレンスと違う機能">リファレンスと違う機能</h3>
<p>リファレンスがポインターの機能制限版だというのであれば、ポインターにあってリファレンスにはない機能は何だろうか。代入と、何も参照しない状態だ。</p>
<h3 id="代入">代入</h3>
<p>リファレンスは代入ができないが、ポインターは代入ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x { } ;
<span class="dt">int</span> y { } ;

<span class="dt">int</span> &amp; reference = x ;
<span class="co">// xにyの値を代入</span>
<span class="co">// リファレンスの参照先は変わらない</span>
reference = y ;

<span class="dt">int</span> * pointer = &amp;x ;
<span class="co">// pointerの参照先をyに変更</span>
pointer = &amp;y ;</code></pre></div>
<h3 id="何も参照しない状態">何も参照しない状態</h3>
<p>リファレンスは必ず初期化しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー、初期化されていない</span>
<span class="dt">int</span> &amp; reference ; </code></pre></div>
<p>そのため、リファレンスは常にオブジェクトを参照している。</p>
<p>ポインターは初期化しなくてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * pointer ;</code></pre></div>
<p>この場合、具体的に何かを参照していない状態になる。この場合にポインターの値はどうなるかはわからない。初期化のない整数の値がわからないのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 値はわからない</span>
<span class="dt">int</span> data ;</code></pre></div>
<p>わからない値の整数を読んだ結果は未定義だ。書くことはできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値はわからない</span>
    <span class="dt">int</span> data ; 

    <span class="co">// 未定義</span>
    std::cout &lt;&lt; data ;

    <span class="co">// OK</span>
    data = <span class="dv">0</span> ;
}</code></pre></div>
<p>このプログラムは未定義動作を含むので、プログラム全体がどのように実行されるかも未定義だ。</p>
<p>そしてここからがポインターの恐ろしいところだが、ポインターの場合にもこのわからない値は発生する。わからない値を持ったポインターの参照先への読み書きは未定義の挙動を引き起こす。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> * pointer ;

    <span class="co">// 未定義の挙動</span>
    std::cout &lt;&lt; *pointer ;

    <span class="co">// 未定義の挙動</span>
    *pointer = <span class="dv">123</span> ;
}</code></pre></div>
<p>なぜ未定義の挙動になるかというと、わからない値のポインターは、たまたまどこかの妥当なオブジェクトを参照してしまっているかもしれないからだ。</p>
<p>未定義の挙動は恐ろしい。未定義の挙動が発生した場合、何が起こっても文句は言えない。なぜならばその挙動は本来存在するはずがないのだから。上のプログラムはコンパイル時にエラーになるかもしれないし、実行時にエラーになるかもしれない。いや、もっとひどいことにはエラーにならないかもしれない。そして人生、宇宙、すべてのものの答えと、あろうことか答えに対する質問まで出力するかもしれない。</p>
<h3 id="明示的に何も参照しないポインター-nullptr">明示的に何も参照しないポインター: nullptr</h3>
<p>ポインターを未初期化にしていると、よくわからない値になってしまう。そのため、何も参照していないことを明示的に示すためのポインターの値、nullポインター値がある。<code>nullptr</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * pointer = <span class="kw">nullptr</span> ;</code></pre></div>
<p><code>nullptr</code>はどんな型へのポインターに対しても、何も参照していない値となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// doubleへのポインター</span>
<span class="dt">double</span> * p1 = <span class="kw">nullptr</span> ;

<span class="co">// std::stringへのポインター</span>
std::string * p2 = <span class="kw">nullptr</span> ;</code></pre></div>
<p>C言語とC++では歴史的な理由で、<code>nullptr</code>のほかにも<code>NULL</code>もnullポインター値</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * pointer = NULL ;</code></pre></div>
<p>C++ではさらに歴史的な理由で、<code>0</code>もnullポインター値として扱う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * pointer = <span class="dv">0</span> ;</code></pre></div>
<p>ただし、nullポインター値が実際に0である保証はない。ポインターの値についてはあとで詳しく扱う。</p>
<h3 id="無効な参照先の作り方">無効な参照先の作り方</h3>
<p>ポインターやリファレンスによって参照先が参照される時点では有効だったが、後に無効になる参照先を作ることができてしまう。</p>
<p>例えば以下のコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * f()
{
    <span class="co">// 寿命は関数</span>
    <span class="dt">int</span> variable {} ;

    <span class="kw">return</span> &amp;variable ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> * ptr = f() ;
    <span class="co">// エラー</span>
    <span class="dt">int</span> read = *ptr ;
}</code></pre></div>
<p>このコードの問題は、関数<code>f</code>の中の変数<code>variable</code>の寿命は関数<code>f</code>の中だけで、呼び出し元に戻ったときには寿命が尽きるというところにある。変数<code>variable</code>へのポインターは変数<code>variable</code>の寿命が尽きたあとも存在してしまうので、存在しないオブジェクトにポインター経由でアクセスしようとしてエラーになる。</p>
<p>同じ問題はリファレンスでも起きるが、ポインターの方がこの問題を起こしやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp; f()
{
    <span class="dt">int</span> variable {} ;
    <span class="kw">return</span> variable ;
}</code></pre></div>
<h2 id="文法上のポインター">文法上のポインター</h2>
<p>ポインターが難しいと言われる理由の1つに、ポインターの文法が難しい問題がある。</p>
<h3 id="ポインターとconstの関係">ポインターとconstの関係</h3>
<p>型としてのポインターは、ある型<code>T</code>があるときに、<code>T</code>へのポインター型となる。</p>
<p><code>T</code>へのポインター型は<code>T *</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// intへのポインター型</span>
<span class="kw">using</span> t1 = <span class="dt">int</span> * ;
<span class="co">// doubleへのポインター型</span>
<span class="kw">using</span> t2 = <span class="dt">double</span> * ;
<span class="co">// std::stringへのポインター型</span>
<span class="kw">using</span> t3 = std::string * ;
<span class="co">// std::array&lt;int,5&gt;へのポインター型</span>
<span class="kw">using</span> t4 = std::array&lt;<span class="dt">int</span>,<span class="dv">5</span>&gt; * ;
<span class="co">// std::array&lt;double,10&gt;へのポインター型</span>
<span class="kw">using</span> t5 = std::array&lt;<span class="dt">double</span>,<span class="dv">10</span>&gt; * ;</code></pre></div>
<p>リファレンスや<code>const</code>も同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int型へのポインター型</span>
<span class="kw">using</span> t1 = <span class="dt">int</span> * ;
<span class="co">// int型へのリファレンス型</span>
<span class="kw">using</span> t2 = <span class="dt">int</span> &amp; ;
<span class="co">// どちらも同じconstなint型</span>
<span class="kw">using</span> t3 = <span class="dt">const</span> <span class="dt">int</span> ;
<span class="kw">using</span> t4 = <span class="dt">int</span> <span class="dt">const</span> ;</code></pre></div>
<p><code>const int</code>と<code>int const</code>は同じ型だ。この場合、<code>const</code>は<code>int</code>型のあとに付いても前に付いても同じ意味になる。</p>
<p>すると当然の疑問が生じる。組み合わせるとどうなるのかということだ。</p>
<p>ポインター型へのリファレンス型はできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int *型へのリファレンス</span>
<span class="kw">using</span> type = <span class="dt">int</span> * &amp; ;</code></pre></div>
<p>リファレンス型へのポインター型はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー、できない</span>
<span class="kw">using</span> error = <span class="dt">int</span> &amp; * ;</code></pre></div>
<p>理由は、リファレンスへのポインターというのは意味がないからだ。ポインターへのリファレンスは意味がある。</p>
<p>リファレンスからポインターの値を得るには、参照先のオブジェクトと同じく<code>&amp;</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> data { } ;
<span class="dt">int</span> &amp; ref = data ;
<span class="co">// &amp;dataと同じ</span>
<span class="dt">int</span> * ptr = &amp;ref ;</code></pre></div>
<p>リファレンスは参照先のオブジェクトとまったく同じように振る舞うのでリファレンス自体のポインターの値を得ることはできない。</p>
<p>ポインターのリファレンスを得るのは、ポインター以外の値とまったく同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * ptr = <span class="kw">nullptr</span> ;
<span class="co">// ptrを参照する</span>
<span class="dt">int</span> * &amp; ref = ptr ;

<span class="dt">int</span> data { } ;
<span class="co">// ptrの値が&amp;dataになる。</span>
ref = &amp;data ;</code></pre></div>
<p><code>const</code>とポインターの組み合わせは難しい。</p>
<p>まず型<code>T</code>とその<code>const</code>版がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> T = <span class="dt">int</span> ;
<span class="kw">using</span> const_T = <span class="dt">const</span> T ;</code></pre></div>
<p>そして型<code>T</code>とそのポインター版がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> T = <span class="dt">int</span> ;
<span class="kw">using</span> T_pointer = T * ;</code></pre></div>
<p>これを組み合わせると、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 型T</span>
<span class="kw">using</span> T = <span class="dt">int</span> ;
<span class="co">// どちらもconstなT</span>
<span class="kw">using</span> const_T_1 = <span class="dt">const</span> T ;
<span class="kw">using</span> const_T_2 = T <span class="dt">const</span> ;
<span class="co">// Tへのポインター</span>
<span class="kw">using</span> T_pointer = T * ;

<span class="co">// どちらもconstなTへのポインター</span>
<span class="kw">using</span> const_T_pointer_1 = <span class="dt">const</span> T * ;
<span class="kw">using</span> const_T_pointer_2 = T <span class="dt">const</span> * ;

<span class="co">// Tへのconstなポインター</span>
<span class="kw">using</span> T_const_pointer = T * <span class="dt">const</span> ;

<span class="co">// どちらもconstなTへのconstなポインター</span>
<span class="kw">using</span> const_T_const_pointer_1 = <span class="dt">const</span> T * <span class="dt">const</span> ;
<span class="kw">using</span> const_T_const_pointer_2 = T <span class="dt">const</span> * <span class="dt">const</span> ;</code></pre></div>
<p>順番に見ていこう。まずは組み合わせない型から。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> T = <span class="dt">int</span> ;
<span class="co">// どちらもconstなT</span>
<span class="kw">using</span> const_T_1 = <span class="dt">const</span> T ;
<span class="kw">using</span> const_T_2 = T <span class="dt">const</span> ;
<span class="co">// Tへのポインター</span>
<span class="kw">using</span> T_pointer = T * ;</code></pre></div>
<p><code>T</code>はここでは<code>int</code>型だ。<code>T</code>型はどんな型でもよい。</p>
<p><code>const T</code>と<code>T const</code>が同じ型であることを思い出せば、<code>const_T_1</code>と<code>const_T_2</code>は同じ型であることがわかるだろう。</p>
<p><code>T_pointer</code>は<code>T</code>へのポインターだ。</p>
<p>次を見ていこう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// どちらもconstなTへのポインター</span>
<span class="kw">using</span> const_T_pointer_1 = <span class="dt">const</span> T * ;
<span class="kw">using</span> const_T_pointer_2 = T <span class="dt">const</span> * ;</code></pre></div>
<p>これはどちらも同じ型だ。<code>const</code>な<code>T</code>へのポインターとなる。わかりにくければ以下のように書いてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// constなT</span>
<span class="kw">using</span> const_T = <span class="dt">const</span> <span class="dt">int</span> ;
<span class="co">// constなTへのポインター</span>
<span class="kw">using</span> const_T_pointer = const_T * ;</code></pre></div>
<p>実際に使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">const</span> <span class="dt">int</span> data = <span class="dv">123</span> ;
    <span class="co">// int const *でもよい</span>
    <span class="dt">const</span> <span class="dt">int</span> * ptr = &amp;data ;

    <span class="co">// 読み込み</span>
    <span class="dt">int</span> read = *ptr ;
}</code></pre></div>
<p><code>const</code>な<code>int</code>へのポインターなので、このポインターの参照先を変更することはできない。ポインターは変更できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">const</span> <span class="dt">int</span> x {} ;
    <span class="dt">const</span> <span class="dt">int</span> * ptr = &amp;x ;

    <span class="co">// エラー</span>
    <span class="co">// constな参照先を変更できない</span>
    *ptr = <span class="dv">0</span> ;

    <span class="dt">int</span> y {} ;
    <span class="co">// OK</span>
    <span class="co">// ポインターはconstではないので値が変更できる</span>
    ptr = &amp;y ;
}</code></pre></div>
<p><code>const</code>なのは<code>int</code>であってポインターではない。<code>const int *</code>、もしくは<code>int const *</code>は参照先の<code>int</code>が<code>const</code>なので、参照先を変更することができない。ポインターは<code>const</code>ではないので、ポインターの値は変更できる。</p>
<p><code>const</code>な<code>T</code>型へのリファレンスで<code>const</code>ではない<code>T</code>型のオブジェクトを参照できるように、<code>const</code>な<code>T</code>型へのポインターから<code>const</code>ではない<code>T</code>型のオブジェクトを参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// constではない</span>
    <span class="dt">int</span> data { } ;

    <span class="co">// OK</span>
    <span class="dt">const</span> <span class="dt">int</span> &amp; ref = data ;
    <span class="co">// OK</span>
    <span class="dt">const</span> <span class="dt">int</span> * ptr = &amp;data ;
}</code></pre></div>
<p>この場合、リファレンスやポインターは<code>const int</code>扱いなので、リファレンスやポインターを経由して読むことはできるが変更はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> data = <span class="dv">123</span> ;
    <span class="dt">const</span> <span class="dt">int</span> * ptr = &amp;data ;
    <span class="co">// エラー</span>
    <span class="co">// 変更できない</span>
    *ptr = <span class="dv">0</span> ;

    <span class="co">// 変更できる</span>
    data = <span class="dv">0</span> ;
}</code></pre></div>
<p>その次は<code>const</code>なポインターだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Tへのconstなポインター</span>
<span class="kw">using</span> T_const_pointer = T * <span class="dt">const</span> ;</code></pre></div>
<p>これはポインターが<code>const</code>なのであって、<code>T</code>は<code>const</code>ではない。したがってポインターを経由して参照先を変更することはできるが、ポインターの値自体は変更できない型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> data { } ;

    <span class="co">// constなポインター</span>
    <span class="dt">int</span> * <span class="dt">const</span> ptr = &amp;data ;

    <span class="co">// OK、参照先は変更できる</span>
    *ptr = <span class="dv">1</span> ;

    <span class="co">// エラー、値は変更できない</span>
    ptr = <span class="kw">nullptr</span> ;
}</code></pre></div>
<p>最後は<code>const</code>な<code>T</code>への<code>const</code>なポインターだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// どちらもconstなTへのconstなポインター</span>
<span class="kw">using</span> const_T_const_pointer_1 = <span class="dt">const</span> T * <span class="dt">const</span> ;
<span class="kw">using</span> const_T_const_pointer_2 = T <span class="dt">const</span> * <span class="dt">const</span> ;</code></pre></div>
<p>これは<code>const</code>な<code>T</code>なので、ポインターを経由して参照先を変更できないし、<code>const</code>なポインターなのでポインターの値も変更できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> data = <span class="dv">123</span> ;

    <span class="dt">int</span> <span class="dt">const</span> * <span class="dt">const</span> ptr = &amp;data ;

    <span class="co">// OK、参照先は読める</span>
    <span class="dt">int</span> read = *ptr ;
    <span class="co">// エラー、参照先は変更できない</span>
    *ptr = <span class="dv">0</span> ;
    <span class="co">// エラー、ポインターは変更できない</span>
    ptr = <span class="kw">nullptr</span> ;
}</code></pre></div>
<h3 id="ポインターのポインター">ポインターのポインター</h3>
<p>ポインター型というのは、「ある型<code>T</code>へのポインター」という形で表現できる。この型<code>T</code>にはどんな型でも使うことができる。ところで、ポインターというのは型だ。もし<code>T</code>がポインター型の場合はどうなるのだろう。</p>
<p>例えば、「<code>T</code>型へのポインター型」で、型<code>T</code>が「<code>U</code>型へのポインター型」の場合、全体としては「<code>U</code>型へのポインター型へのポインター型」になる。これはC++の文法では<code>U **</code>となる。</p>
<p>C++のコードで確認しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 適当なU型</span>
<span class="kw">using</span> U = <span class="dt">int</span> ;
<span class="co">// ポインターとしてのT型</span>
<span class="kw">using</span> T = U * ;
<span class="co">// T型へのポインター型</span>
<span class="co">// つまりU型へのポインター型へのポインター型</span>
<span class="co">// つまりU **</span>
<span class="kw">using</span> type = T * ;</code></pre></div>
<p>具体的に書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int</span>
    <span class="dt">int</span> x = <span class="dv">123</span> ;
    <span class="co">// intへのポインター</span>
    <span class="dt">int</span> * p = &amp;x ;
    <span class="co">// intへのポインターのポインター</span>
    <span class="dt">int</span> ** pp = &amp;p ;


    <span class="co">// 123</span>
    <span class="co">// ポインターを経由したポインターを経由したxの読み込み</span>
    <span class="dt">int</span> value1 = **pp ; 

    <span class="dt">int</span> y = <span class="dv">456</span> ;
    <span class="co">// ポインターを経由した変数pの変更</span>
    *pp = &amp;y ;

    <span class="co">// 456</span>
    <span class="co">// ポインターを経由したポインターを経由したyの読み込み</span>
    <span class="dt">int</span> value2 = **pp ;
}</code></pre></div>
<p><code>x</code>は<code>int</code>だ。<code>p</code>は<code>int</code>へのポインターだ。ここまではいままでどおりだ。</p>
<p><code>pp</code>は<code>int **</code>という型で、「<code>int</code>へのポインターへのポインター」型だ。このポインターの値のためには「<code>int</code>へのポインターのポインター」が必要だ。変数<code>p</code>のポインターは<code>&amp;p</code>で得られる。この場合、変数<code>p</code>は「<code>int</code>へのポインター」でなければならない。そうした場合、変数<code>p</code>のポインターは「<code>int</code>へのポインターのポインター」型の値になる。</p>
<p>変数<code>pp</code>は「<code>int</code>へのポインターのポインター」だ。変数<code>pp</code>の参照先の変数<code>p</code>を読み書きするには、<code>*pp</code>と書く。これはまだ「<code>int</code>へのポインター」だ。ここからさらに参照先の<code>int</code>型のオブジェクトにアクセスするには、その結果にさらに<code>*</code>を書く。結果として<code>**pp</code>となる。</p>
<p>わかりにくければ変数に代入するとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> object { } ;

    <span class="dt">int</span> *   a = &amp;object ;
    <span class="dt">int</span> **  b = &amp;a ;

    <span class="co">// cとaは同じ値</span>
    <span class="dt">int</span> * c = *pointer_to_pointer_to_object ;

    <span class="co">// objectに1が代入される</span>
    *c = <span class="dv">1</span> ;
    <span class="co">// objectに2が代入される</span>
    **b = <span class="dv">2</span> ;
}</code></pre></div>
<p>リファレンスを使うという手もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> object { } ;

    <span class="dt">int</span> *   a = &amp;object ;
    <span class="dt">int</span> **  b = &amp;a ;

    <span class="dt">int</span> &amp; r1 = *a ;

    <span class="co">// objectに1が代入される</span>
    r1 = <span class="dv">1</span> ;

    <span class="dt">int</span> &amp;r2 = **b ;

    <span class="co">// objectに2が代入される</span>
    r2 = <span class="dv">2</span> ;
}</code></pre></div>
<p>「ポインターへのポインター」があるということは、「ポインターへのポインターへのポインター」もあるということだろうか。もちろんある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// intへのポインターへのポインターへのポインター型</span>
<span class="kw">using</span> type = <span class="dt">int</span> *** ;

<span class="co">// intへのポインターへのポインターへのポインターへのポインター型</span>
<span class="co">// int ****</span>
<span class="kw">using</span> pointer_to_type = type * ;</code></pre></div>
<p>もちろん<code>const</code>も付けられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="dt">int</span> <span class="dt">const</span> * <span class="dt">const</span> * <span class="dt">const</span> * <span class="dt">const</span> ;</code></pre></div>
<h3 id="関数へのポインター">関数へのポインター</h3>
<p>関数へのポインターを説明する前に、まず型としての関数を説明しなければならない。</p>
<p>関数にも型がある。例えば以下のような関数、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> ) ;
<span class="dt">double</span> g( <span class="dt">double</span>, <span class="dt">double</span> ) ;</code></pre></div>
<p>の型は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> f_type = <span class="dt">int</span> ( <span class="dt">int</span> ) ;
<span class="kw">using</span> g_type = <span class="dt">double</span> ( <span class="dt">double</span>, <span class="dt">double</span> ) ;</code></pre></div>
<p>となる。関数から関数名を取り除いたものが関数の型だ。すると関数へのポインター型は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> f_pointer = f_type * ;
<span class="kw">using</span> g_pointer = g_type * ;</code></pre></div>
<p>さっそく試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実引数を出力して返す関数</span>
<span class="dt">int</span> f( <span class="dt">int</span> x )
{
    std::cout &lt;&lt; x ;
    <span class="kw">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="kw">using</span> f_type = <span class="dt">int</span> ( <span class="dt">int</span> ) ;
    <span class="kw">using</span> f_pointer = f_type * ;

    f_pointer ptr = &amp;f ;

    <span class="co">// 関数へのポインターを経由した関数呼び出し</span>
    (*ptr)(<span class="dv">123</span>) ;
}</code></pre></div>
<p>動くようだ。最後の関数呼び出しはまず参照先を得て<code>(*ptr)</code>、その後に関数呼び出し<code>(123)</code>をしている。これは面倒なので、C++では特別に関数へのポインターはそのまま関数呼び出しすることができるようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 関数へのポインターを経由した関数呼び出し</span>
ptr(<span class="dv">123</span>) ;</code></pre></div>
<p>ところで、変数<code>ptr</code>の宣言を、<code>f_pointer</code>というエイリアス宣言を使わずに書くと、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 適当な関数</span>
<span class="dt">int</span> f( <span class="dt">int</span> ) { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="co">// 変数ptrの宣言</span>
<span class="co">// int (int)へのポインター</span>
<span class="dt">int</span> (*ptr)(<span class="dt">int</span>) = &amp;f ;</code></pre></div>
<p>なぜこうなるのか。これを完全に理解するためにはC++の宣言子(declarator)という文法の詳細な理解が必要だ。</p>
<p>ここでは詳細を飛ばして重要な部分だけ伝えるが、型名のうちポインターであることを指定する<code>*</code>は、名前にかかる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// この *はnameにかかる</span>
<span class="dt">int</span> * name ;</code></pre></div>
<p>つまり以下のような意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> (*name) ;</code></pre></div>
<p>型名だけを指定する場合、名前が省略される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 名前が省略されている</span>
<span class="kw">using</span> type = <span class="dt">int</span> * ;</code></pre></div>
<p>つまり以下のような意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="dt">int</span> (*) ;</code></pre></div>
<p>そのため、<code>int * name( int )</code>と書いた場合、これは「<code>int</code>型の引数を取り、<code>int</code>型へのポインターを戻り値として返す関数」となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * f( <span class="dt">int</span> ){ <span class="kw">return</span> <span class="kw">nullptr</span> ; }</code></pre></div>
<p>そうではなく、「<code>int</code>型の引数を取り<code>int</code>型の戻り値を返す関数へのポインター」を書きたい場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="dt">int</span> (*)(<span class="dt">int</span>) ;</code></pre></div>
<p>としなければならない。</p>
<p>変数の名前を入れる場所は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type =
<span class="dt">int</span>
( * <span class="co">// ポインター</span>
<span class="co">// ここに変数が省略されている</span>
)(<span class="dt">int</span>) ;</code></pre></div>
<p>なので、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> (*ptr)(<span class="dt">int</span>) = <span class="kw">nullptr</span> ;</code></pre></div>
<p>となる。あるいは以下のように書いてもいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> function_type = <span class="dt">int</span> (<span class="dt">int</span>) ;
<span class="kw">using</span> function_pointer_type = function_type * ;

function_pointer_type ptr = <span class="kw">nullptr</span> ;</code></pre></div>
<p>関数へのポインターは型であり、値でもある。値であるということは、関数は引数として関数へのポインターを受け取ったり、関数へのポインターを返したりできるということだ。</p>
<p>さっそく書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x ) { <span class="kw">return</span> x ; }
<span class="kw">using</span> f_ptr = <span class="dt">int</span> (*) (<span class="dt">int</span> ) ;
<span class="co">// 関数へのポインターを引数に取り</span>
<span class="co">// 関数へのポインターを戻り値として返す</span>
<span class="co">// 関数g</span>
f_ptr g( f_ptr p )
{
    p(<span class="dv">0</span>) ;
    <span class="kw">return</span> p ;
}

<span class="dt">int</span> main()
{
    g(&amp;f) ;
}</code></pre></div>
<p>これは動く。ところでこの関数<code>g</code>へのポインターはどう書けばいいのだろうか。つまり、</p>
<pre><code>auto ptr = &amp;g ;</code></pre>
<p>を<code>auto</code>を使わずに書くとどうなるのだろうか。</p>
<p>以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> (*(*ptr)(<span class="dt">int</span> (*)(<span class="dt">int</span>)))(<span class="dt">int</span>) = &amp;g ;</code></pre></div>
<p>なぜこうなるのか。分解すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> (* <span class="co">// 戻り値型前半</span>
    (*ptr) <span class="co">// 変数名</span>
    (<span class="co">// 関数の引数</span>
        <span class="dt">int</span> (*)(<span class="dt">int</span>) <span class="co">// 引数としての関数へのポインター</span>
    )<span class="co">// 関数の引数</span>

)(<span class="dt">int</span>) <span class="co">// 戻り値の型後半</span>

 = &amp;g ; <span class="co">// 初期化子</span></code></pre></div>
<p>これはわかりにくい。戻り値の型を後ろに書く文法を使うと少し読みやすくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> (*ptr)( <span class="dt">int</span> (*)(<span class="dt">int</span>) ) -&gt; <span class="dt">int</span> (*)(<span class="dt">int</span>) = &amp;g ;</code></pre></div>
<p>これを分解すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> <span class="co">// プレイスホルダー</span>
(*ptr) <span class="co">// 変数名</span>
( <span class="dt">int</span> (*)(<span class="dt">int</span>) ) <span class="co">// 引数</span>
-&gt; <span class="dt">int</span> (*)(<span class="dt">int</span>) <span class="co">// 戻り値の型</span>
= &amp;g ; <span class="co">// 初期化子</span></code></pre></div>
<p>もちろん、これでもまだわかりにくいので、エイリアス宣言を使った方がよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> func_ptr = <span class="dt">int</span>(*)(<span class="dt">int</span>) ;

<span class="kw">auto</span> (*ptr)(func_ptr) -&gt; func_ptr = &amp;g ;</code></pre></div>
<h3 id="配列へのポインター">配列へのポインター</h3>
<p>配列へのポインターについて学ぶ前に、配列の型について学ぶ必要がある。</p>
<p>配列の型は、要素の型を<code>T</code>、要素数を<code>N</code>とすると、<code>T [N]</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 要素型int、要素数5の配列型</span>
<span class="kw">using</span> int5 = <span class="dt">int</span> [<span class="dv">5</span>] ;
<span class="co">// 要素型double、要素数10の配列型</span>
<span class="kw">using</span> double10 = <span class="dt">double</span> [<span class="dv">10</span>] ;</code></pre></div>
<p>関数型と同じく、ポインター宣言子である<code>*</code>は名前に付く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 要素型int、要素数5の配列へのポインター型</span>
<span class="kw">using</span> pointer_to_array_type = <span class="dt">int</span> (*)[<span class="dv">5</span>] ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">5</span>] ;
    pointer_to_array_type ptr = &amp;a ;
}</code></pre></div>
<p>エイリアス宣言を使わない変数の宣言は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">5</span>] ;
    <span class="dt">int</span> (*p)[<span class="dv">5</span>] = &amp;a ;
}</code></pre></div>
<p>配列とポインターは密接に関係している。そのため、配列名は配列の先頭要素へのポインターに暗黙に変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// &amp;a[0]と同じ</span>
    <span class="dt">int</span> * ptr = a ;
}</code></pre></div>
<p>配列とポインターの関係については、ポインターの詳細で詳しく説明する。</p>
<h3 id="ポインター型の作り方">ポインター型の作り方</h3>
<p><code>T</code>型へのポインター型は<code>T *</code>で作ることができる。</p>
<p>ただし、<code>T</code>が<code>int (int)</code>のような関数型である場合は、<code>int (*)(int)</code>になる。配列型の場合は要素数<code>N</code>まで必要で<code>T (*)[N]</code>になる。</p>
<p>エイリアス宣言で型に別名を付けると<code>T *</code>でよくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> function_type = <span class="dt">int</span> (<span class="dt">int</span>) ;
<span class="kw">using</span> pointer_to_function_type = function_type * ;</code></pre></div>
<p>ポインターの型を書く際に、このようなことをいちいち考えるのは面倒だ。ここで必要のなのは、ある型<code>T</code>を受け取ったときに型<code>T *</code>を得るような方法だ。ところで、物覚えのいい読者は前にも似たような文章を読んだことに気が付くだろう。そう、テンプレートだ。</p>
<p>テンプレートは型を引数化できる機能だ。いままではクラスや関数にしか使っていなかったが、実はエイリアス宣言にも使えるのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">using</span> type = T ;</code></pre></div>
<p>これは引数と同じ型になるエイリアステンプレートだ。使ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="kw">using</span> type = T ;

<span class="co">// aはint</span>
type&lt;<span class="dt">int</span>&gt; a = <span class="dv">123</span> ;
<span class="co">// bはdouble</span>
type&lt;<span class="dt">double</span>&gt; b = <span class="fl">1.23</span> ;
<span class="co">// cはstd::vector&lt;int&gt;</span>
type&lt;std::vector&lt;<span class="dt">int</span>&gt;&gt; c = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</code></pre></div>
<p><code>using type = int ;</code>というエイリアス宣言があるとき<code>type</code>の型は<code>int</code>だ。エイリアス宣言は新しい<code>type</code>という型を作るわけではない。</p>
<p>同様に、上のエイリアステンプレート<code>type</code>による<code>type&lt;int&gt;</code>の型は<code>int</code>だ。新しい<code>type&lt;int&gt;</code>という型ができるわけではない。</p>
<p>もう少し複雑な使い方もしてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
type&lt;type&lt;<span class="dt">int</span>&gt;&gt; a = <span class="dv">0</span> ;
<span class="co">// int</span>
type&lt;type&lt;type&lt;<span class="dt">int</span>&gt;&gt;&gt; b = <span class="dv">0</span> ;</code></pre></div>
<p><code>type&lt;int&gt;</code>の型は<code>int</code>なので、それを引数に渡した<code>type&lt; type&lt;int&gt; &gt;</code>も<code>int</code>だ。<code>type&lt;T&gt;</code>をいくつネストしようとも<code>int</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// std::vector&lt;int&gt;</span>
std::vector&lt; type&lt;<span class="dt">int</span>&gt; &gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
<span class="co">// std::vector&lt;int&gt;</span>
type&lt;std::vector&lt;type&lt;<span class="dt">int</span>&gt;&gt;&gt; b = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</code></pre></div>
<p><code>type&lt;int&gt;</code>は<code>int</code>なので、<code>std::vector&lt;type&lt;int&gt;&gt;</code>は<code>std::vector&lt;int&gt;</code>になる。それをさらに<code>type&lt;T&gt;</code>で囲んでも同じ型だ。</p>
<p><code>type&lt;T&gt;</code>は面白いが何の役に立つのだろうか。<code>type&lt;T&gt;</code>は型として使える。つまり<code>type&lt;T&gt; *</code>はポインターとして機能するのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="kw">using</span> type = T ;

<span class="co">// int *</span>
type&lt;<span class="dt">int</span>&gt; * a = <span class="kw">nullptr</span> ;
<span class="co">// int (*)(int)</span>
type&lt;<span class="dt">int</span>(<span class="dt">int</span>)&gt; * b = <span class="kw">nullptr</span> ;
<span class="co">// int (*) [5]</span>
type&lt;<span class="dt">int</span> [<span class="dv">5</span>]&gt; * c = <span class="kw">nullptr</span> ;</code></pre></div>
<p><code>type&lt;int&gt; *</code>は<code>int *</code>型だ。<code>type&lt;int(int)&gt; *</code>は<code>int(*)(int)</code>型だ。<code>type&lt;int [5]&gt; *</code>は<code>int (*) [5]</code>型だ。これでもう<code>*</code>をどこに書くかという問題に悩まされることはなくなった。</p>
<p>しかしわざわざ<code>type&lt;T&gt; *</code>と書くのは依然として面倒だ。<code>T</code>型は引数で受け取っているのだから、最初からポインターを返してどうだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">using</span> add_pointer_t = T * ;</code></pre></div>
<p>さっそく試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int *</span>
add_pointer_t&lt;<span class="dt">int</span>&gt; a = <span class="kw">nullptr</span> ;
<span class="co">// int **</span>
add_pointer_t&lt;<span class="dt">int</span> *&gt; b = <span class="kw">nullptr</span> ;
<span class="co">// int(*)(int)</span>
add_pointer_t&lt;<span class="dt">int</span>(<span class="dt">int</span>)&gt; c = <span class="kw">nullptr</span> ;
<span class="co">// int(*)[5]</span>
add_pointer_t&lt;<span class="dt">int</span> [<span class="dv">5</span>]&gt; d = <span class="kw">nullptr</span> ;</code></pre></div>
<p>どうやら動くようだ。もっと複雑な例も試してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int **</span>
add_pointer_t&lt;add_pointer_t&lt;<span class="dt">int</span>&gt;&gt; a = <span class="kw">nullptr</span> ;</code></pre></div>
<p><code>add_pointer_t&lt;int&gt;</code>は<code>int *</code>なので、その型を<code>add_pointer_t&lt;T&gt;</code>で囲むとその型へのポインターになる。結果として<code>int **</code>になる。</p>
<p>ここで実装した<code>add_pointer_t&lt;T&gt;</code>は<code>T</code>がリファレンスのときにエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt; <span class="kw">using</span> add_pointer_t = T * ;
<span class="co">// エラー</span>
add_pointer_t&lt;<span class="dt">int</span> &amp;&gt; ptr = <span class="kw">nullptr</span> ;</code></pre></div>
<p>実は標準ライブラリにも<code>std::add_pointer_t&lt;T&gt;</code>があり、こちらはリファレンス<code>U &amp;</code>を渡しても、<code>U *</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK</span>
<span class="co">// int *</span>
std::add_pointer_t&lt;<span class="dt">int</span> &amp;&gt; ptr = <span class="kw">nullptr</span> ;</code></pre></div>
<p>標準ライブラリ<code>std::add_pointer_t&lt;T&gt;</code>は、<code>T</code>がリファレンス型の場合、リファレンスは剝がしてポインターを付与するという実装になっている。これをどうやって実装するかについてだが、まだ読者の知識では実装できない。テンプレートについて深く学ぶ必要がある。いまは標準ライブラリに頼っておこう。</p>
<p>標準ライブラリにはほかにも、ポインターを取り除く<code>std::remove_pointer_t&lt;T&gt;</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
std::remove_pointer_t&lt;<span class="dt">int</span> * &gt; a = <span class="dv">0</span> ;
<span class="co">// int</span>
std::remove_pointer_t&lt;
    std::add_pointer_t&lt;<span class="dt">int</span>&gt;
    &gt; b = <span class="dv">0</span> ;</code></pre></div>
<h3 id="クラスへのポインター">クラスへのポインター</h3>
<p>クラスへのポインターはいままでに学んだものと同じ文法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C { } ;

<span class="dt">int</span> main()
{
    C object ;
    C * pointer = &amp;object ;
} </code></pre></div>
<p>ただし、ポインターを経由してメンバーにアクセスするのが曲者だ。</p>
<p>以下のようなメンバーにアクセスするコードがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
    <span class="dt">int</span> data_member ;
    <span class="dt">void</span> member_function() {}
} ;

<span class="dt">int</span> main()
{
    C object ;

    object.data_member = <span class="dv">0</span> ;
    object.member_function() ;
}</code></pre></div>
<p>これをポインターを経由して書いてみよう。</p>
<p>以下のように書くとエラーだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    C object ;
    C * pointer = &amp;object ;

    <span class="co">// エラー</span>
    *pointer.data_member = <span class="dv">0</span> ;
    <span class="co">// エラー</span>
    *pointer.member_function() ;
}</code></pre></div>
<p>この理由は演算子の優先順位の問題だ。上の式は以下のように解釈される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">*(pointer.data_member) = <span class="dv">0</span> ;
*(pointer.member_function()) ;</code></pre></div>
<p>ポインターを参照する演算子<code>*</code>よりも、演算子ドット(<code>'.'</code>)の方が演算子の優先順位が高い。</p>
<p>このような式を可能にする変数<code>pointer</code>とは以下のようなものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Pointer
{
    <span class="dt">int</span> data  = <span class="dv">42</span> ;
    <span class="dt">int</span> * data_member = &amp;data ;
    <span class="dt">int</span> * member_function()
    {
        <span class="kw">return</span> &amp;data ;
    }
} ;

<span class="dt">int</span> main()
{
    Pointer pointer ;

    *pointer.data_member = <span class="dv">0</span>;
    *pointer.member_function() ;
}</code></pre></div>
<p><code>pointer.data_member</code>はポインターなのでそれに演算子<code>*</code>を適用して参照した上で<code>0</code>を代入している。</p>
<p><code>pointer.member_function()</code>は関数呼び出しで戻り値としてポインターを返すのでそれに演算子<code>*</code>を適用している。</p>
<p>演算子<code>*</code>を先にポインターの値である<code>pointer</code>に適用するには、括弧を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">(*pointer).data_member = <span class="dv">0</span> ;
(*pointer).member_function() ;</code></pre></div>
<p>リファレンスを使ってポインターを参照した結果をリファレンスに束縛して使うこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">C &amp; ref = *pointer ;
ref.data_member = <span class="dv">0</span> ;
ref.member_function() ;</code></pre></div>
<p>ただし、ポインターを介してクラスを扱う際に、毎回括弧を使ったりリファレンスを使ったりするのは面倒なので、簡単なシンタックスシュガーとして演算子<code>-&gt;</code>が用意されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pointer-&gt;data_member = <span class="dv">0</span> ;
pointer-&gt;member_function() ;</code></pre></div>
<p><code>a-&gt;b</code>は、<code>(*(a))-&gt;b</code>と同じ意味になる。そのため、上は以下のコードと同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
(*(pointer)).data_member = <span class="dv">0</span> ;
(*(pointer)).member_function() ;</code></pre></div>
<h3 id="thisポインター">thisポインター</h3>
<p>メンバー関数はクラスのデータメンバーにアクセスできる。このときのデータメンバーはメンバー関数が呼ばれたクラスのオブジェクトのサブオブジェクトになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
    <span class="dt">int</span> data { } ;

    <span class="dt">void</span> set( <span class="dt">int</span> n )
    {
        data = n ;
    }
} ;

<span class="dt">int</span> main()
{
    C a ;
    C b ;

    <span class="co">// a.dataを変更</span>
    a.set(<span class="dv">1</span>) ;
    <span class="co">// b.dataを変更</span>
    b.set(<span class="dv">2</span>) ;
}</code></pre></div>
<p>すでに説明したように、メンバー関数が自分を呼び出したクラスのオブジェクトのサブオブジェクトを参照できるのは、クラスのオブジェクトへの参照を知っているからだ。内部的には以下のような隠し引数を持つコードが生成されたかのような挙動になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// コンパイラーが生成するコードのたとえ</span>
<span class="kw">struct</span> C
{
    <span class="dt">int</span> data { } ;
} ;

<span class="co">// 隠し引数</span>
<span class="dt">void</span> set( C &amp; obj, <span class="dt">int</span> n )
{
    obj.data = n ;
}</code></pre></div>
<p>つまり、メンバー関数は自分を呼び出したクラスのオブジェクトへの参照を知っている。その参照にアクセスする方法が<code>this</code>キーワードだ。</p>
<p><code>this</code>キーワードはクラスのメンバー関数の中で使うと、メンバー関数を呼び出したクラスのオブジェクトへのポインターとして扱われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
    <span class="dt">int</span> data { } ;

    <span class="dt">void</span> set( <span class="dt">int</span> n )
    {
        <span class="co">// このメンバー関数を呼び出したクラスのオブジェクトへのポインター</span>
        C * pointer = <span class="kw">this</span> ;
        <span class="kw">this</span>-&gt;data = n ;
    }
} ;</code></pre></div>
<p>先ほど、関数<code>C::set</code>の中で<code>data = n ;</code>と書いたのは、<code>this-&gt;data = n ;</code>と書いたのと同じ意味になる。</p>
<p><code>this</code>はリファレンスではなくてポインターだ。この理由は歴史的なものだ。本来ならばリファレンスの方がよいのだが、いまさら変更できないのでポインターになっている。わかりにくければリファレンスに束縛してもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> f()
    {
        <span class="kw">auto</span> &amp; this_ref = *<span class="kw">this</span> ;
    }
} ;</code></pre></div>
<p><code>const</code>なメンバー関数の中では、<code>this</code>の型も<code>const</code>なクラス型へのポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">void</span> f()
    {
        <span class="co">// thisの型はS *</span>
        S * pointer = <span class="kw">this</span> ;
    }

    <span class="dt">void</span> f() <span class="dt">const</span>
    {
        <span class="co">// thisの型はS const *</span>
        S <span class="dt">const</span> * pointer = <span class="kw">this</span> ;
    }
} ;</code></pre></div>
<p>この理由は、<code>const</code>なメンバー関数はクラスのオブジェクトへの参照として<code>const</code>なリファレンスを隠し引数として持つからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// コンパイラーが生成するコードのたとえ</span>
<span class="kw">struct</span> S { } ;

<span class="co">// 非constなメンバー関数</span>
<span class="dt">void</span> f( S &amp; obj ) ;

<span class="co">// constなメンバー関数</span>
<span class="dt">void</span> f( S <span class="dt">const</span> &amp; obj ) ;</code></pre></div>
<h3 id="メンバーへのポインター">メンバーへのポインター</h3>
<p>メンバーへのポインターはかなり文法的にややこしい。そもそも、通常のポインターとは概念でも実装でも異なる。</p>
<p>ここで取り扱うのはメンバーへのポインターという概念で、クラスのオブジェクトのサブオブジェクトへのポインターではない。サブオブジェクトへのポインターは通常のポインターと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Object
{
    <span class="co">// サブオブジェクト</span>
    <span class="dt">int</span> subobject ;
} ;

<span class="dt">int</span> main()
{
    <span class="co">// クラスのオブジェクト</span>
    Object object ;

    <span class="co">// サブオブジェクトへのポインター</span>
    <span class="dt">int</span> * pointer = &amp;object.subobject ;

    *pointer = <span class="dv">123</span> ;
    <span class="dt">int</span> read = object.subobject ;
}</code></pre></div>
<p>メンバーへのポインターとは、クラスのデータメンバーやメンバー関数を参照するもので、クラスのオブジェクトとともに使うことでそのデータメンバーやメンバー関数を参照できるものだ。</p>
<p>細かい文法の解説はあとにして例を見せよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Object
{
    <span class="dt">int</span> data_member ;
    <span class="dt">void</span> member_function()
    { std::cout &lt;&lt; data_member ; }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Object::data_memberメンバーへのポインター</span>
    <span class="dt">int</span> Object::* int_ptr = &amp;Object::data_member ;
    <span class="co">// Object::member_functionメンバーへのポインター</span>
    <span class="dt">void</span> (Object::* func_ptr)() = &amp;Object::member_function ;

    <span class="co">// クラスのオブジェクト</span>
    Object object ;

    <span class="co">// objectに対するメンバーポインターを介した参照</span>
    object.*int_ptr = <span class="dv">123</span> ;
    <span class="co">// objectに対するメンバーポインターを介した参照</span>
    <span class="co">// 123</span>
    (object.*func_ptr)() ;

    <span class="co">// 別のオブジェクト</span>
    Object another_object ;
    another_object.data_member = <span class="dv">456</span> ;
    <span class="co">// 456</span>
    (another_object.*func_ptr)() ;
}</code></pre></div>
<p>細かい文法はあとで学ぶとして、肝心の機能としてはこうだ。クラスのオブジェクトからは独立したデータメンバーやメンバー関数自体へのポインターを取得する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Object
{
    <span class="dt">int</span> data_member ;
} ;

<span class="co">// メンバーへのポインター</span>
<span class="dt">int</span> Object::*int_ptr = &amp;Object::data_member ; </code></pre></div>
<p>このポインターをクラスのオブジェクトと組み合わせることで、ポインターが参照するクラスのメンバーで、かつオブジェクトのサブオブジェクトの部分を参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Object object ;

<span class="co">// メンバーへのポインターをオブジェクトに適用してサブオブジェクトを参照する</span>
object.*int_ptr = <span class="dv">123</span> ;</code></pre></div>
<p>では文法の説明に入ろう。</p>
<p>メンバーへのポインターは文法がややこしい。</p>
<p>あるクラス名<code>C</code>の型名<code>T</code>のメンバーへのポインター型は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">型名 クラス名::*
T C::*</code></pre></div>
<p>以下のクラスの各データメンバーへの型はそれぞれコメントのとおりになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> ABC
{
    <span class="co">// int ABC::*</span>
    <span class="dt">int</span> x ;
    <span class="co">// int ABC::*</span>
    <span class="dt">int</span> y ;
    <span class="co">// double ABC::*</span>
    <span class="dt">double</span> d ;
    <span class="co">// int * ABC::*</span>
    <span class="dt">int</span> * ptr ;
} ;

<span class="kw">struct</span> DEF
{
    <span class="co">// ABC * DEF::*</span>
    ABC * abc ;
} ;</code></pre></div>
<p>順を追って説明していこう。まずクラス<code>ABC</code>のメンバー、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int ABC::*</span>
<span class="dt">int</span> x ;
<span class="co">// int ABC::*</span>
<span class="dt">int</span> y ;</code></pre></div>
<p>このメンバーへのポインターの型はどちらも<code>int ABC::*</code>になる。データメンバーの型は<code>int</code>で、クラス名が<code>ABC</code>なので、<code>型名 クラス名::*</code>に当てはめると<code>int ABC::*</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// double ABC::*</span>
<span class="dt">double</span> d ;</code></pre></div>
<p>このメンバーへのポインターの型は<code>double ABC::*</code>になる。</p>
<p>最後のクラス<code>ABC</code>のメンバー、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int * ABC::*</span>
<span class="dt">int</span> * ptr ;</code></pre></div>
<p>これが<code>int * ABC::*</code>になる理由も、最初に説明した<code>型名 クラス名::*</code>のルールに従っている。型名が<code>int *</code>、クラス名が<code>ABC</code>なので、<code>int * ABC::*</code>だ。</p>
<p>最後の例はクラス<code>DEF</code>のメンバーとしてクラス<code>ABC</code>のポインター型のメンバーだ。<code>ABC DEF::*</code>になる。</p>
<p>クラス名<code>C</code>のメンバー名<code>M</code>のメンバーへのポインターを得るには以下の文法を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">&amp;クラス名::メンバー名
&amp;C::M</code></pre></div>
<p>具体的な例を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="dt">int</span> y = <span class="dv">2</span> ;
} ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> C::* x_ptr = &amp;C::x ;
    <span class="dt">int</span> C::* y_ptr = &amp;C::y ;

    C object ;

    <span class="co">// 1</span>
    std::cout &lt;&lt; object.*x_ptr ;
    <span class="co">// 2 </span>
    std::cout &lt;&lt; object.*y_ptr ;
}</code></pre></div>
<p>わかりづらければエイリアス宣言を使うとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="dt">int</span> C::* ;
type x_ptr = &amp;C::x ;</code></pre></div>
<p>あるいは<code>auto</code>を使うという手もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int C::*</span>
<span class="kw">auto</span> x_ptr = &amp;C::x ;</code></pre></div>
<p>メンバー関数へのポインターは、メンバーへのポインターと関数へのポインターを組み合わせた複雑な文法となるので、とてもわかりづらい。</p>
<p>復習すると、<code>int</code>型の引数を1つ受け取り<code>int</code>型の戻り値を返す関数へのポインターの型は<code>int (*)(int)</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f(<span class="dt">int</span>) { <span class="kw">return</span> <span class="dv">0</span> ; }
<span class="dt">int</span> (*ptr)(<span class="dt">int</span>) = &amp;f ;</code></pre></div>
<p>この関数がクラス<code>C</code>のメンバー関数の場合、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
    <span class="dt">int</span> f(<span class="dt">int</span>) { <span class="kw">return</span> <span class="dv">0</span> ; }
} ;</code></pre></div>
<p>ところで、メンバーへのポインターは<code>型名 クラス名::*</code>だった。この2つを組み合わせると、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
    <span class="dt">int</span> f(<span class="dt">int</span>) { <span class="kw">return</span> <span class="dv">0</span> ; }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// メンバー関数へのポインター</span>
    <span class="dt">int</span> (C::*ptr)(<span class="dt">int</span>) = &amp;C::f ;
    <span class="co">// クラスのオブジェクト</span>
    C object ;

    <span class="co">// オブジェクトを指定したメンバー関数へのポインターを介した関数呼び出し</span>
    (object.*ptr)( <span class="dv">123</span> ) ;
}</code></pre></div>
<p>メンバー関数へのポインターは難しい。</p>
<p>関数<code>f</code>の型は<code>int (int)</code>で、そのポインターの型は<code>int (*)(int)</code>だ。するとクラス名<code>C</code>のメンバー関数<code>f</code>へのポインターの型は、<code>int (C::*)(int)</code>になる。</p>
<p>メンバー関数へのポインター型の変数を宣言してその値を<code>C::f</code>へのポインターに初期化しているのが以下の行だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// メンバー関数へのポインター</span>
<span class="dt">int</span> (C::*ptr)(<span class="dt">int</span>) = &amp;C::f ;</code></pre></div>
<p>この<code>ptr</code>を経由したメンバー関数<code>f</code>の呼び出し方だが、まずクラスのオブジェクトが必要になるので作る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">C object ;</code></pre></div>
<p>そして演算子の<code>operator .*</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">(object.*ptr)(<span class="dv">123</span>) ;</code></pre></div>
<p><code>object.*ptr</code>を括弧で囲んでいるのは、演算子の優先順位のためだ。もしこれを以下のように書くと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">object.*ptr(<span class="dv">123</span>)</code></pre></div>
<p>これは<code>ptr(123)</code>という式を評価した結果をメンバーへのポインターと解釈してクラスのオブジェクトを介して参照していることになる。例えば以下のようなコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C { <span class="dt">int</span> data { } ; } ;

<span class="kw">auto</span> ptr( <span class="dt">int</span> ) -&gt; <span class="dt">int</span> C::*
{ <span class="kw">return</span> &amp;C::data ; }

<span class="dt">int</span> main()
{
    C object ;
    object.*ptr(<span class="dv">123</span>) ;
}</code></pre></div>
<p>演算子の優先順位の問題のために、<code>(object.*ptr)</code>と括弧で包んで先に評価させ、その後に関数呼び出し式である<code>(123)</code>を評価させる。</p>
<p>実は演算子<code>operator .*</code>のほかに、<code>operator -&gt;*</code>という演算子がある。</p>
<p><code>.*</code>はクラスのオブジェクトがリファレンスの場合の演算子だが、<code>-&gt;*</code>はクラスのオブジェクトがポインターの場合の演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C{ <span class="dt">int</span> data { } ; } ;

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> data_ptr = &amp;C::data ;

    C object ;
    <span class="kw">auto</span> c_ptr = &amp;object ;

    c_ptr-&gt;*data_ptr = <span class="dv">123</span> ;
}</code></pre></div>
<p>演算子<code>a-&gt;b</code>が<code>(*(a)).b</code>となるように、演算子<code>a-&gt;*b</code>も<code>(*(a)).*b</code>と置き換えられるシンタックスシュガーだ。</p>
<p>上の例で、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">c_ptr-&gt;*object = <span class="dv">123</span> ;</code></pre></div>
<p>は、以下と同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">(*(c_ptr)).*object = <span class="dv">123</span> ;</code></pre></div>
<p><code>.*</code>や<code>-&gt;*</code>の文法を覚えるのが面倒な場合、標準ライブラリに<code>std::invoke( f, t1, ... )</code>という便利な関数が用意されている。</p>
<p><code>f</code>がデータメンバーへのポインターで、<code>t1</code>がクラスのオブジェクトの場合、<code>std::invoke(f, t1)</code>は以下のような関数になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> F, <span class="kw">typename</span> T1 &gt;
適切な戻り値の型 std::invoke( F f, T1 t1 )
{
    <span class="kw">return</span> t1.*f ;
}</code></pre></div>
<p>なので以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C { <span class="dt">int</span> data { } ; } ;

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> data_ptr = &amp;C::data ;

    C object ;

    <span class="co">// どちらも同じ意味</span>
    object.*data_ptr = <span class="dv">123</span> ;
    std::invoke( data_ptr, object ) = <span class="dv">123</span> ;
}</code></pre></div>
<p>便利なことに<code>t1</code>がポインターの場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> F, <span class="kw">typename</span> T1 &gt;
適切な戻り値の型 std::invoke( F f, T1 t1 )
{
    <span class="kw">return</span> (*(t1)).*f ;
}</code></pre></div>
<p>という関数として振る舞う。そのため、リファレンスでもポインターでも気にせずに使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">C * c_ptr = &amp;object ;

<span class="co">// どちらも同じ意味</span>
c_ptr-&gt;*data_ptr = <span class="dv">123</span> ;
std::invoke( data_ptr, c_ptr ) = <span class="dv">123</span> ;</code></pre></div>
<p><code>std::invoke</code>がさらにすごいことに、メンバー関数へのポインターにも対応している。</p>
<p><code>std::invoke( f, t1, ... )</code>で、<code>f</code>がメンバー関数へのポインターで、<code>t1</code>がクラスのオブジェクトへのリファレンスで、<code>...</code>が関数呼び出しの際の引数の場合、以下のような関数として振る舞う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> F, <span class="kw">typename</span> T1,
    <span class="co">// まだ知らない機能</span>
    <span class="kw">typename</span> ... Ts &gt;
適切な戻り値の型
invoke( F f, T1 t1,
<span class="co">// まだ知らない機能</span>
Ts ... ts )
{
    <span class="kw">return</span> (t1.*f)(ts...)
}</code></pre></div>
<p>厳密にはこの宣言は間違っているのだが、まだ知らない機能を使っているので気にしなくてもよい。大事なことは、<code>std::invoke</code>の第三引数以降の実引数が、関数呼び出しの実引数として使われるということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
    <span class="dt">int</span> f0() { <span class="kw">return</span> <span class="dv">0</span> ; }
    <span class="dt">int</span> f1(<span class="dt">int</span>) { <span class="kw">return</span> <span class="dv">1</span> ; } 
    <span class="dt">int</span> f2( <span class="dt">int</span>, <span class="dt">int</span> ) { <span class="kw">return</span> <span class="dv">2</span> ; }
} ;

<span class="dt">int</span> main()
{
    C object ;

    <span class="co">// 同じ</span>
    (object.*&amp;C::f0)() ;
    std::invoke( &amp;C::f0, object ) ;
    <span class="co">// 同じ</span>
    (object.*&amp;C::f1)(<span class="dv">1</span>) ;
    std::invoke( &amp;C::f1, object, <span class="dv">1</span>) ;
    <span class="co">// 同じ</span>
    (object.*&amp;C::f2)(<span class="dv">1</span>,<span class="dv">2</span>) ;
    std::invoke( &amp;C::f2, object, <span class="dv">1</span>,<span class="dv">2</span>) ;
}</code></pre></div>
<p>この場合も、<code>object</code>が<code>C</code>へのリファレンスではなく、<code>C</code>へのポインターでも自動で認識していいように処理してくれる。</p>
<h2 id="ポインターの内部実装">ポインターの内部実装</h2>
<p>ポインターの意味上と文法上の解説は終えた。ここからはポインターの内部実装についてだ。ポインターの値とは外でもない、メモリー上のアドレスのことだ。</p>
<h3 id="キロバイトとキビバイト">キロバイトとキビバイト</h3>
<p>メモリーとアドレスについて解説する前に、キロバイト(Kilo byte)とキビバイト(Kibi byte)の違いについて解説する。</p>
<p>キロ(Kilo)というのはSI接頭語で、<span class="math inline">\(1000^1\)</span>を意味する。1キロは1000だ。SI接頭語にはほかにもメガ(Mega, <span class="math inline">\(1000^2\)</span>)、ギガ(Giga, <span class="math inline">\(1000^3\)</span>)やテラ(Tera, <span class="math inline">\(1000^4\)</span>)などの接頭語もある。</p>
<p>長さ1キロメートルは1000メートルで、重さ1キログラムは1000グラムだ。</p>
<p>いま「このCPUのクロック周波数は1GHzだ」と言ったとき、それは<span class="math inline">\(1000^3\)</span>Hz = <span class="math inline">\(1000000000\)</span>Hzのことだ。</p>
<p>しかし、メモリー容量だけは慣習的に<span class="math inline">\(1000^n\)</span>ではなく、<span class="math inline">\(1024^n\)</span>を使う。</p>
<p>一般人が「このメモリーは1KBだ」と言ったとき、それは1024バイトのことだ。1GBのメモリーは<span class="math inline">\(1024^3 バイト = 1073741824 バイト\)</span>だ。筆者が本書を執筆するのに使ったラップトップコンピューターは32GBのメモリーを積んでいるがこれは34359738368バイトだ。</p>
<p>メモリーの容量が10進数ではなく2進数で数えられているのは、メモリーは2進数で扱うのがハードウェア的に都合がいいからだ。そのため、慣習的にキロは<span class="math inline">\(1000^1\)</span>ではなく<span class="math inline">\(1024^1\)</span>を意味するようになってしまった。</p>
<p>このため、IEEE 1541では10進SI接頭語と対になる2進接頭語を定義した。</p>
<table>
<thead>
<tr class="header">
<th align="left">接頭語</th>
<th align="left">値</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">キビ(kibi, Ki)</td>
<td align="left"><span class="math inline">\(2^{10}\)</span></td>
</tr>
<tr class="even">
<td align="left">メビ(mebi, Mi)</td>
<td align="left"><span class="math inline">\(2^{20}\)</span></td>
</tr>
<tr class="odd">
<td align="left">ギビ(gibi, Gi)</td>
<td align="left"><span class="math inline">\(2^{30}\)</span></td>
</tr>
<tr class="even">
<td align="left">テビ(tebi, Ti)</td>
<td align="left"><span class="math inline">\(2^{40}\)</span></td>
</tr>
<tr class="odd">
<td align="left">ペビ(pebi, Pi)</td>
<td align="left"><span class="math inline">\(2^{50}\)</span></td>
</tr>
<tr class="even">
<td align="left">エクスビ(exbi, Ei)</td>
<td align="left"><span class="math inline">\(2^{60}\)</span></td>
</tr>
</tbody>
</table>
<p>本書では1KBは1000バイトで、1KiBが1024バイトを意味する。</p>
<h3 id="メモリーとアドレス">メモリーとアドレス</h3>
<p>コンピューターにはメモリーやストレージと呼ばれる記憶領域がある。情報の最小単位はすでに学んだようにビットだが、情報をビット単位で扱うのは不便なので、慣習的に複数の連続したビットを束ねたバイトという単位で扱っている。1バイトはほとんどのアーキテクチャで8ビットだ。メモリーは複数の連続したバイト列で成り立っている。</p>
<p>この連続したバイト列の中の任意の1バイトを指し示すのがアドレスだ。メモリーのバイト列の最初の1バイトのアドレスを0とし、次の1バイトアドレスを1とし、以降、その次を前のアドレスに1加えた値にしてみよう。</p>
<p>そのようなメモリーとアドレスのコンピューターでは、1バイトの符号なし整数で表現されたアドレスは、256バイトのメモリーの中の任意の1バイトをアドレスとして参照することができる。</p>
<p>これはとても抽象化された計算機で、現実の計算機はもっと複雑な実装になっている。しかしC++の規格としては、メモリーとはフラットな連続したバイト列であって、その任意の各バイトをアドレスから参照可能だという想定になっている。</p>
<p>アドレスが1バイトの符号なし整数で表現され、そのすべてのビットが使われる場合、256バイトの連続したメモリーをアドレス可能だ。</p>
<p>アドレスが2バイトならば、64KiBのメモリーをアドレス可能だ。</p>
<p>アドレスが4バイトならば、4GiBのメモリーをアドレス可能だ。</p>
<p>アドレスが8バイトならば、16EiBのメモリーをアドレス可能だ。</p>
<p>ポインターの値というのは、このアドレスの値のことだ。</p>
<h3 id="ポインターのサイズ">ポインターのサイズ</h3>
<p>ポインターの値というのはアドレスの値だ。ポインターの値を格納するのにもメモリーが必要だ。ではポインターのサイズは何バイトあるのだろう。</p>
<p>型<code>T</code>のサイズを調べるには<code>sizeof(T)</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> T &gt;
<span class="dt">void</span> print_size()
{
    std::cout &lt;&lt; <span class="kw">sizeof</span>(T) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    print_size&lt;<span class="dt">int</span> *&gt;() ;
    print_size&lt;<span class="dt">double</span> *&gt;() ;

    <span class="co">// ポインターへのポインター</span>
    print_size&lt;<span class="dt">int</span> **&gt;() ; 
}</code></pre></div>
<p>筆者の環境でこのプログラムを実行した結果は以下のようになった。</p>
<pre><code>8
8
8</code></pre>
<p>どうやら筆者の環境ではポインターのサイズはすべて8バイトらしい。</p>
<h3 id="ポインターの値">ポインターの値</h3>
<p>ポインターが8バイト、つまり64ビットの値であるならば、それを8バイトの符号なし整数として解釈した値はどうなるのだろう。</p>
<p>C++にはすべてのポインターの値を格納できるサイズの符号なし整数型が用意されている。<code>std::uintptr_t</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="kw">sizeof</span>( std::uintptr_t ) ;
}</code></pre></div>
<p>筆者の環境でこのプログラムを実行した結果も<code>8</code>が出力される。</p>
<p>ポインターも<code>std::uintptr_t</code>も8バイトだ。ポインターのバイト列を<code>std::uintptr_t</code>として強引に解釈すれば、符号なし整数としての値を出力してみよう。</p>
<p>ある値<code>from</code>のバイト列を、同じバイト数のある型<code>to</code>の値として強引に解釈するC++20で追加された標準ライブラリに、<code>std::bit_cast&lt;to&gt;(from)</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;bit&gt;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> data {} ;
    std::cout &lt;&lt; std::bit_cast&lt;std::uintptr_t&gt;(&amp;data) ;
}</code></pre></div>
<p>このプログラムを何度か実行した結果、以下のような結果を得た。</p>
<pre><code>$ make run
140725678382588
$ make run
140721510940268
$ make run
140731669632396</code></pre>
<p>私の環境ではポインターの具体的な値は実行ごとに異なる。これは私の使っているOSがASLR(Address Space Layout Randomization)を実装しているためだ。興味のある読者は調べてみるとよい。</p>
<p>この値は<code>int</code>型の変数<code>data</code>のポインターの整数としての値だ。このアドレスの場所に、<code>int</code>型のオブジェクトの最初の1バイトがあり、その次の場所に次の1バイトがある。</p>
<p>筆者の環境では<code>int</code>型は4バイトだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="kw">sizeof</span>(<span class="dt">int</span>) ;
}</code></pre></div>
<p><code>int</code>型のオブジェクトは4バイトの連続したメモリー上に構築されている。つまり、本質的には以下のようなコードと同等になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::byte data[<span class="dv">4</span>] ;
    std::cout &lt;&lt; std::bit_cast&lt;std::uintptr_t&gt;(&amp;data[<span class="dv">0</span>]) ;
}</code></pre></div>
<p><code>std::byte</code>というのは<code>sizeof(std::byte)</code>の結果が1になる、サイズが1バイトの符号なし整数型だ。</p>
<p><code>std::byte</code>はC++で1バイトの生の値を表現するために使うことができる。配列は連続したバイト列なので、4バイトの<code>int</code>型は、本質的には上のようなコードになる。ただし上のコードはアライメントという概念が欠けている。これについてはあとで説明する。</p>
<p>ところで、<code>std::bit_cast</code>は2020年に制定される国際標準規格C++20から入った。しかるに筆者がこの文章を書いているのは2018年だ。まだC++20を完全に実装したC++コンパイラーは存在しない。この本が出版されてしばらくは、読者の手元にもC++20コンパイラーは存在しないだろう。</p>
<h3 id="stdbit_castの実装"><code>std::bit_cast</code>の実装</h3>
<p>ないものは自分で実装すればいい。<code>std::bit_cast</code>に近いものを実装してみよう。</p>
<p>今回実装する<code>bit_cast</code>は以下のような関数テンプレートだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> To, <span class="kw">typename</span> From &gt;
To bit_cast( From <span class="dt">const</span> &amp; from )
{
    <span class="co">// 値fromのバイト列をTo型の値として解釈して返す。</span>
}</code></pre></div>
<p><code>bit_cast</code>の実装にはポインターが必要だ。<code>From</code>の値を表現するバイト列への先頭のポインターを取り、バイト単位で<code>To</code>の値を表現するバイト列にコピーすればよい。</p>
<p>標準ライブラリにはそのような処理を行ってくれる<code>std::memcpy(dest, src, n)</code>がある。ポインター<code>src</code>から<code>n</code>バイトをポインター<code>dest</code>から<code>n</code>バイトに書き込む関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> To, <span class="kw">typename</span> From &gt;
To bit_cast( From <span class="dt">const</span> &amp; from )
{
    To to ;
    std::memcpy( &amp;to, &amp;from, <span class="kw">sizeof</span>(To) ) ;
    <span class="kw">return</span> to ;
}</code></pre></div>
<p>これで<code>std::bit_cast</code>の実装はできた。しかしこの実装は問題を<code>std::memcpy</code>にたらい回しにしただけだ。<code>std::memcpy</code>も実装できて初めて<code>std::bit_cast</code>を自前で実装できたと言える。</p>
<h3 id="stdmemcpyの実装"><code>std::memcpy</code>の実装</h3>
<p><code>std::memcpy</code>はC++コンパイラーによって効率のよいコードに置き換えられる。そのため自分で実装した<code>std::memcpy</code>を標準ライブラリと同じ効率にすることは難しいが、機能的にはほとんど同じものを作ることができる。</p>
<p><code>memcpy</code>の実装にはポインターの詳細な理解が必要だ。</p>
<p><code>std::memcpy</code>関数は以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * memcpy( <span class="dt">void</span> * dest, <span class="dt">void</span> <span class="dt">const</span> * src, std::size_t n )
{
    <span class="co">// srcの先頭バイトからnバイトを</span>
    <span class="co">// destの先頭バイトからのバイト列にコピーし</span>
    <span class="co">// destを返す</span>
}</code></pre></div>
<p>見慣れない<code>void *</code>という型が出てきた。まずはこれについて学ぼう。</p>
<h4 id="void型">void型</h4>
<p><code>void</code>は特別な型だ。<code>void</code>型は何も値を持たない型という意味を持つ。例えば関数が戻り値を何も返さない場合、<code>void</code>型を返す関数として宣言される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 何も値を返さない関数</span>
<span class="dt">void</span> f()
{
    <span class="co">// 何も値を返さない</span>
    <span class="kw">return</span> ;
}</code></pre></div>
<p>あらゆる値は<code>void</code>型に変換することができる。変換した結果は、何も値を持たない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">void</span>&gt;(<span class="dv">123</span>) ;
}</code></pre></div>
<p>C++17では、<code>void</code>型の変数は作れない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="dt">void</span> x ;</code></pre></div>
<p>ところで、読者が本書を読むころには、C++規格では<code>void</code>型の変数が作れるようになっているかもしれない。これは<code>void</code>型だけ変数を作れないのが面倒だから作れるようになるだけで、具体的な値のない変数になる。</p>
<h4 id="void-型">void *型</h4>
<p><code>void *</code>型は「<code>void</code>型へのポインター型」だ。<code>int *</code>が「<code>int</code>型へのポインター型」であるのと同じだ。</p>
<p><code>void *</code>型の値は、ある型<code>T</code>へのポインター型から型<code>T</code>という情報が消え去ったポインターの値だ。ポインターの値というのはアドレスで、アドレスというのは単なるバイト単位のメモリーを指す整数値だということを学んだ。<code>void *</code>型は特定の型を意味しないポインター型だ。</p>
<p>ある型<code>T</code>へのポインター型の値は、<code>void *</code>型に変換できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> data { } ;

    <span class="co">// int *からvoid *への変換</span>
    <span class="dt">void</span> * ptr = &amp;data ;
}</code></pre></div>
<p><code>void *</code>型の値<code>e</code>から元の型<code>T</code>へのポインターに変換するには<code>static_cast&lt;T *&gt;(e)</code>が必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> data { } ;
    <span class="dt">void</span> * void_ptr = &amp;data ;

    <span class="dt">int</span> * int_ptr = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> *&gt;(void_ptr) ;
}</code></pre></div>
<p>もし<code>static_cast&lt;T *&gt;(e)</code>の<code>e</code>が<code>T *</code>として妥当なアドレスの値であれば、変換後も正しく動く。</p>
<p><code>T const *</code>型は<code>void const *</code>型に変換できる。その逆変換もできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> data {} ;
    <span class="dt">int</span> <span class="dt">const</span> * int_const_ptr = &amp;data ;
    <span class="dt">void</span> <span class="dt">const</span> * void_const_ptr = int_const_ptr ;
    <span class="dt">int</span> <span class="dt">const</span> * original = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> <span class="dt">const</span> *&gt;(void_const_ptr) ;
}</code></pre></div>
<p>ポインター間の型変換で<code>const</code>を消すことはできない。</p>
<p><code>memcpy</code>は<code>void *</code>を使うことで、どんなポインターの値でも取れるようにしている。C++にはテンプレートがあるので以下のように宣言してもよいのだが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Dest, <span class="kw">typename</span> Src &gt;
Dest * memcpy( Dest * dest, Src <span class="dt">const</span> * src, std::size_t n ) ;</code></pre></div>
<p><code>memcpy</code>はC++以前からあるC言語ライブラリなので、こうなっている。</p>
<h4 id="stdbyte型">std::byte型</h4>
<p><code>void *</code>型はアドレスだけを意味するポインター型なので、参照することができない。<code>memcpy</code>の実装にはポインターを経由して参照先を1バイトずつ読み書きする必要がある。そのための型として<code>std::byte</code>がある。</p>
<p><code>std::byte</code>型は1バイトを表現するための型だ。<code>sizeof(std::byte)</code>の結果は<code>1</code>になる。</p>
<p>1バイトというのは10進数で<span class="math inline">\(0 \leqq n \leqq 255\)</span>までの値を扱う。</p>
<p><code>std::byte</code>はとても厳格に1バイトの符号なし整数として振る舞うので、普通の整数で初期化や代入をすることができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
std::byte a = <span class="dv">123</span> ;
std::byte b(<span class="dv">123</span>) ;

<span class="co">// これもエラー</span>
a = <span class="dv">123</span> ;</code></pre></div>
<p><code>std::byte</code>に具体的な値で初期化するには<code>{x}</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::byte a{<span class="dv">123</span>} ;</code></pre></div>
<p><code>std::byte</code>に値を代入するには<code>std::byte{x}</code>を使う</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::byte a ;
a = std::byte{<span class="dv">123</span>} ;</code></pre></div>
<p><code>static_cast&lt;std::byte&gt;(x)</code>や<code>std::byte(x)</code>はコンパイルできるが、使ってはならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 使ってはならない</span>
std::byte a = <span class="kw">static_cast</span>&lt;std::byte&gt;(<span class="dv">123</span>) ;
std::byte b = std::byte(<span class="dv">123</span>) ;</code></pre></div>
<p>なぜ使ってはならないかというと、範囲外の値を無理やり変換してしまうからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::byte a = <span class="kw">static_cast</span>&lt;std::byte&gt;(<span class="dv">256</span>) ;
std::byte b = std::byte(<span class="dv">-1</span>) ;</code></pre></div>
<h4 id="配列のメモリー上での表現">配列のメモリー上での表現</h4>
<p>配列は要素型を表現するバイト列をメモリー上に連続して配置する。</p>
<p>例えば<code>int [3]</code>という配列があり、<code>sizeof(int)</code>が<code>4</code>の場合、全体で12バイトのメモリーが確保される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> data[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;</code></pre></div>
<p>最初の4バイト（0バイト目から3バイトまで）の領域は0番目の要素である<code>data[0]</code>で、その値は<code>1</code>だ。</p>
<p>次の4バイト（4バイト目から7バイト目まで）の領域は1番目の要素である<code>data[1]</code>で、その値は<code>2</code>だ。</p>
<p>最後の4バイト（8バイト目から11バイト目まで）の領域は2番目の要素である<code>data[2]</code>で、その値は<code>3</code>だ。</p>
<div class="figure">
<img src="fig-kurema/fig30-01.svg" />

</div>
<p>実際にアドレスの生の値を出力して確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 生のアドレスを出力する関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> print_raw_address( T ptr )
{
    std::cout &lt;&lt; std::bit_cast&lt;std::uintptr_t&gt;(ptr) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> data[<span class="dv">3</span>] = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>} ;
    print_raw_address( &amp;data[<span class="dv">0</span>] ) ;
    print_raw_address( &amp;data[<span class="dv">1</span>] ) ;
    print_raw_address( &amp;data[<span class="dv">2</span>] ) ;
}</code></pre></div>
<p>このプログラムを筆者の環境で実行すると以下のように出力された。</p>
<pre><code>140736120015884
140736120015888
140736120015892</code></pre>
<p>筆者の環境では<code>sizeof(int)</code>は4だ。<code>&amp;data[0]</code>の生のアドレスに4を足した値が<code>&amp;data[1]</code>になっていることがわかる。</p>
<h4 id="ポインターと整数の演算">ポインターと整数の演算</h4>
<p>ポインターと整数を加減算することができる。</p>
<p>ポインター<code>T *</code>に整数<code>n</code>を足すと、ポインターのアドレスが<code>sizeof(T) * n</code>加算される。この結果、ポインターは要素が配列のように配置された場合に<code>n</code>個先の要素を指すようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> print_raw_address( T ptr )
{
    std::cout &lt;&lt; std::bit_cast&lt;std::uintptr_t&gt;(ptr) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">4</span>] = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="co">// 0個目の要素へのポインター</span>
    <span class="dt">int</span> * a0 = &amp;a[<span class="dv">0</span>] ;
    print_raw_address( a0 ) ;
    

    <span class="co">// アドレスがsizeof(int) * 3加算される</span>
    <span class="co">// a3は3個目の要素へのポインター</span>
    <span class="dt">int</span> * a3 = a0 + <span class="dv">3</span> ;
    print_raw_address( a3 ) ;

    <span class="co">// アドレスがsizeof(int) * 2減算される。</span>
    <span class="co">// a1は1個目の要素へのポインター</span>
    <span class="dt">int</span> * a1 = a3 - <span class="dv">2</span> ;
    print_raw_address( a1 ) ;
}</code></pre></div>
<p>これを筆者の環境で実行すると以下のように出力された。</p>
<pre><code>140722117900224
140722117900236
140722117900228</code></pre>
<p>最初の値が<code>a0</code>, 次の値が<code>a3</code>, 最後の値が<code>a1</code>だ。</p>
<p>筆者の環境では<code>sizeof(int)</code>は<code>4</code>だ。すると<code>a3</code>の値は<code>a0</code>の値より12多い値になっているはずだ。実際にそうなっている。<code>a1</code>は<code>a3</code>に対して8少ない値になっているはずだ。実際にそうなっている。</p>
<h4 id="いよいよmemcpyの実装">いよいよmemcpyの実装</h4>
<p>これまで学んできたことをすべて使い、ようやく<code>memcpy</code>が実装できる。</p>
<ol style="list-style-type: decimal">
<li><code>dest</code>を<code>std::byte *</code>型に変換する</li>
<li><code>src</code>を<code>std::byte const *</code>型に変換する</li>
<li><code>src</code>の参照先から<code>n</code>バイトを<code>dest</code>の参照先にコピーする</li>
<li><code>dest</code>を返す</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * memcpy( <span class="dt">void</span> * dest, <span class="dt">void</span> <span class="dt">const</span> * src, std::size_t n )
{
    <span class="co">// destをstd::byte *型に変換</span>
    <span class="kw">auto</span> d = <span class="kw">static_cast</span>&lt;std::byte *&gt;(dest) ;
    <span class="co">// srcをstd::byte const *型に変換する</span>
    <span class="kw">auto</span> s = <span class="kw">static_cast</span>&lt;std::byte <span class="dt">const</span> *&gt;(src) ;

    <span class="co">// srcからnバイトコピーするのでnバイト先のアドレスを得る </span>
    <span class="kw">auto</span> last = s + n ;

    <span class="co">// nバイトコピーする</span>
    <span class="kw">while</span> ( s != last )
    {
        *d = *s ;
        ++d ;
        ++s ;
    }

    <span class="co">// destを返す</span>
    <span class="kw">return</span> dest ;
}</code></pre></div>
<h4 id="memcpyの別の実装">memcpyの別の実装</h4>
<p>ポインターは<code>operator []</code>に対応している。</p>
<p>ポインター<code>p</code>と整数<code>i</code>に対して<code>p[i]</code>と書いたとき、<code>*(p + i)</code>という意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">5</span>] = {<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>} ;
    <span class="dt">int</span> * p = &amp;a[<span class="dv">0</span>] ;

    p[<span class="dv">0</span>] ; <span class="co">// 0</span>
    p[<span class="dv">2</span>] ; <span class="co">// 2</span>

    <span class="dt">int</span> * p2 = &amp;p[<span class="dv">2</span>] ;
    p2[<span class="dv">1</span>] ; <span class="co">// 3</span>
}</code></pre></div>
<p><code>memcpy</code>は<code>operator []</code>を使って書くこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * memcpy( <span class="dt">void</span> * dest, <span class="dt">void</span> <span class="dt">const</span> * src, std::size_t n )
{
    <span class="kw">auto</span> d = <span class="kw">static_cast</span>&lt;std::byte *&gt;(dest) ;
    <span class="kw">auto</span> s = <span class="kw">static_cast</span>&lt;std::byte <span class="dt">const</span> *&gt;(src) ;

    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != n ; ++i )
    {
        d[i] = s[i] ;
    }

    <span class="kw">return</span> dest ;
}</code></pre></div>
<h3 id="データメンバーへのポインターの内部実装">データメンバーへのポインターの内部実装</h3>
<p>データメンバーへのポインターの整数としての値は少し変わっている。</p>
<p>ポインターの生の値は、メモリー上で値を表現しているバイト列の先頭アドレスだ。</p>
<p>データメンバーへのポインターは、具体的なクラスのオブジェクトへのポインターやリファレンスがあって初めて意味がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S { <span class="dt">int</span> x = <span class="dv">123</span> ; } ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> data = <span class="dv">123</span> ;
    <span class="dt">int</span> * ptr = &amp;data ;
    <span class="co">// ptr単体で参照できる</span>
    <span class="dt">int</span> read1 = *ptr ;

    S object ;
    <span class="dt">int</span> S::* mem_ptr = &amp;S::x ;
    <span class="co">// objectとmem_ptrの2つで参照できる</span>
    <span class="dt">int</span> read2 = object.*mem_ptr ;

}</code></pre></div>
<p>配列が要素型のバイト列を連続して配置したメモリーレイアウトをしているように、クラスもデータメンバーを連続して配置したメモリーレイアウトをしている。</p>
<p>たとえば以下のようなクラス<code>Object</code>がある場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Object
{
    <span class="dt">int</span> x ;
    <span class="dt">int</span> y ;
    <span class="dt">int</span> z ;
} ;</code></pre></div>
<p>このクラスのサイズは<code>sizeof(Object)</code>だ。このクラスは<code>int</code>型のサブオブジェクトを3つ持っているので、そのサイズは少なくとも<code>size(int)*3</code>はある。</p>
<p>実際に確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Object
{
    <span class="dt">int</span> x ;
    <span class="dt">int</span> y ;
    <span class="dt">int</span> z ;
} ;

<span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;sizeof(int): &quot;</span> &lt;&lt; <span class="kw">sizeof</span>(<span class="dt">int</span>) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;

    std::cout &lt;&lt; <span class="st">&quot;sizeof(Object): &quot;</span> &lt;&lt; <span class="kw">sizeof</span>(Object) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このプログラムを筆者の環境で実行すると以下のように出力された。</p>
<pre><code>sizeof(int): 4
sizeof(Object): 12</code></pre>
<p><code>int</code>型のサイズが<code>4</code>で、<code>Object</code>型のサイズが<code>12</code>ということは、クラス<code>Object</code>には<code>int</code>型のサブオブジェクトが3つ、隙間なく連続して配置されているということだ。すべてのクラスがこうではないが、今回の私の環境ではそうなっている。</p>
<p>全体で12バイトということは、配列<code>int [3]</code>と同じように、最初の4バイトに<code>x</code>, <code>y</code>, <code>z</code>のどれかが、次の4バイトに残りのどちらかが、最後の4バイトに残りが配置されている。</p>
<p>データメンバーへのポインターというのは、このクラスのオブジェクトを表現するバイト列の先頭から何バイト目に配置されているかというオフセット値になっている。</p>
<p>具体的な値を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> print_raw_address( T ptr )
{
    std::cout &lt;&lt; bit_cast&lt;std::uintptr_t&gt;(ptr) &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="kw">struct</span> Object
{
    <span class="dt">int</span> x ;
    <span class="dt">int</span> y ;
    <span class="dt">int</span> z ;
} ;

<span class="dt">int</span> main()
{
    print_raw_address( &amp;Object::x ) ;
    print_raw_address( &amp;Object::y ) ;
    print_raw_address( &amp;Object::z ) ;
}</code></pre></div>
<p>このプログラムを筆者の環境で実行すると以下のように出力される。</p>
<pre><code>0
4
8</code></pre>
<p>筆者の環境では、<code>x</code>はクラスの先頭アドレスからオフセット0バイトに、<code>y</code>はオフセット4バイトに、<code>z</code>はオフセット8バイトに配置されているようだ。</p>
<p>確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Object
{
    <span class="dt">int</span> x = <span class="dv">123</span> ;
    <span class="dt">int</span> y = <span class="dv">456</span> ;
    <span class="dt">int</span> z = <span class="dv">789</span> ;
} ;

<span class="dt">int</span> main()
{

    Object object ;

    <span class="co">// クラスのオブジェクトの先頭アドレス</span>
    std::byte * start = bit_cast&lt;std::byte *&gt;(&amp;object) ;
    <span class="co">// オフセット0</span>
    <span class="dt">int</span> * x = bit_cast&lt;<span class="dt">int</span> *&gt;(start + <span class="dv">0</span>) ;
    <span class="co">// オフセット4</span>
    <span class="dt">int</span> * y = bit_cast&lt;<span class="dt">int</span> *&gt;(start + <span class="dv">4</span>) ;
    <span class="co">// オフセット8</span>
    <span class="dt">int</span> * z = bit_cast&lt;<span class="dt">int</span> *&gt;(start + <span class="dv">8</span>) ;

    std::cout &lt;&lt; *x &lt;&lt; *y &lt;&lt; *z ;
}</code></pre></div>
<p>筆者の環境では以下のように出力される</p>
<pre><code>123456789</code></pre>
<p>このプログラムの実行結果は環境によって変わる。読者の使っている環境でデータメンバーへのポインターが筆者の環境と同じように実装されているとは限らない。</p>
<h1 id="イテレーター詳細">イテレーター詳細</h1>
<h2 id="イテレーターとポインターの関係">イテレーターとポインターの関係</h2>
<p><code>array</code>のイテレーターの実装を振り返ろう。前回実装したイテレーターは、リファレンスとインデックスを使うものだった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; Array &gt;
<span class="kw">struct</span> array_iterator
{
    <span class="kw">using</span> reference = <span class="kw">typename</span> Array::reference ;

    Array &amp; a ;
    std::size_t i ;

    array_iterator( Array * a, std::size_t i )
        : a(a), i(i) { }

    reference <span class="kw">operator</span> *() <span class="dt">const</span>
    { <span class="kw">return</span> a[i] ; }

    array_iterator &amp; <span class="kw">operator</span> ++()
    {
        ++i ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }

    reference <span class="kw">operator</span> [] ( std::size_t n )
    { <span class="kw">return</span> a[i + n] ; }
} ;</code></pre></div>
<p>このコードは単にポインターをクラスで実装しているだけではないだろうか。ならば、ポインターでイテレーターを実装することもできるのではないか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Array &gt;
<span class="kw">struct</span> array_iterator
{
    <span class="kw">using</span> pointer = <span class="kw">typename</span> Array::pointer ;
    <span class="kw">using</span> reference = <span class="kw">typename</span> Array::reference ;
    pointer p ;

    array_iterator( pointer p )
        : p(p) { }

    reference <span class="kw">operator</span> *()
    { <span class="kw">return</span> *p ; }

    array_iterator &amp; <span class="kw">operator</span> ++()
    {
        ++p ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }

    reference <span class="kw">operator</span>[] ( std::size_t n )
    { <span class="kw">return</span> p[n] ; }
} ;</code></pre></div>
<p>このコードは本当にポインターをクラスで実装しているだけだ。ならばイテレータークラスの代わりにポインターでもいいのではないだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{

    T storage[N] ;

    <span class="co">// ポインター</span>
    <span class="kw">using</span> iterator = T * ;

    iterator begin()
    { <span class="kw">return</span> &amp;storage[<span class="dv">0</span>] ;  }

    iterator end()
    { <span class="kw">return</span> begin() + N ; }
} ;</code></pre></div>
<p>これは動く。そして実際の<code>std::array</code>の実装もこうなっている。</p>
<p>実はイテレーターはポインターを参考にして作られた。インクリメントで次の要素を参照、<code>operator *</code>で参照先の要素にアクセスといった操作は、すべてポインターの操作をより抽象化したものだ。</p>
<p>ポインターの操作をすべてサポートしたイテレーターは、ランダムアクセスイテレーターと呼ばれる。</p>
<h2 id="イテレーターカテゴリー">イテレーターカテゴリー</h2>
<p>イテレーターにはサポートしている操作に応じて以下のような種類が存在する。</p>
<ul>
<li>入力イテレーター(Input Iterator)</li>
<li>出力イテレーター(Output Iterator)</li>
<li>前方イテレーター(Forward Iterator)</li>
<li>双方向イテレーター(Bidirectional Iterator)</li>
<li>ランダムアクセスイテレーター(Random Access Iterator)</li>
</ul>
<p>イテレーターの関係は以下のようになっている。</p>
<div class="figure">
<img src="fig-kurema/fig31-01.svg" />

</div>
<p>矢印<code>A → B</code>は<code>A</code>が<code>B</code>であることを意味している。</p>
<p>ランダムアクセスイテレーターは双方向イテレーターのすべての操作をサポートする。故にランダムアクセスイテレーターは双方向イテレーターである。</p>
<p>同様に、双方向イテレーターは前方イテレーターである。前方イテレーターは入力イテレーター/出力イテレーターである。</p>
<p><code>A</code>は<code>B</code>であることに加えて、追加の操作をサポートしている。</p>
<h3 id="ランダムアクセスイテレーター">ランダムアクセスイテレーター</h3>
<p>ランダムアクセスイテレーターは名前のとおりランダムアクセスができる。イテレーターが<code>n</code>番目の要素を指すとき、<code>n+m</code>番目の要素を指すことができる。<code>m</code>は負数でもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;
<span class="dt">void</span> f( RandomAccessIterator i, <span class="dt">int</span> n  )
{
    i + n ;
    i - n ;
    n + i ; <span class="co">// i+nと同じ</span>
    n - i ; <span class="co">// n-iと同じ</span>

    i + (-n) ; <span class="co">// i - nと同じ</span>

    <span class="co">// i = i + n ; と同じ</span>
    i += n ;
    <span class="co">// i = i - n ; と同じ</span>
    i -= n ;
}</code></pre></div>
<p>と書ける。<code>n</code>の型が符号付き整数型でよい。<code>i + (-5)</code>は<code>i-5</code>と同じ意味だ。</p>
<p>イテレーター間の距離を計算したいときはイテレーター同士を引き算する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;
<span class="dt">void</span> f( RandomAccessIterator a, RandomAccessIterator b )
{
    b - a ; <span class="co">// aからbまでの距離</span>
    a - b ; <span class="co">// bからaまでの距離</span>
}</code></pre></div>
<p>イテレーター間の距離は負数にもなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;
<span class="dt">void</span> f( RandomAccessIterator a )
{
    <span class="kw">auto</span> b = a ;
    <span class="co">// bはaより3進んでいる</span>
    ++b ; ++b ; ++b ;
    b - a ; <span class="co">// 3</span>
    a - b ; <span class="co">// -3</span>
}</code></pre></div>
<p>イテレーター<code>b</code>は<code>a</code>より3進んでいるので、<code>a</code>から<code>b</code>までの距離である<code>b - a</code>は3になる。では<code>b</code>から<code>a</code>までの距離である<code>a - b</code>はどうなるかというと、<span class="math inline">\(-3\)</span>になる。<code>b</code>にとって<code>a</code>は3戻っているからだ。</p>
<p>イテレーター <code>i</code>の<code>n</code>個先の要素を参照したい場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;
<span class="dt">void</span> f( RandomAccessIterator i, std::size_t n )
{
    <span class="co">// *(i + n) ; と同じ</span>
    i[n] ;
}</code></pre></div>
<p>と書ける。</p>
<p>ランダムアクセスイテレーターは大小比較ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> RandomAccessIterator &gt;
<span class="dt">void</span> f( RandomAccessIterator i, RandomAccessIterator j )
{
    i   &lt;   j ;
    i   &gt;   j ;
    i   &lt;=  j ;
    i   &gt;=  j ;
}</code></pre></div>
<p>イテレーターの比較は、イテレーターが参照する要素の値の比較ではない。イテレーターが参照する要素の順番の比較だ。</p>
<p><code>n</code>番目の要素を参照するイテレーターは、<code>n+1</code>番目の要素を参照するイテレーターより小さい。<code>n-1</code>番目を参照するイテレーターより大きい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    <span class="co">// jはn+1番目を指す</span>
    <span class="kw">auto</span> j = i + <span class="dv">1</span> ;

    i &lt; j ; <span class="co">// true</span>
    i &gt; j ; <span class="co">// false</span>
}</code></pre></div>
<p>ここまでの操作はランダムアクセスイテレーターにしかできない。</p>
<p>双方向イテレーター以下のイテレーターができる比較は同値比較だけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i, Iterator j )
{
    i == j ;
    i != j ;
}</code></pre></div>
<p>イテレーターは同じ<code>n</code>番目の要素を指しているときに等しいと比較される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    <span class="kw">auto</span> j = i ;
    i == j ;    <span class="co">// true</span>
    ++j ;
    i = j ;     <span class="co">// false</span>
}</code></pre></div>
<h3 id="双方向イテレーター">双方向イテレーター</h3>
<p>双方向イテレーターは名前のとおり双方向のイテレーターの移動ができる。双方向というのはイテレーターが参照している<code>n</code>番目の要素の<code>n-1</code>番目の要素と<code>n+1</code>番目の要素だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> BidirectionalIterator &gt;
<span class="dt">void</span> f( BidirectionalIterator i )
{
    ++i ; <span class="co">// i+1</span>
    --i ; <span class="co">// i-1</span>

    <span class="co">// r1, r2は変更する前のiの値</span>
    <span class="kw">auto</span> r1 = i++ ;
    <span class="kw">auto</span> r2 = i-- ;
}</code></pre></div>
<p>と書ける。この操作は前方イテレーターにはできない。</p>
<p>1個ずつ移動できるのであれば、イテレーターを<code>n</code>個進めることもできそうなものだ。実際、双方向イテレーターを以下のようにして<code>n</code>個進めることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> BidirectionalIterator &gt;
BidirectionalIterator
nth_next( BidirectionalIterator iter, std::size_t n )
{
    <span class="kw">for</span> ( std::size_t i = <span class="dv">0</span> ; i != n ; ++i )
        ++iter ;
    <span class="kw">return</span> iter ;
}</code></pre></div>
<p>確かにこれはできる。できるが、効率的ではない。双方向イテレーターが提供される場合というのは、ランダムアクセスが技術的に可能ではあるが非効率的な場合だ。具体的なデータ構造を出すと、例えばリンクリストがある。リンクリストに対するランダムアクセスは技術的に可能であるが非効率的だ。</p>
<h3 id="前方イテレーター">前方イテレーター</h3>
<p>前方イテレーターは前方にしか移動できない。イテレーターが0番目の要素を指しているならば1番目、1番目の要素を指しているならば2番目に移動できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator &gt;
<span class="dt">void</span> f( ForwardIterator i )
{
    ++i ;
}</code></pre></div>
<p>前方イテレーターにはマルチパス保証がある。イテレーターの指す要素を動かす前のイテレーターの値を保持しておき、保持した値を動かしたとき、2つのイテレーターは同一になるという保証だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator &gt;
<span class="dt">void</span> f( ForwardIterator i )
{
    <span class="co">// 動かす前の値を保持</span>
    <span class="kw">auto</span> prev = i ;
    <span class="co">// 次の要素を指す</span>
    ++i ;
    <span class="co">// 動かす前の値も次の要素を指すようにする</span>
    ++prev ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b = ( i == prev ) ;

    <span class="co">// r1, r2は同じ要素を指す</span>
    <span class="kw">auto</span> &amp; r1 = *i ;
    <span class="kw">auto</span> &amp; r2 = *prev ;
}</code></pre></div>
<p>入力イテレーター、出力イテレーターにはこの保証がない。</p>
<h3 id="入力イテレーター">入力イテレーター</h3>
<p>入力イテレーターはイテレーターの比較、イテレーターの参照、イテレーターのインクリメントができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> InputIterator &gt;
<span class="dt">void</span> f( InputIterator i, InputIterator j )
{
    <span class="co">// 比較</span>
    <span class="dt">bool</span> b1 = (i == j) ;
    <span class="dt">bool</span> b2 = (i != j) ;

    <span class="co">// 参照</span>
    *i ;
    <span class="co">// (*i).m と同じ</span>
    i-&gt;m ;

    <span class="co">// インクリメント</span>
    ++i ;
    i++ ;
}</code></pre></div>
<p>入力イテレーターの参照は、読み込みことしか保証されていない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> InputIterator &gt;
<span class="dt">void</span> f( InputIterator i )
{
    <span class="co">// OK</span>
    <span class="kw">auto</span> value = *i ;
    <span class="co">// エラー</span>
    *i = value ;
}</code></pre></div>
<p>書き込みは出力イテレーターの仕事だ。</p>
<h3 id="出力イテレーター">出力イテレーター</h3>
<p>出力イテレーターはイテレーターのインクリメントと、イテレーターの参照への代入ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> OutputIterator &gt;
<span class="dt">void</span> f( OutputIterator i, <span class="kw">typename</span> OutputIterator::value_type v )
{
    <span class="co">// 参照への代入</span>
    *i = v ;

    <span class="co">// インクリメント</span>
    ++i ;
    i++ ;
}</code></pre></div>
<p>出力イテレーターを参照した結果は定められていない。<code>void</code>かもしれない。したがって出力イテレーターの値を読むのは意味がない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> OutputIterator &gt;
<span class="dt">void</span> f( OutputIterator i )
{
    <span class="co">// 意味がない</span>
    <span class="kw">auto</span> value = *i ;
}</code></pre></div>
<h2 id="iterator_traits">iterator_traits</h2>
<p>イテレーターカテゴリーやイテレーターの参照する値を見分けるためのライブラリとして、<code>iterator_traits&lt;T&gt;</code>がある。これは以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iterator
{
    <span class="kw">using</span> difference_type = ... ;
    <span class="kw">using</span> value_type = ... ;
    <span class="kw">using</span> pointer = ... ;
    <span class="kw">using</span> reference = ... ;
    <span class="kw">using</span> iterator_category = ... ;

} ;

}</code></pre></div>
<p><code>difference_type</code>はイテレーター同士の距離を指す数値だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i, Iterator j )
{
    <span class="co">// イテレーター同士の距離</span>
    <span class="kw">typename</span> std::iterator_traits&lt;Iterator&gt;::difference_type diff = j - i ;
}</code></pre></div>
<p><code>value_type</code>はイテレーターの参照する値の型、<code>pointer</code>はそのポインター型、<code>reference</code>はそのリファレンス型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    <span class="co">// 値型</span>
    <span class="kw">typename</span> std::iterator_traits&lt;Iterator&gt;::value_type v = *i ;
    <span class="co">// ポインター型 </span>
    <span class="kw">typename</span> std::iterator_traits&lt;Iterator&gt;::pointer p = &amp;v ;
    <span class="co">// リファレンス型</span>
    <span class="kw">typename</span> std::iterator_traits&lt;Iterator&gt;::reference r = v ;
}</code></pre></div>
<p><code>iterator_category</code>はイテレーターカテゴリーを示す型で、以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">struct</span> input_iterator_tag { };
<span class="kw">struct</span> output_iterator_tag { };
<span class="kw">struct</span> forward_iterator_tag: <span class="kw">public</span> input_iterator_tag { };
<span class="kw">struct</span> bidirectional_iterator_tag: <span class="kw">public</span> forward_iterator_tag { };
<span class="kw">struct</span> random_access_iterator_tag: <span class="kw">public</span> bidirectional_iterator_tag { };
}</code></pre></div>
<p><code>forward_iterator_tag</code>以降のコロン文字のあとに続くコードについては、いまは気にしなくてもよい。これは派生というまだ説明していないクラスの機能だ。</p>
<p>あるイテレーターがあるイテレーターカテゴリーを満たすかどうかを調べるには以下のようにする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> tag, <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_category_of( )
{
    <span class="kw">using</span> iter_tag = <span class="kw">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category ;
    <span class="kw">return</span> std::is_base_of_v&lt; tag, iter_tag&gt; ;
}


<span class="dt">int</span> main()
{
    <span class="kw">using</span> iterator = std::vector&lt;<span class="dt">int</span>&gt;::iterator ;
    <span class="dt">bool</span> b = is_category_of&lt; std::forward_iterator_tag, iterator &gt;() ;
    <span class="co">// vectorのイテレーターはランダムアクセスイテレーターなので前方イテレーターでもある</span>
    std::cout &lt;&lt; b ;
}</code></pre></div>
<p>このコードはまだ学んでいないC++の機能をふんだんに使っているので、現時点で理解するのは難しい。</p>
<h2 id="イテレーターカテゴリーの実例">イテレーターカテゴリーの実例</h2>
<p>イテレーターカテゴリーについて学んだので、イテレーターカテゴリーの実例について見ていこう。</p>
<h3 id="出力イテレーター-1">出力イテレーター</h3>
<p>前方イテレーター以上のイテレーターカテゴリーを満たすイテレーターはすべて、出力イテレーターとして使える。例えば<code>std::array</code>の内容を<code>std::vector</code>にコピーしたければ以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">5</span>) ;

    std::copy( std::begin(a), std::end(a), std::begin(v) ) ;
}</code></pre></div>
<p><code>std::vector</code>のイテレーターは出力イテレーターとして振る舞う。</p>
<p>出力イテレーターの要件しか満たさないイテレーターは、例えば以下のようなものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> cout_iterator
{
<span class="co">// --- ボイラープレートコード</span>
    <span class="co">// 出力イテレーターでは使わないのでvoidでいい</span>
    <span class="kw">using</span> difference_type = <span class="dt">void</span> ;
    <span class="kw">using</span> value_type = <span class="dt">void</span> ;
    <span class="kw">using</span> reference = <span class="dt">void</span> ;
    <span class="kw">using</span> pointer = <span class="dt">void</span> ;
    <span class="co">// イテレーターカテゴリーは出力イテレーター</span>
    <span class="kw">using</span> iterator_category = std::output_iterator_tag ;
    <span class="co">// 何もしない</span>
    <span class="co">// 自分自身を返すだけ</span>
    cout_iterator &amp; <span class="kw">operator</span> *() { <span class="kw">return</span> *<span class="kw">this</span> ; }
    cout_iterator &amp; <span class="kw">operator</span> ++() { <span class="kw">return</span> *<span class="kw">this</span> ; }
    cout_iterator &amp; <span class="kw">operator</span> ++(<span class="dt">int</span>) { <span class="kw">return</span> *<span class="kw">this</span> ; }
<span class="co">// --- ボイラープレートコード</span>

    <span class="co">// ここが肝心</span>
    <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
    cout_iterator &amp; <span class="kw">operator</span> =( T <span class="dt">const</span> &amp; x )
    {
        std::cout &lt;&lt; x ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
} ;


<span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    cout_iterator out ;

    std::copy( std::begin(v), std::end(v), out ) ;
}</code></pre></div>
<p><code>cout_iterator</code>は<code>*i = x;</code>と書いたときに、値<code>x</code>を<code>std::cout</code>で出力する。</p>
<p><code>cout_iterator</code>は出力イテレーターの要件を満たすので<code>std::copy</code>に渡せる。<code>std::copy</code>はイテレーターを順番に<code>*out = *i ;</code>のように実行するので、結果として値がすべて<code>std::cout</code>で出力される。</p>
<p><code>cout_iterator</code>はとても便利なので、標準ライブラリには<code>std::ostream_iterator&lt;T&gt;</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::ostream_iterator&lt;<span class="dt">int</span>&gt; out(std::cout) ;
    std::copy( std::begin(v), std::end(v), out ) ;
}</code></pre></div>
<p><code>ostream_iterator</code>は出力ストリーム(<code>ostream</code>)に対するイテレーターだ。コンストラクターに出力先の出力ストリームを渡すことで値を出力先に出力してくれる。今回は<code>std::cout</code>だ。</p>
<p>上のような出力イテレーターが<code>operator =</code>で以下のようなことをしていたらどうだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="kw">struct</span> back_inserter
{
    back_inserter( Container &amp; c )
        : c(c) { }

    <span class="co">// その他のボイラープレートコード</span>

    
    back_inserter &amp; <span class="kw">operator</span> =( <span class="dt">const</span> <span class="kw">typename</span> Container::value_type &amp; value )
    {
        c.push_back(value) ;
    }

    Container &amp; c ;
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">void</span> f( Container <span class="dt">const</span> &amp; c )
{
    <span class="co">// cの全要素をコピーしたい</span>
    std::vector&lt; <span class="kw">typename</span> Container::value_type &gt; temp ;
    <span class="kw">auto</span> out = back_inserter(temp) ;
    std::copy( std::begin(c), std::end(c), out ) ;
}</code></pre></div>
<p>このコードが何をするかわかるだろうか。コンテナー<code>c</code>の全要素を出力イテレーターで出力する。出力イテレーターは渡された値<code>value</code>を<code>temp.push_back(value) ;</code>する。その結果、<code>temp</code>は<code>c</code>のすべての要素を保持していることになる。</p>
<p>C++の標準ライブラリには<code>std::back_inserter</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; temp ;
    <span class="kw">auto</span> out = std::back_inserter(temp) ;

    std::copy( std::begin(v), std::end(v), out ) ;
}</code></pre></div>
<p><code>std::back_inserter(c)</code>はコンテナー<code>c</code>に出力イテレーターとして渡された値を<code>puch_back</code>する。</p>
<p>ただし、<code>std::back_inserter</code>は古いライブラリなので、ここで示した方法とは少し違う実装がされている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 出力イテレーター</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="kw">struct</span> back_insert_iterator
{
    back_insert_iterator( Container &amp; c )
        : c(&amp;c) { }
    Container * c ;

    <span class="co">// その他のコード</span>
} ;

<span class="co">// 出力イテレーターを返す関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
back_insert_iterator&lt;Container&gt; back_inserter( Container &amp; c )
{
    <span class="kw">return</span> back_insert_iterator&lt;Container&gt;(c) ;
}</code></pre></div>
<p>この理由は、C++17以前のC++ではクラスのコンストラクターからテンプレート実引数の推定ができなかったためだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T ) { }

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> S
{
    S( T ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// f&lt;int&gt;と推定</span>
    f(<span class="dv">0</span>) ;

    <span class="co">// S&lt;int&gt;と推定</span>
    S s(<span class="dv">0</span>) ;
}</code></pre></div>
<p>C++17以前のC++では関数の実引数からテンプレート仮引数<code>T</code>の型を推定することはできたが、クラスのコンストラクターから推定することはできなかった。C++17以降は可能だ。</p>
<p><code>std::cout</code>に出力したり、コンテナーに<code>push_back</code>する実装のイテレーターは、マルチパス保証を満たさない。実装を見ればわかるように、イテレーターをコピーして別々にインクリメントした結果のイテレーターのオブジェクトに対する操作は同一ではないからだ。</p>
<h3 id="入力イテレーター-1">入力イテレーター</h3>
<p>入力イテレーターの実例はどうか。</p>
<p><code>std::cin</code>から<code>T</code>型を読み込む入力イテレーターの実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> cin_iterator
{
<span class="co">// --- ボイラープレートコード</span>
    <span class="kw">using</span> difference_type = std::ptrdiff_t ;
    <span class="kw">using</span> value_type = T ;
    <span class="kw">using</span> reference = T &amp; ;
    <span class="kw">using</span> pointer = T * ;
    <span class="co">// イテレーターカテゴリーは入力イテレーター</span>
    <span class="kw">using</span> iterator_category = std::input_iterator_tag ;
<span class="co">// --- ボイラープレートコード</span>

    <span class="co">// コンストラクター</span>
    cin_iterator( <span class="dt">bool</span> fail = <span class="kw">false</span> )
        : fail(fail)
    { ++*<span class="kw">this</span> ; }    

    <span class="co">// キャッシュした値を返す</span>
    <span class="dt">const</span> reference <span class="kw">operator</span> *() <span class="dt">const</span>
    { <span class="kw">return</span> value ; }

    <span class="co">// 新しい値をキャッシュする</span>
    cin_iterator &amp; <span class="kw">operator</span> ++()
    {
        <span class="kw">if</span> ( !fail )
        {
            std::cin &gt;&gt; value ;
            fail = std::cin.fail() ;
        }
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }

    <span class="co">// 後置インクリメント</span>
    cin_iterator <span class="kw">operator</span> ++(<span class="dt">int</span>)
    {
        <span class="kw">auto</span> old = *<span class="kw">this</span> ;
        ++*<span class="kw">this</span> ;
        <span class="kw">return</span> old ;
    }

    <span class="co">// イテレーターの等価比較の状態</span>
    <span class="dt">bool</span> fail ;
    <span class="co">// 値のキャッシュ</span>
    value_type value ;
} ;

<span class="co">// 比較演算子</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">bool</span> <span class="kw">operator</span> ==( cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; r )
{ <span class="kw">return</span> l.fail == r.fail ; }

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">bool</span> <span class="kw">operator</span> !=( cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; r )
{ <span class="kw">return</span> !(l == r) ; }</code></pre></div>
<p>以下のように使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    cin_iterator&lt;<span class="dt">int</span>&gt; input, fail(<span class="kw">true</span>) ;
    std::vector&lt;<span class="dt">int</span>&gt; buffer ;

    std::copy( input, fail, std::back_inserter(buffer) ) ;
}</code></pre></div>
<p>実装としては、まずボイラープレートコード</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> difference_type = std::ptrdiff_t ;
<span class="kw">using</span> value_type = T ;
<span class="kw">using</span> reference = T &amp; ;
<span class="kw">using</span> pointer = T * ;
<span class="co">// イテレーターカテゴリーは入力イテレーター</span>
<span class="kw">using</span> iterator_category = std::input_iterator_tag ;</code></pre></div>
<p><code>difference_type</code>はイテレーターの距離を表現する型で、通常は<code>std::ptrdiff_t</code>という型が使われる。これはポインターの距離を表現する型だ。</p>
<p><code>value_type</code>は参照している要素の型、<code>reference</code>と<code>pointer</code>は要素に対するリファレンスとポインターだ。</p>
<p><code>iterator_category</code>は今回は入力イテレーターなので<code>std::input_iterator_tag</code>になる。</p>
<p>データメンバーが2つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> fail ;
value_type value ;</code></pre></div>
<p><code>fail</code>は<code>std::cin</code>が失敗状態のときに<code>true</code>になる。通常は<code>false</code>だ。<code>std::cin</code>が失敗状態かどうかは、メンバー関数<code>fail</code>で確かめることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b = std::cin.fail() ;
}</code></pre></div>
<p><code>std:cin</code>が失敗状態になる理由はいくつかあるが、EOFが入力された場合や、指定した型の値を読み込めなかった場合、例えば<code>int</code>型を読み込むのに入力が<code>&quot;abcd&quot;</code>のような文字列だった場合に<code>true</code>になる。</p>
<p><code>value</code>は<code>std::cin</code>から読み込んだ値だ。</p>
<p>イテレーターから値を読み込むのは<code>operator *</code>の仕事だ。これは単に<code>value</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> reference <span class="kw">operator</span> *() <span class="dt">const</span>
{ <span class="kw">return</span> value ; }</code></pre></div>
<p>入力イテレーターでは値の読み込みのみをサポートしている。書き込みはサポートしない。イテレーター <code>i</code>に対して<code>*i</code>は書けるが、<code>*i = x</code>とは書けない。</p>
<p>実際に<code>std::cin</code>から値を読み込むのは<code>operator ++</code>で行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">cin_iterator &amp; <span class="kw">operator</span> ++()
{
    <span class="co">// 失敗状態でなければ</span>
    <span class="kw">if</span> ( !fail )
    {
        <span class="co">// 値を読み込む</span>
        std::cin &gt;&gt; value ;
        <span class="co">// 失敗状態かどうかも調べる</span>
        fail = std::cin.fail() ;
    }
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<p>まず<code>std::cin</code>が失敗状態でないかどうかを確認する。失敗状態となった<code>std::cin</code>からは読み込めないからだ。失敗状態でなければ値を読み込み、失敗状態かどうかを確認する。結果の値は<code>value</code>に、失敗状態かどうかは<code>fail</code>に保持される。</p>
<p>後置インクリメントは前置インクリメントを呼び出すだけの汎用的な実装だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">cin_iterator <span class="kw">operator</span> ++(<span class="dt">int</span>)
{
    <span class="co">// 元の値をコピーし</span>
    <span class="kw">auto</span> old = *<span class="kw">this</span> ;
    <span class="co">// 次の値を読み込み</span>
    ++*<span class="kw">this</span> ;
    <span class="co">// 元の値を返す</span>
    <span class="kw">return</span> old ;
}</code></pre></div>
<p>コンストラクターに<code>true</code>を渡すと、イテレーターを最初から失敗状態にしておく</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">cin_iterator( <span class="dt">bool</span> fail = <span class="kw">false</span> )
    : fail(fail)
{ ++*<span class="kw">this</span> ; }    </code></pre></div>
<p>コンストラクターは最初の値を読み込むために自分自身にインクリメントを呼び出す。</p>
<p>入力イテレーターは同値比較ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">bool</span> <span class="kw">operator</span> ==( cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; r )
{ <span class="kw">return</span> l.fail == r.fail ; }

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">bool</span> <span class="kw">operator</span> !=( cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; l, cin_iterator&lt;T&gt; <span class="dt">const</span> &amp; r )
{ <span class="kw">return</span> !(l == r) ; }</code></pre></div>
<p>イテレーターが同値比較できると、イテレーターが終了条件に達したかどうかの判定ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> InputIterator &gt;
<span class="dt">void</span> print( InputIterator iter, InputIterator end_iter )
{
    <span class="co">// 終了条件に達するまで</span>
    <span class="kw">while</span> ( iter != end_iter )
    {   <span class="co">// 値を標準出力する</span>
        std::cout &lt;&lt; *iter ;
        ++iter ;
    }
}</code></pre></div>
<p>このような関数<code>print</code>に、<code>vector</code>の<code>begin</code>/<code>end</code>を渡すと、<code>vector</code>の要素をすべて標準出力する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    print( std::begin(v), std::end(v) ) ;
}</code></pre></div>
<p><code>cin_iterator</code>を渡した場合、失敗状態になるまで標準出力する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    cin_iterator iter, fail(<span class="kw">true</span>) ;
    print( iter, fail )
}</code></pre></div>
<p><code>cin_iterator</code>が比較するのは<code>std::cin</code>の失敗状態の有無だ。この比較によって、<code>cin_iterator</code>で標準入力から失敗するまで値を読み込み続けることができる。</p>
<p>このようなイテレーターは標準に<code>std::istream_iterator&lt;T&gt;</code>として存在する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::istream_iterator&lt;<span class="dt">int</span>&gt; iter( std::cin ), end_iter ;
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    std::copy( iter, end_iter, std::back_inserter(v) ) ;
}</code></pre></div>
<p>標準ライブラリは読み込むストリームをコンストラクターで取る。何も指定しない場合は失敗状態になる。</p>
<h3 id="前方イテレーター-1">前方イテレーター</h3>
<p>前方イテレーター以上のイテレーターの例として、<code>iota_iterator&lt;T&gt;</code>を実装してみよう。</p>
<p>このイテレーターは<code>T</code>型の整数を保持し、<code>operator *</code>でリファレンスを返し、<code>operator ++</code>でインクリメントする。</p>
<p>以下のように使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    iota_iterator iter(<span class="dv">0</span>) ;
    *iter ; <span class="co">// 0</span>
    *++iter ; <span class="co">// 1</span>
    *++iter ; <span class="co">// 2</span>

    iota_iterator first(<span class="dv">0</span>), last(<span class="dv">10</span>) ;

    <span class="co">// 0123456789と出力される</span>
    std::for_each( first, last,
        [](<span class="kw">auto</span> i){ std::cout &lt;&lt; i ;}
    ) ;

    std::vector&lt;<span class="dt">int</span>&gt; v ;
    std::copy( first, last, std::back_inserter(v) ) ;
    <span class="co">// vは{0,1,2,3,4,5,6,7,8,9}</span>
}</code></pre></div>
<p>さっそく実装してみよう。まずはネストされた型名と初期化から。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iota_iterator
{
    <span class="co">// イテレーター同士の距離を表現する型</span>
    <span class="kw">using</span> difference_type = std::ptrdiff_t ;
    <span class="co">// 要素の型</span>
    <span class="kw">using</span> value_type = T ;
    <span class="kw">using</span> reference = T &amp; ;
    <span class="kw">using</span> pointer = T * ;
    <span class="co">// イテレーターカテゴリーは前方イテレーター</span>
    <span class="kw">using</span> iterator_category = std::forward_iterator_tag ;

    <span class="co">// 値を保持する</span>
    T value ;

    <span class="co">// コンストラクター</span>
    iota_iterator( T value = <span class="dv">0</span> )
        : value(value)
    { }

    <span class="co">// 残りのコード</span>
} ;</code></pre></div>
<p>これでイテレーターとしてオブジェクトを作ることができるようになる。コピーは自動的に生成されるので書く必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// i(0)</span>
    iota_iterator&lt;<span class="dt">int</span>&gt; i ;
    <span class="co">// iota_iterator&lt;int&gt;</span>
    iota_iterator first(<span class="dv">0</span>), last(<span class="dv">10</span>) ;

    <span class="co">// lastをiにコピー</span>
    i = last ;
}</code></pre></div>
<p>残りのコードも書いていこう。<code>operator *</code>は単に<code>value</code>を返すだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 非const版</span>
reference       <span class="kw">operator</span> *() <span class="kw">noexcept</span>
{ <span class="kw">return</span> value ; }
<span class="co">// const版</span>
<span class="dt">const</span> reference <span class="kw">operator</span> *() <span class="dt">const</span> <span class="kw">noexcept</span>
{ <span class="kw">return</span> value ; }</code></pre></div>
<p>非<code>const</code>版と<code>const</code>版があるのは、<code>const</code>な<code>iota_iterator</code>のオブジェクトからも使えるようにするためだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 非constなオブジェクト</span>
    iota_iterator non_const(<span class="dv">0</span>) ;
    <span class="co">// 非const版のoperator *を呼び出す</span>
    <span class="dt">int</span> value = *non_const ;
    <span class="co">// 変更できる</span>
    *non_const = <span class="dv">1</span> ;

    <span class="co">// constなオブジェクト</span>
    iota_iterator immutable(<span class="dv">0</span>) ;
    <span class="co">// const版のoperator *を呼び出す</span>
    <span class="dt">int</span> const_value = *immutable ;
    <span class="co">// 変更はできない</span>
}</code></pre></div>
<p><code>noexcept</code>はこの関数は例外を外に投げないという宣言だ。今回、例外を投げる処理は使わないので、<code>noexcept</code>を指定できる。</p>
<p><code>operator ++</code>を実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 前置</span>
iota_iterator &amp; <span class="kw">operator</span> ++() <span class="kw">noexcept</span>
{
    ++value ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}
<span class="co">// 後置</span>
iota_iterator   <span class="kw">operator</span> ++(<span class="dt">int</span>) <span class="kw">noexcept</span>
{
    <span class="kw">auto</span> temp = *<span class="kw">this</span> ;
    ++*<span class="kw">this</span> ;
    <span class="kw">return</span> temp ;
}</code></pre></div>
<p>すでに説明したようにインクリメント演算子には前置後置の2種類が存在する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">++i ; <span class="co">// 前置</span>
i++ ; <span class="co">// 後置</span></code></pre></div>
<p>前置インクリメント演算子は引数を取らず、後置インクリメント演算子は区別のためだけに特に意味のない<code>int</code>型の引数を取る。</p>
<p>インクリメント演算子も例外を投げないので<code>noexcept</code>を指定する。</p>
<p>インクリメント演算子はデータメンバーを変更するので<code>const</code>は指定しない。</p>
<p>最後は比較演算子だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> <span class="kw">operator</span> == ( iota_iterator <span class="dt">const</span> &amp; i ) <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> value == i.value ;
}
<span class="dt">bool</span> <span class="kw">operator</span> != ( iota_iterator <span class="dt">const</span> &amp; i ) <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> !(*<span class="kw">this</span> == i) ;
}</code></pre></div>
<p>前方イテレーターがサポートする比較演算子は2つ、<code>operator ==</code>と<code>operator !=</code>だ。<code>!=</code>は<code>==</code>で実装してしまうとして、<code>==</code>は単に<code>value</code>を比較する。通常、イテレーターの比較は要素の値の比較ではなく、同じ要素を参照するイテレーターかどうかの比較になるが、<code>iota_iterator</code>の場合、<code>vector</code>や<code>array</code>のようなメモリー上に構築された要素は存在しないので、<code>value</code>の比較でよい。</p>
<p>前方イテレーターが提供される実例としては、前方リンクリストがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> forward_link_list
{
    T value ;
    forward_link_list * next ;
} ;

<span class="dt">int</span> main()
{
    forward_link_list&lt;<span class="dt">int</span>&gt; list3{ <span class="dv">3</span>, <span class="kw">nullptr</span> } ;
    forward_link_list&lt;<span class="dt">int</span>&gt; list2{ <span class="dv">2</span>, &amp;list3 } ;
    forward_link_list&lt;<span class="dt">int</span>&gt; list1{ <span class="dv">1</span>, &amp;list2 } ;
    forward_link_list&lt;<span class="dt">int</span>&gt; list0{ <span class="dv">0</span>, &amp;list1 } ;
}</code></pre></div>
<p>この<code>forward_link_list&lt;T&gt;</code>というクラスは<code>T</code>型の値を保持する<code>value</code>と、次のクラスのオブジェクトを参照するポインター<code>next</code>を持っている。このクラス<code>list</code>の次の要素は<code>*(list.next)</code>で、<code>list</code>の2つ次の要素は<code>*(*list.next).next)</code>だ。</p>
<p>このような<code>forward_link_list&lt;T&gt;</code>へのイテレーターの骨子は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iterator 
{
    forward_link_list&lt;T&gt; * ptr ;

    T &amp; <span class="kw">operator</span> *() <span class="kw">noexcept</span>
    {
        <span class="kw">return</span> ptr-&gt;value ;
    }

    iterator &amp; <span class="kw">operator</span> ++() <span class="kw">noexcept</span>
    {
        ptr = ptr-&gt;next ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
<span class="co">// 省略</span>
} ;</code></pre></div>
<p>前方リンクリストは<code>vector</code>や<code>array</code>のように要素の線形の集合を表現できる。<code>n</code>番目の要素から<code>n+1</code>番目の要素を返すことはできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// n+1番目の要素を返す関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
forward_link_list&lt;T&gt; &amp; next( forward_link_list&lt;T&gt; &amp; list ) <span class="kw">noexcept</span>
{
    <span class="co">// 次の要素</span>
    <span class="kw">return</span> *list.next ;
}</code></pre></div>
<p>ただし<code>n-1</code>番目の要素を返すことはできない。その方法がないからだ。</p>
<p>前方イテレーターが入力/出力イテレーターと違う点は、マルチパス保証があることだ。イテレーターのコピーを使い回して複数回同じ要素をたどることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ForwardIterator &gt;
<span class="dt">void</span> f( ForwardIterator first, ForwardIterator last )
{
    <span class="kw">using</span> vector_type = std::vector&lt; <span class="kw">typename</span> ForwardIterator::value_type &gt; ;

    <span class="co">// 全要素の値をv1にコピー</span>
    vector_type v1 ;
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
        v1.push_back( *iter ) ;

    <span class="co">// 全要素の値をv2にコピー</span>
    <span class="co">// イテレーターがもう一度使われる</span>
    vector_type v2 ;
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
        v2.push_back( *iter ) ;

    <span class="co">// マルチパス保証があれば常にtrue</span>
    <span class="dt">bool</span> b = v1 == v2 ;
}</code></pre></div>
<p>前方イテレーター以上のイテレーターにはこのマルチパス保証がある。</p>
<h3 id="双方向イテレーター-1">双方向イテレーター</h3>
<p>双方向イテレーターは<code>n</code>番目の要素を指すイテレーターから<code>n-1</code>番目を指すイテレーターを得られるイテレーターだ。<code>n-1</code>番目を指すには<code>operator --</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    ++i ; <span class="co">// n+1番目</span>
    --i ; <span class="co">// n-1番目</span>
}</code></pre></div>
<p><code>iota_iterator</code>を双方向イテレーターにするのは簡単だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iota_iterator
{
    <span class="co">// イテレーターカテゴリー</span>
    <span class="kw">using</span> iterator_category = std::bidirectional_iterator_tag ;

    iota_iterator &amp; <span class="kw">operator</span> --() <span class="kw">noexcept</span>
    {
        --value ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
    iota_iterator   <span class="kw">operator</span> --(<span class="dt">int</span>) <span class="kw">noexcept</span>
    {
        <span class="kw">auto</span> temp = *<span class="kw">this</span> ;
        --*<span class="kw">this</span> ;
        <span class="kw">return</span> temp ;
    }

    <span class="co">// 省略</span>
} ;</code></pre></div>
<p>イテレーターカテゴリーは双方向イテレーターを表現する<code>std::bidirectional_iterator_tag</code>を指定する。</p>
<p><code>operator --</code>の実装は<code>operator ++</code>の実装と要領は同じだ。</p>
<p>これで<code>iota_iterator</code>が双方向イテレーターになった。</p>
<p>双方向イテレーターが提供される実例としては、双方向リンクリストがある。前方リンクリストが前方の要素への参照を持つのに対し、双方向リンクリストは後方の要素への参照も持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> bidirectional_link_list
{
    T value ;

    bidirectional_link_list * next ;
    bidirectional_link_list * prev ;
} ;</code></pre></div>
<p>双方向リンクリストに対するイテレーター操作の骨子は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iterator 
{
    <span class="co">// 前方 n+1</span>
    iterator &amp; <span class="kw">operator</span> ++() <span class="kw">noexcept</span>
    {
        ptr = ptr-&gt;next ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
    <span class="co">// 後方 n-1</span>
    iterator &amp; <span class="kw">operator</span> --() <span class="kw">noexcept</span>
    {
        ptr = ptr-&gt;prev ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
} ;</code></pre></div>
<h3 id="ランダムアクセスイテレーター-1">ランダムアクセスイテレーター</h3>
<p>ランダムアクセスイテレーターにできることは多い。すでにランダムアクセスイテレーターでできることは解説したので、<code>iota_iterator</code>を対応させていこう。</p>
<p>イテレーターの参照する要素の移動の部分。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iota_iterator
{
    iota_iterator &amp; <span class="kw">operator</span> += ( difference_type n )
    {
        value += n ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
    iota_iterator <span class="kw">operator</span> + ( difference_type n ) <span class="dt">const</span>
    {
        <span class="kw">auto</span> temp = *<span class="kw">this</span> ;
        temp += n ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
    iota_iterator &amp; <span class="kw">operator</span> -= ( difference_type n )
    {
        value -= n ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
    iota_iterator <span class="kw">operator</span> - ( difference_type n ) <span class="dt">const</span>
    {
        <span class="kw">auto</span> temp = *<span class="kw">this</span> ;
        temp -= n ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
    <span class="co">// 省略</span>
} ;

<span class="co">// difference_type + iota_iteratorの場合</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
iota_iterator&lt;T&gt; <span class="kw">operator</span> +
(
    <span class="kw">typename</span> iota_iterator&lt;T&gt;::difference_type n,
    iota_iterator&lt;T&gt; <span class="dt">const</span> &amp; i
)
{ <span class="kw">return</span> i + n ; }


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
iota_iterator&lt;T&gt; <span class="kw">operator</span> - 
(
    <span class="kw">typename</span> iota_iterator&lt;T&gt;::difference_type n,
    iota_iterator&lt;T&gt; <span class="dt">const</span> &amp; i
)
{ <span class="kw">return</span> i - n ; }</code></pre></div>
<p>ランダムアクセスイテレーター <code>i</code>と<code>difference_type n</code>があるとき、<code>i + n</code>と<code>n + i</code>は同じ意味だ。<code>i + n</code>はイテレーターのメンバー関数としても、クラス外のフリー関数としても実装できる。どちらでも好きな方法で実装してよい。</p>
<p>参考に、クラス外のフリー関数として実装する場合は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
iota_iterator&lt;T&gt; <span class="kw">operator</span> +
(
    iota_iterator&lt;T&gt; i,
    <span class="kw">typename</span> iota_iterator&lt;T&gt;::difference_type n
)
{ <span class="kw">return</span> i + n ; }


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
iota_iterator&lt;T&gt; <span class="kw">operator</span> - 
(
    iota_iterator&lt;T&gt; i,
    <span class="kw">typename</span> iota_iterator&lt;T&gt;::difference_type n
)
{ <span class="kw">return</span> i - n ; }</code></pre></div>
<p><code>n + i</code>は必ずクラス外のフリー関数として実装しなければならない。クラスのメンバー関数として演算子のオーバーロードをする場合はオペランドが<code>this</code>になるからだ。</p>
<p>イテレーターの距離の実装は<code>iota_iterator</code>の場合、単に<code>value</code>の差だ。</p>
<p>メンバー関数として実装する場合は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iota_iterator
{
    difference_type <span class="kw">operator</span> - ( iota_iterator <span class="dt">const</span> &amp; i )
    {
        <span class="kw">return</span> value - i.value ;
    }
} ;</code></pre></div>
<p>クラス外のフリー関数として実装する場合は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">typename</span> iota_iterator&lt;T&gt;::difference_type
( iota_iterator&lt;T&gt; <span class="dt">const</span> &amp; a, iota_iterator&lt;T&gt; <span class="dt">const</span> &amp; b )
{
    <span class="kw">return</span> a.value - b.value ;
}</code></pre></div>
<p>大小比較の実装も<code>value</code>を比較するだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iota_iterator 
{
    <span class="dt">bool</span> <span class="kw">operator</span> &lt; ( iota_iterator <span class="dt">const</span> &amp; i ) <span class="dt">const</span> <span class="kw">noexcept</span> 
    { <span class="kw">return</span> value &lt; i.value ; }
    <span class="dt">bool</span> <span class="kw">operator</span> &lt;= ( iota_iterator <span class="dt">const</span> &amp; i ) <span class="dt">const</span> <span class="kw">noexcept</span> 
    { <span class="kw">return</span> value &lt;= i.value ; }
    <span class="dt">bool</span> <span class="kw">operator</span> &gt; ( iota_iterator <span class="dt">const</span> &amp; i ) <span class="dt">const</span> <span class="kw">noexcept</span> 
    { <span class="kw">return</span> value &gt; i.value ; }
    <span class="dt">bool</span> <span class="kw">operator</span> &gt;= ( iota_iterator <span class="dt">const</span> &amp; i ) <span class="dt">const</span> <span class="kw">noexcept</span> 
    { <span class="kw">return</span> value &gt;= i.value ; }
    <span class="co">// 省略</span>
} ;</code></pre></div>
<p>ランダムアクセスイテレーターの実例としては、連続したメモリー上に構築された要素の集合に対するイテレーターがある。標準ライブラリでは、<code>vector</code>や<code>array</code>が該当する。</p>
<p><code>vector</code>や<code>array</code>の中身は連続したメモリー上に確保された要素で、要素の参照にはポインターか、ポインターとインデックスが用いられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// arrayやvectorのイテレーター</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> iterator
{
    T * ptr ;

    T &amp; <span class="kw">operator</span> * () { <span class="kw">return</span> *ptr ; }
    iterator &amp; <span class="kw">operator</span> ++ () <span class="kw">noexcept</span>
    { ++ptr ; <span class="kw">return</span> *<span class="kw">this</span> ; }
    <span class="co">// その他のメンバー</span>
} ;</code></pre></div>
<p><code>vector</code>や<code>array</code>のイテレーターの実装は、ポインターとほぼ同じ処理をしている。その実装は上にあるように、単にポインターに処理をデリゲートするだけだ。</p>
<p>そこで、C++標準ライブラリの実装によっては、<code>vector</code>や<code>array</code>の実装は単に生のポインターを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, std::size_t N &gt;
<span class="kw">struct</span> array
{
    T storage[N] ;

    T * begin() <span class="kw">noexcept</span>
    { <span class="kw">return</span> storage ; }
    T * end() <span class="kw">noexcept</span>
    { <span class="kw">return</span> storage + N ; }
} ;</code></pre></div>
<p>イテレーターはクラスであり、そのネストされた型名に<code>value_type</code>や<code>difference_type</code>や<code>iterator_category</code>などの型がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="co">// ネストされた型名を使う</span>
<span class="kw">typename</span> Iterator::reference_type
get_value( Iterator i )
{
    <span class="kw">return</span> *i ;
}</code></pre></div>
<p><code>vector</code>や<code>array</code>のイテレーターが単に生のポインターを返す実装の場合、上のコードは動かない。</p>
<p>こういうときのために、<code>iterator_traits&lt;T&gt;</code>がある。もし<code>T</code>がポインターの場合は、ネストされた型名を都合のいいように宣言してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="co">// ポインターにも対応</span>
<span class="kw">typename</span> std::iterator_traits&lt;Iterator&gt;::reference_type
get_value( Iterator i )
{
    <span class="kw">return</span> *i ;
}</code></pre></div>
<p>そのため、イテレーターのネストされた型名を使うときには、直接使うのではなく、一度<code>iterator_traits</code>を経由して使うとよい。</p>
<h2 id="イテレーター操作">イテレーター操作</h2>
<p>イテレーターはそのまま使うこともできるが、一部の操作を簡単に行うための標準ライブラリがある。</p>
<h3 id="advance-i-n-n移動する"><code>advance( i, n )</code>: n移動する</h3>
<p>イテレーター <code>i</code>を<code>n</code>回移動したいとする。ランダムアクセスイテレーターならば以下のようにする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i += n ;</code></pre></div>
<p>しかし前方イテレーターの場合、<code>operator +=</code>は使えない。<code>n</code>回<code>operator ++</code>を呼び出す必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( <span class="kw">auto</span> count = <span class="dv">0</span> ; count != n ; ++count )
    ++i ;</code></pre></div>
<p>双方向イテレーターの場合、<code>n</code>は負数の場合がある。<code>n</code>が負数の場合、<code>n</code>回<code>operator --</code>を呼び出すことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> ( n &gt; <span class="dv">0</span> )
    <span class="kw">for</span> ( <span class="kw">auto</span> count = <span class="dv">0</span> ; count != n ; ++count )
        ++i ;
<span class="kw">else</span>
    <span class="kw">for</span> ( <span class="kw">auto</span> count = <span class="dv">0</span> count != n ; --count )
        --i ;</code></pre></div>
<p>双方向イテレーター用のコードはランダムアクセスイテレーターでも動くが非効率的だ。</p>
<p>いま使っているイテレーターの種類を把握して適切な方法を選ぶコードを書くのは面倒だ。そこで標準ライブラリには、イテレーター <code>i</code>を<code>n</code>回移動してくれる<code>advance(i, n)</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// iを1前方に移動</span>
std::advance(i, <span class="dv">1</span>) ;
<span class="co">// iを5前方に移動</span>
std::advance(i, <span class="dv">5</span>) ;
<span class="co">// iを5後方に移動</span>
std::advance(i, <span class="dv">-5</span>) ;
<span class="co">// iは移動しない</span>
std::advance(i, <span class="dv">0</span>) ;</code></pre></div>
<p><code>n</code>が正数の場合は前方(<code>i+1</code>の方向)に、<code>n</code>が負数の場合は後方(<code>i-1</code>の方向)に、それぞれ<code>n</code>回移動させる。</p>
<p><code>advance(i,n)</code>は<code>i</code>自体が書き換わる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">i ; <span class="co">// n番目を指す</span>
std::advance( i, <span class="dv">1</span> ) ;
i ; <span class="co">// n+1番目を指す</span></code></pre></div>
<h3 id="distance-first-last-firstからlastまでの距離"><code>distance( first, last )</code>: firstからlastまでの距離</h3>
<p>イテレーター<code>first</code>から<code>last</code>までの距離を求めたいとする。</p>
<p>ランダムアクセスイテレーターならば以下のようにする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> dist = last - first ;</code></pre></div>
<p>それ以外のイテレーターならば、<code>first</code>が<code>last</code>と等しくなるまで<code>operator ++</code>を呼び出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::size_t dist = <span class="dv">0</span> ;
<span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
    ++dist ;</code></pre></div>
<p>これをやるのも面倒なので標準ライブラリがある。</p>
<p><code>distance( first, last )</code>は<code>first</code>から<code>last</code>までの距離を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// iからjまでの距離を返す</span>
<span class="kw">auto</span> dist = std::distance( i, j ) ;</code></pre></div>
<p>ランダムアクセスイテレーターならば<code>j - i</code>と同じで、そうでなければ<code>i</code>が<code>j</code>と等しくなるまで<code>operator ++</code>を呼び出す。</p>
<p><code>distance</code>に渡したイテレーターは変更されない。</p>
<h3 id="nextprev-移動したイテレーターを返す">next/prev : 移動したイテレーターを返す</h3>
<p><code>advance(i, n)</code>はイテレーター<code>i</code>を変更してしまう。イテレーターを変更させずに移動後のイテレーターもほしい場合、以下のように書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    <span class="kw">auto</span> j = i ;
    std::advance( j, <span class="dv">3</span> ) ;
    <span class="co">// jはiより3前方に移動している</span>
}</code></pre></div>
<p>標準ライブラリの<code>next</code>/<code>prev</code>は、引数に渡したイテレーターを変更せず、移動後のイテレーターを返してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    <span class="kw">auto</span> j = std::next( i, <span class="dv">3</span> ) ;
    <span class="co">// jはiより3前方に移動している</span>
}</code></pre></div>
<p><code>prev</code>はその逆だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    <span class="kw">auto</span> j = std::prev( i, <span class="dv">3</span> ) ;
    <span class="co">// jはiより3後方に移動している</span>
    <span class="co">// jはstd::advance(i, 3)したあとのiと同じ値</span>
}</code></pre></div>
<p><code>next</code>/<code>prev</code>に第二引数を渡さない場合、前後に1だけ移動する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> f( Iterator i )
{
    <span class="kw">auto</span> j = std::next(i) ;
    <span class="co">// jは++iしたのと同じ値</span>
    <span class="kw">auto</span> k = std::prev(i) ;
    <span class="co">// kは--iしたのと同じ値</span>
}</code></pre></div>
<h2 id="リバースイテレーター">リバースイテレーター</h2>
<p>イテレーターは要素を順番どおりにたどる。例えば以下は要素を順番に出力する関数テンプレート<code>print</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="dt">void</span> print( Iterator first, Iterator last )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = first ; iter != last ; ++iter )
        std::cout &lt;&lt; *iter ;
}</code></pre></div>
<p>逆順に出力するにはどうすればいいのだろうか。</p>
<p>双方向イテレーター以上ならば逆順にたどることはできる。すると逆順に出力する関数テンプレート<code>reverse_print</code>は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> reverse_print( Iterator first, Iterator last )
{
    <span class="kw">for</span> ( <span class="kw">auto</span> iter = std::prev(last) ; iter != first ; --iter )
    {
        std::cout &lt;&lt; *iter ;
    }
    <span class="co">// 最初の要素の出力</span>
    std::cout &lt;&lt; *iter ;
}</code></pre></div>
<p>しかしイテレーターを正順にたどるか逆順にたどるかという違いだけで、本質的に同じアルゴリズム、同じコードを2度も書きたくはない。そういうときに役立つのがリバースイテレーターだ。</p>
<p><code>std::reverse_iterator&lt;Iterator&gt;</code>はイテレーター<code>Iterator</code>に対するリバースイテレーターを提供する。リバースイテレーターはイテレーターのペア <code>[first,last)</code>を受け取り、<code>last</code>の1つ前の要素が先頭で<code>first</code>の要素が末尾になるような順番のイテレーターにしてくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// std::reverse_iterator&lt; std::vector&lt;int&gt;::iterator &gt;</span>
    std::reverse_iterator first{ std::end(v) } ;
    std::reverse_iterator last{ std::begin(v) } ;

    <span class="co">// 54321</span>
    std::for_each( first, last,
        [](<span class="kw">auto</span> x ){ std::cout &lt;&lt; x ; } ) ;
}</code></pre></div>
<p>これで、<code>print</code>と<code>reverse_print</code>のような本質的に同じコードを重複して書かずに済む。</p>
<p>リバースイテレーターはとても便利なので、<code>std::vector</code>のような標準ライブラリのコンテナーには最初からネストされた型名としてリバースイテレーター<code>::reverse_iterator</code>がある。リバースイテレーターを返す<code>rbegin</code>/<code>rend</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// std::vector&lt;int&gt;::reverse_iterator</span>
    <span class="kw">auto</span> first = std::rbegin(v) ;
    <span class="kw">auto</span> last = std::rend(v) ;

    std::for_each( first, last,
        [](<span class="kw">auto</span> x ){ std::cout &lt;&lt; x ; } ) ;
}</code></pre></div>
<h1 id="動的メモリー確保">動的メモリー確保</h1>
<h2 id="概要">概要</h2>
<p>動的メモリー確保は任意のサイズのメモリーを確保できる機能だ。</p>
<p>例えば<code>std::vector</code>は任意個の要素を保持できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> input { } ;
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="kw">while</span> ( std::cin &gt;&gt; input )
    {
        v.push_back( input ) ;
    }
}</code></pre></div>
<p>このプログラムは任意個の<code>int</code>型の値を保持する。いくつ保持するかはコンパイル時にはわからないし、実行途中にもわからない。プログラムが終了するまで、実際にいくつ値を保持したのかはわからない。</p>
<p>このような事前にいくつの値を保持するかわからない状況では、動的メモリー確保を使う。</p>
<h2 id="mallocfree">malloc/free</h2>
<p><code>malloc</code>/<code>free</code>はC言語から受け継いだ素朴な動的メモリー確保のライブラリだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="dt">void</span> *  malloc  ( std::size_t size ) ;
    <span class="dt">void</span>    free    ( <span class="dt">void</span> * ptr ) ;
}</code></pre></div>
<p><code>malloc(n)</code>は<code>n</code>バイトの生のメモリーを確保して、その先頭バイトへのポインターを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 5バイトのメモリーを確保</span>
<span class="dt">void</span> * ptr = std::malloc( <span class="dv">5</span> ) ;</code></pre></div>
<p>これによって確保されるメモリーは、1バイトごとのメモリーが配列のように連続したメモリーだ。型で書くと、<code>std::byte [5]</code>のようなものだ。</p>
<p>確保したメモリーは<code>free</code>で解放するまで有効だ。<code>free(ptr)</code>は<code>malloc</code>が返したポインター<code>ptr</code>を解放する。その結果、メモリーはまた再び<code>malloc</code>によって再利用できるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 5バイトの生のメモリーを確保</span>
<span class="dt">void</span> * ptr = std::malloc( <span class="dv">5</span> ) ;
<span class="co">// 解放</span>
std::free( ptr ) ;
<span class="co">// これ以降、ptrの値は無効</span></code></pre></div>
<h2 id="operator-newoperator-delete">operator new/operator delete</h2>
<p>C++の追加した生のメモリーを確保する方法が、<code>operator new</code>と<code>operator delete</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// グローバル名前空間</span>
<span class="dt">void</span> *  <span class="kw">operator</span> <span class="kw">new</span>    ( std::size_t size );
<span class="dt">void</span>    <span class="kw">operator</span> <span class="kw">delete</span> ( <span class="dt">void</span> * ptr ) ;</code></pre></div>
<p>使い方は<code>malloc</code>とほぼ同じだ。<code>&quot;operator new&quot;</code>までが名前なので少し混乱するが、通常の関数呼び出しと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="dv">5</span> ) ;</code></pre></div>
<p>グローバル名前空間であることを明示するために<code>::</code>を使っている。</p>
<p><code>operator new</code>で確保したメモリーは、<code>operator delete</code>で解放するまで有効だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="dv">5</span> ) ;
::<span class="kw">operator</span> <span class="kw">delete</span> ( ptr ) ;</code></pre></div>
<h2 id="生のバイト列を基本的な型の値として使う方法">生のバイト列を基本的な型の値として使う方法</h2>
<p><code>int</code>や<code>double</code>のような基本的な型は、生のバイト列のポインターを型変換するだけで使える。</p>
<ol style="list-style-type: decimal">
<li>生のメモリーを確保</li>
<li>ポインターを型変換</li>
<li>値を代入</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 確保</span>
    <span class="dt">void</span> * void_ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(<span class="dt">int</span>) ) ;
    <span class="co">// 型変換</span>
    <span class="dt">int</span> * int_ptr = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> *&gt;( void_ptr ) ;
    <span class="co">// 代入</span>
    *int_ptr = <span class="dv">0</span> ;
    <span class="co">// 解放</span>
    ::<span class="kw">operator</span> <span class="kw">delete</span> ( void_ptr ) ;
}</code></pre></div>
<p><code>int</code>型のサイズは<code>sizeof(int)</code>バイトなので、<code>sizeof(int)</code>バイトのメモリーを確保する。<code>void *</code>型から<code>int *</code>型に型変換する。あとはポインターを経由して使うだけだ。</p>
<p>ポインターの文法がわかりにくい場合、リファレンスを使うこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp; int_ref = *int_ptr ;</code></pre></div>
<p><code>malloc</code>や<code>operator new</code>が返すメモリーの値は不定だ。なので、確保した生のメモリーへのポインターを、実際に使う型のポインターに型変換して、その値を参照しようとすると、結果は未定義だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// ここまでは定義された挙動</span>
    <span class="dt">int</span> * ptr = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> *&gt;( ::<span class="kw">operator</span> <span class="kw">new</span>(<span class="kw">sizeof</span>(<span class="dt">int</span>)) ) ;
    <span class="co">// 未定義の挙動</span>
    std::cout &lt;&lt; *ptr ;
}</code></pre></div>
<p>このプログラムを実行した結果、何が起こるかはわからない。</p>
<h2 id="メモリー確保の失敗">メモリー確保の失敗</h2>
<p>メモリー確保は失敗する可能性がある。現実のコンピューターは有限のリソースしか持たないために、メモリーも当然有限のリソースだ。</p>
<p><code>malloc</code>が失敗すると、<code>nullptr</code>が返される。<code>malloc</code>が失敗したかどうかを調べるには、戻り値を<code>nullptr</code>と比較すればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">void</span> * ptr = std::malloc( <span class="dv">1</span> ) ;

    <span class="kw">if</span> ( ptr == <span class="kw">nullptr</span> ) {
        <span class="co">// メモリー確保失敗</span>
    } <span class="kw">else</span> {
        <span class="co">// メモリー確保成功</span>
    }
}</code></pre></div>
<p><code>operator new</code>が失敗すると、<code>std::bad_alloc</code>が投げられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">try</span> {
        <span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="dv">1</span> ) ;
        <span class="co">// メモリー確保成功</span>
    } <span class="kw">catch</span> ( std::bad_alloc e )
    {
        <span class="co">// メモリー確保失敗</span>
    }
}</code></pre></div>
<p>たいていの環境ではメモリー確保が失敗したときにできることは少ない。そのままプログラムを終了するのが最も適切な処理だ。というのも、ほとんどの処理にはメモリー確保が必要だからだ。</p>
<p>例外の場合、<code>catch</code>しなければプログラムは終了する。<code>malloc</code>の場合、自分でメモリー確保が失敗したかどうかを調べてプログラムを終了しなければならない。プログラムを途中で強制的に終了するには、<code>std::abort</code>が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="dt">void</span> * ptr = malloc(<span class="dv">1</span>) ;

    <span class="co">// 失敗判定</span>
    <span class="kw">if</span> ( ptr == <span class="kw">nullptr</span> )
        std::abort() ;

    <span class="co">// 成功</span>
}</code></pre></div>
<h2 id="クラス型の値の構築">クラス型の値の構築</h2>
<p>動的に確保したメモリーを<code>int</code>や<code>double</code>のような基本的な型の値として使うには以下のように書けばよいことはすでに学んだ。</p>
<ol style="list-style-type: decimal">
<li>その型のサイズ分のメモリーを確保</li>
<li>ポインターを型変換</li>
<li>適切な値を代入</li>
</ol>
<p>より汎用的にテンプレートを使って書くと以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 動的確保したメモリーをT型の値として使う</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> dynamic_allocate()
{
    <span class="co">// 1. その型のサイズ分のメモリーを確保</span>
    <span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(T) ) ;
    <span class="co">// 2. ポインターを型変換</span>
    T * T_ptr = <span class="kw">static_cast</span>&lt;T * &gt;( ptr ) ;
    <span class="co">// 3. 適切な値を代入</span>
    *T_ptr = T{} ;
    ::<span class="kw">operator</span> <span class="kw">delete</span>( ptr ) ;
}

<span class="dt">int</span> main()
{
    dynamic_allocate&lt;<span class="dt">int</span>&gt;() ;
    dynamic_allocate&lt;<span class="dt">double</span>&gt;() ;
}</code></pre></div>
<p>この方法は、ほとんどのクラスには使えない。例えば<code>std::vector&lt;T&gt;</code>には使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
dynamic_allocate&lt; std::vector&lt;<span class="dt">int</span>&gt; &gt;() ;</code></pre></div>
<p>「ほとんどのクラス」と書いたからには、使えるクラスもあるということだ。例えば以下のようなクラスでは使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Simple
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
} ;

<span class="dt">int</span> main()
{
    <span class="co">// 使える</span>
    dynamic_allocate&lt;Simple&gt;() ;
}</code></pre></div>
<p>なぜ<code>Simple</code>のようなクラスでは使えるのだろうか。<code>std::vector&lt;T&gt;</code>とはどう違うのか。この違いを厳密に解説するためには、とても長くて厳密なC++の標準規格の理解が必要だ。とても難しいため、本書では解説しない。</p>
<p>クラスの値を使うためには、メモリー上にクラスのオブジェクトを構築する必要がある。クラスの構築にはコンストラクター呼び出し以外にも、そのメモリーをクラスのオブジェクトとして使うのに必要な何らかの初期化が含まれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sizeof(std::vector&lt;int&gt;)バイトのメモリーを確保し</span>
<span class="co">// そのメモリー上にクラスのオブジェクトを構築</span>
std::vector&lt;<span class="dt">int</span>&gt; v ;</code></pre></div>
<p>生のメモリー上にクラスのような複雑な型を構築するには、<code>newプレイスメント</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">new</span> ( 生のポインター ) 型 new初期化子</code></pre></div>
<p><code>new初期化子</code>というのは<code>()</code>か<code>{}</code>で囲んだコンストラクターへの引数だ。引数がない場合は省略もできる。</p>
<p>例えば<code>std::vector&lt;int&gt;</code>型を構築するには以下のようにする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 生のメモリーを動的確保</span>
<span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span> ( <span class="kw">sizeof</span>( std::vector&lt;<span class="dt">int</span>&gt; ) ) ;
<span class="co">// 生のメモリー上に型を構築</span>
std::vector&lt;<span class="dt">int</span>&gt; * vector_ptr = <span class="kw">new</span> (ptr) std::vector&lt;<span class="dt">int</span>&gt;{} ;</code></pre></div>
<p>こうすればクラスが適切にメモリー上に構築され、コンストラクターも呼ばれる。コンストラクターが呼ばれることを確かめてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Logger
{
    std::string name ;
    Logger( std::string name )
        : name( name )
    { std::cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is constructed.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
    ~Logger()
    { std::cout &lt;&lt; name &lt;&lt; <span class="st">&quot; is destructed.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
} ;

<span class="dt">int</span> main()
{
    <span class="dt">void</span> * ptr = ::<span class="kw">operator</span> <span class="kw">new</span> ( <span class="kw">sizeof</span>( Logger ) ) ;
    Logger * logger_ptr = <span class="kw">new</span> (ptr) Logger{<span class="st">&quot;Alice&quot;</span>s} ;
}</code></pre></div>
<p>このプログラムを実行すると、<code>&quot;Alice is constructed.&quot;</code>と出力される。</p>
<p>クラスのオブジェクトを適切に破棄するためには、デストラクターを呼ばなければならない。通常の変数ならば、変数が寿命を迎えたときに自動的にデストラクターが呼ばれてくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    Logger Alice(<span class="st">&quot;Alice&quot;</span>s) ;
    {
        Logger Bob(<span class="st">&quot;Bob&quot;</span>s) ;
        <span class="co">// Bobの寿命はここまで</span>
    }
    <span class="co">// Aliceの寿命はここまで</span>
}</code></pre></div>
<p>このプログラムを実行すると、以下のように出力される。</p>
<pre><code>Alice is constructed.
Bob is constructed.
Bob is destructed.
Alice is destructed.</code></pre>
<p>動的に確保されるメモリー上に構築されたオブジェクトは自動的に破棄されてくれない。クラスのオブジェクトの場合デストラクターを呼び出さなければならないが、動的メモリー確保したメモリー上に構築したクラスのオブジェクトの場合は、明示的に呼び出さなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 動的メモリー確保</span>
<span class="dt">void</span> * raw_ptr = ::<span class="kw">operator</span> <span class="kw">new</span>( <span class="kw">sizeof</span>(Logger) ) ;
<span class="co">// 構築</span>
Logger * logger_ptr = <span class="kw">new</span>(raw_ptr) Logger{ <span class="st">&quot;Alice&quot;</span>s } ;
<span class="co">// デストラクター呼び出し</span>
logger_ptr-&gt;~Logger() ;
<span class="co">// 破棄</span>
::<span class="kw">operator</span> <span class="kw">delete</span>( raw_ptr ) ;</code></pre></div>
<p>このようにすれば、コンストラクター、デストラクターが適切に呼ばれる。また確保したメモリーも解放される。</p>
<h2 id="newdelete">new/delete</h2>
<p>クラスのオブジェクトを動的確保するのに、生のメモリーの確保/解放と、クラスのオブジェクトの構築/破棄をすべて自前で行うのは面倒だ。幸い、確保と構築、破棄と解放を同時にやってくれる機能がある。<code>new式</code>と<code>delete式</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">new</span> 型 new初期化子
<span class="kw">delete</span> ポインター</code></pre></div>
<p><code>new式</code>は生のメモリーを確保し、型のオブジェクトを構築し、そのオブジェクトへのポインターを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * int_ptr = <span class="kw">new</span> <span class="dt">int</span>{<span class="dv">123</span>} ;
std::vector&lt;<span class="dt">int</span>&gt; * vector_ptr = <span class="kw">new</span> std::vector&lt;<span class="dt">int</span>&gt;{} ;</code></pre></div>
<p><code>delete式</code>は<code>new式</code>で返されたポインターの指し示すオブジェクトを破棄し、生のメモリーを解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">delete</span> int_ptr ;
<span class="kw">delete</span> vector_ptr ;</code></pre></div>
<p><code>new式</code>がメモリーの確保に失敗すると、<code>std::bad_alloc</code>例外を投げる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">try</span> {
        <span class="kw">new</span> <span class="dt">int</span>{<span class="dv">0</span>} ;
        <span class="co">// 確保成功</span>
    } <span class="kw">catch</span>( std::bad_alloc e )
    {
        <span class="co">// 確保失敗</span>
    }
}</code></pre></div>
<h2 id="配列版newdelete">配列版new/delete</h2>
<p><code>new式</code>は配列型を動的確保することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> * int_array_ptr =  <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">5</span>]{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</code></pre></div>
<p>配列型を<code>new式</code>で動的確保した場合、<code>delete式</code>は通常の<code>delete</code>ではなく、<code>delete[]</code>を使わなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">delete</span> [] int_array_ptr ;</code></pre></div>
<h2 id="スマートポインター">スマートポインター</h2>
<p>クラスのオブジェクトの動的確保は、解放を明示的にしなければならないので間違いをしやすい。この問題はクラスを使って解決できる。</p>
<p>クラスのコンストラクターで動的確保し、デストラクターで解放すればよいのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> smart_ptr
{
    T * ptr ;
    <span class="co">// コンストラクターで構築</span>
    smart_ptr()
        : ptr( <span class="kw">new</span> T{} )
    { }
    <span class="co">// デストラクターで破棄</span>
    ~smart_ptr()
    { <span class="kw">delete</span> ptr ; }

    T &amp; <span class="kw">operator</span> *() <span class="dt">const</span> <span class="kw">noexcept</span>
    { <span class="kw">return</span> *ptr ; }
} ;

<span class="dt">int</span> main()
{
    smart_ptr&lt;<span class="dt">int</span>&gt; ptr ;
    *ptr = <span class="dv">123</span> ;
    <span class="co">// 自動的に破棄される</span>
}</code></pre></div>
<p>このクラスはさまざまな点で実用的ではない。例えばこのクラスはコピーできてしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    smart_ptr&lt;<span class="dt">int</span>&gt; p1 ;
    <span class="co">// コピーされる</span>
    <span class="kw">auto</span> p2 = p1 ;
    <span class="co">// p2の寿命</span>
    <span class="co">// エラー、p1の寿命</span>
}</code></pre></div>
<p>このコードの何がまずいかというと、<code>smart_ptr::ptr</code>がコピーされてしまうということだ。<code>p2</code>が破棄されると、<code>delete ptr</code>が実行される。そのあとに<code>p1</code>が破棄されるのだが、もう一度<code>delete ptr</code>が実行されてしまうのだ。一度<code>delete</code>を呼び出したポインターはもう無効になっているので、それ以上<code>delete</code>を呼び出すことはできない。よってエラーになる。</p>
<p>この問題を解決するには、まだ学んでいないC++の機能がたくさん必要になる。この問題は必要な機能をすべて学び終えたあとの章で、もう一度挑戦することにしよう。</p>
<h1 id="vectorの実装-基礎">vectorの実装 : 基礎</h1>
<p>クラス、ポインター、メモリー確保を学んだので、とうとうコンテナーの中でも一番有名な<code>std::vector</code>を実装する用意ができた。しかしその前に、アロケーターについて学ぶ必要がある。</p>
<p><code>std::vector</code>は<code>std::vector&lt;T&gt;</code>のように要素の型<code>T</code>を指定して使うので、以下のようになっていると思う読者もいるだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
    <span class="kw">struct</span> vector ;
}</code></pre></div>
<p>実際には以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> allocator = allocator&lt;T&gt; &gt;
    <span class="kw">struct</span> vector ;
}</code></pre></div>
<p><code>std::allocator&lt;T&gt;</code>というのは標準ライブラリのアロケーターだ。アロケーターは生のメモリーの確保と解放をするライブラリだ。デフォルトで<code>std::allocator&lt;T&gt;</code>が渡されるので、普段ユーザーはアロケーターを意識することはない。</p>
<p><code>std::vector</code>は<code>malloc</code>や<code>operator new</code>を直接使わずアロケーターを使ってメモリー確保を行う。</p>
<p>アロケーターはテンプレートパラメーターで指定できる。何らかの理由で独自のメモリー確保を行いたい場合、独自のアロケーターを実装してコンテナーに渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 独自のアロケーター</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> custom_allocator
{
    <span class="co">// ...</span>
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">using</span> custom_vector = std::vector&lt; T, custom_allocator&lt;T&gt; &gt; ;

<span class="dt">int</span> main()
{
    custom_vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// 独自のアロケーターを使ったメモリー確保</span>
    v.push_back(<span class="dv">0</span>) ;
}</code></pre></div>
<h2 id="stdallocatortの概要"><code>std::allocator&lt;T&gt;</code>の概要</h2>
<p><code>std::allocator&lt;T&gt;</code>は<code>T</code>型を構築できる生のメモリーを確保するための以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">class</span> allocator {
    <span class="co">// ネストされた型名の宣言</span>
    <span class="kw">using</span> value_type = T;
    <span class="kw">using</span> size_type = size_t;
    <span class="kw">using</span> difference_type = ptrdiff_t;
    <span class="kw">using</span> propagate_on_container_move_assignment = true_type;
    <span class="kw">using</span> is_always_equal = true_type;

    <span class="co">// コンストラクター</span>
    <span class="co">// constexprはまだ学んでいない</span>
    <span class="kw">constexpr</span> allocator() <span class="kw">noexcept</span>;
    <span class="kw">constexpr</span> allocator(<span class="dt">const</span> allocator&amp;) <span class="kw">noexcept</span>;
    <span class="kw">template</span>&lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> allocator(<span class="dt">const</span> allocator&lt;U&gt;&amp;) <span class="kw">noexcept</span>;
    ~ allocator();
    <span class="co">// コピー代入演算子</span>
    allocator&amp; <span class="kw">operator</span>=(<span class="dt">const</span> allocator&amp;) = <span class="kw">default</span>;

    <span class="co">// ここが重要</span>
    [[<span class="kw">nodiscard</span>]] T* allocate(size_t n);
    <span class="dt">void</span> deallocate(T* p, size_t n);
};
}</code></pre></div>
<p><code>constexpr</code>というキーワードがあるが、ここでは気にする必要はない。あとで学ぶ。</p>
<p>重要なのはメモリー確保をする<code>allocate</code>と、メモリー解放をする<code>deallocate</code>だ。</p>
<h2 id="stdallocatortの使い方"><code>std::allocator&lt;T&gt;</code>の使い方</h2>
<p>標準ライブラリのアロケーター、<code>std::allocator&lt;T&gt;</code>は、<code>T</code>型を構築できる生のメモリーの確保と解放をするライブラリだ。重要なメンバーは以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// メモリー確保</span>
[[<span class="kw">nodiscard</span>]] T* allocate(size_t n);
<span class="co">// メモリー解放</span>
<span class="dt">void</span> deallocate(T* p, size_t n);</code></pre></div>
<p><code>allocate(n)</code>は<code>T</code>型の<code>n</code>個の配列を構築できるだけの生のメモリーを確保してその先頭へのポインターを返す。</p>
<p><code>deallocate(p, n)</code>は<code>allocate(n)</code>で確保されたメモリーを解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::allocator&lt;std::string&gt; a ;
    <span class="co">// 生のメモリー確保</span>
    <span class="co">// std::string [1]分のメモリーサイズ</span>
    std::string * p = a.allocate(<span class="dv">1</span>) ;
    <span class="co">// メモリー解放</span>
    a.deallocate( p, <span class="dv">1</span> ) ;
}</code></pre></div>
<p><code>allocate</code>には<code>[[nodiscard]]</code>という属性が付いている。これにより戻り値を無視すると警告が出る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::allocator&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// 警告、戻り値が無視されている</span>
    a.allocate(<span class="dv">1</span>) ;

    <span class="co">// OK</span>
    <span class="dt">int</span> * p = a.allocate(<span class="dv">1</span>) ;
}</code></pre></div>
<p>確保されるのが生のメモリーだということに注意したい。実際に<code>T</code>型の値として使うには、<code>new</code>による構築が必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::allocator&lt;std::string&gt; a ;
    <span class="co">// 生のメモリー確保</span>
    <span class="co">// std::string [1]分のメモリーサイズ</span>
    std::string * p = a.allocate(<span class="dv">1</span>) ;
    <span class="co">// 構築</span>
    std::string * s = <span class="kw">new</span>(p) std::string(<span class="st">&quot;hello&quot;</span>) ;
    <span class="co">// 明示的なデストラクター呼び出し</span>
    s-&gt;~basic_string() ;
    <span class="co">// メモリー解放</span>
    a.deallocate( p, <span class="dv">1</span> ) ;
}</code></pre></div>
<p>このように書くのはとても面倒だ。特に<code>std::string</code>の明示的なデストラクター呼び出し<code>s-&gt;~basic_string</code>が面倒だ。なぜ<code>s-&gt;~string</code>ではだめなのか。</p>
<p>実は<code>std::string</code>は以下のようなクラステンプレートになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">template</span> &lt;
    <span class="kw">typename</span> charT,
    <span class="kw">typename</span> traits     = char_traits&lt;charT&gt;,
    <span class="kw">typename</span> Allocator  = allocator&lt;charT&gt;&gt;
<span class="kw">class</span> basic_string
{
    <span class="co">// デストラクター</span>
    ~basic_string() ;
} ;

}</code></pre></div>
<p>本当のクラス名は<code>basic_string</code>なのだ。</p>
<p>普段は使っている<code>std::string</code>というのは、以下のようなエイリアスだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">using</span> string = basic_string&lt;<span class="dt">char</span>&gt; ;
}</code></pre></div>
<p>明示的なデストラクター呼び出しにエイリアスは使えないので、本当のクラス名である<code>basic_string</code>を直接指定しなければならない。</p>
<p>この問題はテンプレートで解決できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 明示的なデストラクター呼び出しをする関数テンプレート</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> destroy_at( T * location )
{
    location-&gt;~T() ;
}</code></pre></div>
<p>このようにテンプレートで書くことによって、クラス名を意識せずに破棄ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 破棄</span>
destroy_at( s ) ;</code></pre></div>
<p>このようなコードを書くのは面倒なので、標準ライブラリには<code>std::destroy_at</code>がある。また、これらをひっくるめたアロケーターを使うためのライブラリである<code>allocator_traits</code>がある。</p>
<h2 id="stdallocator_traitsalloc"><code>std::allocator_traits&lt;Alloc&gt;</code></h2>
<p><code>std::allocator_traits&lt;Alloc&gt;</code>はアロケーター<code>Alloc</code>を簡単に使うためのライブラリだ。</p>
<p><code>allocator_traits&lt;Alloc&gt;</code>はアロケーターの型<code>Alloc</code>を指定して使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::allocator&lt;<span class="dt">int</span>&gt; a ;
<span class="dt">int</span> * p = a.allocate(<span class="dv">1</span>) ;</code></pre></div>
<p>と書く代わりに、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::allocator&lt;<span class="dt">int</span>&gt; a ;
<span class="dt">int</span> * p = std::allocator_traits&lt; std::allocator&lt;<span class="dt">int</span>&gt; &gt;::allocate( a, <span class="dv">1</span> ) ;</code></pre></div>
<p>と書く。</p>
<p>これはとても使いづらいので、<code>allocator_traits</code>のエイリアスを書くとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::allocator&lt;<span class="dt">int</span>&gt; a ;
<span class="co">// エイリアス</span>
<span class="kw">using</span> traits = std::allocator_traits&lt; std::allocator&lt;<span class="dt">int</span>&gt; &gt; ;
<span class="dt">int</span> * p = traits::allocate( a, <span class="dv">1</span> ) ;</code></pre></div>
<p>これもまだ書きにくいので、<code>decltype</code>を使う。<code>decltype(expr)</code>は式<code>expr</code>の型として使える機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int型</span>
<span class="kw">decltype</span>(<span class="dv">0</span>) a ;
<span class="co">// double型</span>
<span class="kw">decltype</span>(<span class="fl">0.0</span>) b ;
<span class="co">// int型</span>
<span class="kw">decltype</span>( <span class="dv">1</span> + <span class="dv">1</span> ) c ;
<span class="co">// std::string型</span>
<span class="kw">decltype</span>( <span class="st">&quot;hello&quot;</span>s ) c ;</code></pre></div>
<p><code>decltype</code>を使うと以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::allocator&lt;<span class="dt">int</span>&gt; a ;
<span class="co">// エイリアス</span>
<span class="kw">using</span> traits = std::allocator_traits&lt; <span class="kw">decltype</span>(a) &gt; ;
<span class="dt">int</span> * p = traits::allocate( a, <span class="dv">1</span> ) ;</code></pre></div>
<p><code>allocator_traits</code>はアロケーターを使った生のメモリーの確保、解放と、そのメモリー上にオブジェクトを構築、破棄する機能を提供している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::allocator&lt;std::string&gt; a ;
    <span class="co">// allocator_traits型</span>
    <span class="kw">using</span> traits = std::allocator_traits&lt;<span class="kw">decltype</span>(a)&gt; ;

    <span class="co">// 生のメモリー確保</span>
    std::string * p = traits::allocate( a, <span class="dv">1</span> ) ;
    <span class="co">// 構築</span>
    std::string * s = traits::construct( a, p, <span class="st">&quot;hello&quot;</span>) ;
    <span class="co">// 破棄</span>
    traits::destroy( a, s ) ;
    <span class="co">// メモリー解放</span>
    traits::deallocate( a, p, <span class="dv">1</span> ) ;
}</code></pre></div>
<p><code>T</code>型の<code>N</code>個の配列を構築するには、まず<code>N</code>個の生のメモリーを確保し、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::allocator&lt;std::string&gt; a ;
<span class="kw">using</span> traits = std::allocator_traits&lt;<span class="kw">decltype</span>(a)&gt; ;
std::string * p = traits::allocate( a, N ) ;</code></pre></div>
<p><code>N</code>回の構築を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( <span class="kw">auto</span> i = p, last = p + N ; i != last ; ++i )
{
    traits::construct( a, i, <span class="st">&quot;hello&quot;</span> ) ;
}</code></pre></div>
<p>破棄も<code>N</code>回行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( <span class="kw">auto</span> i = p + N, first = p ; i != first ; --i )
{
    traits::destroy( a, i ) ;
}</code></pre></div>
<p>生のメモリーを破棄する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">traits::deallocate( a, p, N ) ;</code></pre></div>
<h2 id="簡易vectorの概要">簡易vectorの概要</h2>
<p>準備はできた。簡易的な<code>vector</code>を実装していこう。以下が本書で実装する簡易<code>vector</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = std::allocator&lt;T&gt; &gt;
<span class="kw">class</span> vector
{
<span class="kw">private</span> :
    <span class="co">// データメンバー</span>
<span class="kw">public</span> :
    <span class="co">// value_typeなどネストされた型名</span>
    <span class="kw">using</span> value_type = T ;
    <span class="co">// コンストラクター</span>
    vector( std::size_t n = <span class="dv">0</span>, Allocator a = Allocator() ) ;
    <span class="co">// デストラクター</span>
    ~vector() ;
    <span class="co">// コピー</span>
    vector( <span class="dt">const</span> vector &amp; x ) ;
    vector &amp; <span class="kw">operator</span> =( <span class="dt">const</span> vector &amp; x ) ;

    <span class="co">// 要素アクセス</span>
    <span class="dt">void</span> push_back( <span class="dt">const</span> T &amp; x ) ;
    T &amp; <span class="kw">operator</span> []( std::size_t i ) <span class="kw">noexcept</span> ;

    <span class="co">// イテレーターアクセス</span>
    iterator begin() <span class="kw">noexcept</span> ;
    iterator end() <span class="kw">noexcept</span> ;
} ;</code></pre></div>
<p>これだけの簡易<code>vector</code>でもかなり便利に使える。</p>
<p>例えば要素数を定めて配列のようにアクセスできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector v(<span class="dv">100</span>) ;
<span class="kw">for</span> ( <span class="kw">auto</span> i = <span class="dv">0</span> ; i != <span class="dv">100</span> ; ++i )
    v[i] = i ; </code></pre></div>
<p>イテレーターも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::for_each( std::begin(v), std::end(v),
    []( <span class="kw">auto</span> x ) { std::cout &lt;&lt; x ; } ) ;</code></pre></div>
<p>要素を際限なく追加できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::copy(
    std::istream_iterator&lt;<span class="dt">int</span>&gt;(std::cin), std::istream_iterator&lt;<span class="dt">int</span>&gt;(), 
    std::back_inserter(v) ) ;</code></pre></div>
<h2 id="classとアクセス指定">classとアクセス指定</h2>
<p>簡易<code>vector</code>の概要では、まだ学んでいない機能が使われていた。<code>class</code>と<code>public</code>と<code>private</code>だ。</p>
<p>C++のクラスにはアクセス指定がある。<code>public:</code>と<code>private:</code>だ。アクセス指定が書かれたあと、別のアクセス指定が現れるまでの間のメンバーは、アクセス指定の影響を受ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
<span class="kw">public</span> :
    <span class="co">// publicなメンバー</span>
    <span class="dt">int</span> public_member1 ;
    <span class="dt">int</span> public_member2 ;
<span class="kw">private</span> :
    <span class="co">// privateなメンバー</span>
    <span class="dt">int</span> private_member1 ;
    <span class="dt">int</span> private_member2 ;
<span class="kw">public</span> :
    <span class="co">// 再びpublicなメンバー</span>
    <span class="dt">int</span> public_member3 ;    
} ;</code></pre></div>
<p><code>public</code>メンバーはクラスの外から使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
<span class="kw">public</span> :
    <span class="dt">int</span> data_member ;
    <span class="dt">void</span> member_function() { }
} ;

<span class="dt">int</span> main()
{
    C c;
    <span class="co">// クラスの外から使う</span>
    c.data_member = <span class="dv">0</span> ;
    c.member_function() ;
}</code></pre></div>
<p><code>private</code>メンバーはクラスの外から使うことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
<span class="kw">private</span> :
    <span class="dt">int</span> data_member ;
    <span class="dt">void</span> member_function() ;
} ;

<span class="dt">int</span> main()
{
    C c ;
    <span class="co">// エラー</span>
    c.data_member = <span class="dv">0</span> ;
    <span class="co">// エラー</span>
    c.member_function() ;
}</code></pre></div>
<p>コンストラクターもアクセス指定の対象になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
<span class="kw">public</span> :
    C(<span class="dt">int</span>) { }
<span class="kw">private</span> :
    C(<span class="dt">double</span>) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// OK</span>
    C pub(<span class="dv">0</span>) ;
    <span class="co">// エラー</span>
    C pri(<span class="fl">0.0</span>) ;
}</code></pre></div>
<p>この例では、<code>C::C(int)</code>は<code>public</code>メンバーなのでクラスの外から使えるが、<code>C::C(double)</code>は<code>private</code>メンバーなのでクラスの外からは使えない。</p>
<p><code>private</code>メンバーはクラスの中から使うことができる。クラスの中であればどのアクセス指定のメンバーからでも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> C
{
<span class="kw">public</span> :
    <span class="dt">void</span> f()
    {
        <span class="co">// ここはクラスの中</span>
        data_member = <span class="dv">0</span> ;
        member_function() ;
    }

<span class="kw">private</span> :
    <span class="dt">int</span> data_member ;
    <span class="dt">void</span> member_function() { }
} ;</code></pre></div>
<p><code>private</code>メンバーの目的はクラスの外から使ってほしくないメンバーを守ることだ。例えば以下のようにコンストラクターで<code>new</code>してデストラクターで<code>delete</code>するようなクラスがあるとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> dynamic_int
{
<span class="kw">private</span> :
    <span class="dt">int</span> * ptr ;
<span class="kw">public</span> :
    dynamic_int( <span class="dt">int</span> value = <span class="dv">0</span>  )
        : ptr( <span class="kw">new</span> <span class="dt">int</span>(value) )
    { }
    ~dynamic_int()
    {
        <span class="kw">delete</span> ptr ;
    }
} ;</code></pre></div>
<p>もし<code>dynamic_int::ptr</code>が<code>public</code>メンバーだった場合、以下のようなコードのコンパイルが通ってしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    dynamic_int i ;
    <span class="kw">delete</span> i.ptr ;
    <span class="dt">int</span> obj{} ;
    i.ptr = &amp;obj ;
}</code></pre></div>
<p>このプログラムが<code>dynamic_int</code>のデストラクターを呼ぶと、<code>main</code>関数のローカル変数のポインターに対して<code>delete</code>を呼び出してしまう。これは未定義の挙動となる。</p>
<p>外部から使われては困るメンバーを<code>private</code>メンバーにすることでこの問題はコンパイル時にエラーにでき、未然に回避できる。</p>
<p>クラスを定義するにはキーワードとして<code>struct</code>もしくは<code>class</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span>  foo { } ;
<span class="kw">class</span>   bar { } ;</code></pre></div>
<p>違いはデフォルトのアクセス指定だ。</p>
<p><code>struct</code>はデフォルトで<code>public</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> foo
{
    <span class="co">// publicメンバー</span>
    <span class="dt">int</span> member ;
} ;</code></pre></div>
<p><code>class</code>はデフォルトで<code>private</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> bar
{
    <span class="co">// privateメンバー</span>
    <span class="dt">int</span> member ;
} ;</code></pre></div>
<p><code>struct</code>と<code>class</code>の違いはデフォルトのアクセス指定だけだ。アクセス指定を明示的に書く場合、違いはなくなる。</p>
<h2 id="ネストされた型名-1">ネストされた型名</h2>
<p><code>std::vector</code>にはさまざまなネストされた型名がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> vec = std::vector&lt;<span class="dt">int</span>&gt; ;
    vec v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    vec::value_type val = v[<span class="dv">0</span>] ;
    vec::iterator i = v.begin() ;
}</code></pre></div>
<p>自作の簡易<code>vector</code>で<code>std::vector</code>と同じようにネストされた型名を書いていこう。</p>
<p>要素型に関係するネストされた型名。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = std::allocator&lt;T&gt; &gt;
<span class="kw">class</span> vector
{
<span class="kw">public</span> :
    <span class="kw">using</span> value_type                = T ;
    <span class="kw">using</span> pointer                   = T *;
    <span class="kw">using</span> const_pointer             = <span class="dt">const</span> pointer;
    <span class="kw">using</span> reference                 = value_type &amp; ;
    <span class="kw">using</span> const_reference           = <span class="dt">const</span> value_type &amp; ;
} ;</code></pre></div>
<p>本物の<code>std::vector</code>とは少し異なるが、ほぼ同じだ。要素型が<code>value_type</code>で、あとは要素型のポインター、<code>const</code>ポインター、リファレンス、<code>const</code>リファレンスがそれぞれエイリアス宣言される。</p>
<p>アロケーター型も<code>allocator_type</code>としてエイリアス宣言される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = std::allocator&lt;T&gt; &gt;
<span class="kw">class</span> vector
{
<span class="kw">public</span> :
    <span class="kw">using</span> allocator_type = Allocator ;
} ;</code></pre></div>
<p><code>size_type</code>は要素数を表現する型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( std::vector&lt;<span class="dt">int</span>&gt; &amp; v )
{
    std::vector&lt;<span class="dt">int</span>&gt;::size_type s = v.size() ;
}</code></pre></div>
<p>通常<code>std::size_t</code>が使われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_type = std::size_t ;</code></pre></div>
<p><code>difference_type</code>はイテレーターの<code>difference_type</code>と同じだ。これはイテレーター間の距離を表現する型だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( std::vector&lt;<span class="dt">int</span>&gt; &amp; v )
{
    <span class="kw">auto</span> i = v.begin() ;
    <span class="kw">auto</span> j = i + <span class="dv">3</span> ;

    <span class="co">// iとjの距離</span>
    std::vector&lt;<span class="dt">int</span>&gt;::difference_type d = j - i ;
}</code></pre></div>
<p>通常<code>std::ptrdiff_t</code>が使われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">difference_type = std::ptrdiff_t ;</code></pre></div>
<p>イテレーターのエイリアス。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> iterator                  = pointer ;
<span class="kw">using</span> const_iterator            = const_pointer ;
<span class="kw">using</span> reverse_iterator          = std::reverse_iterator&lt;iterator&gt; ;
<span class="kw">using</span> const_reverse_iterator    = std::reverse_iterator&lt;const_iterator&gt; ;</code></pre></div>
<p>今回実装する簡易<code>vector</code>では、ポインター型をイテレーター型として使う。<code>std::vector</code>の実装がこのようになっている保証はない。</p>
<p><code>reverse_iterator</code>と<code>const_reverse_iterator</code>はリバースイテレーターだ。</p>
<h2 id="簡易vectorのデータメンバー">簡易vectorのデータメンバー</h2>
<p>簡易<code>vector</code>にはどのようなデータメンバーがあればいいのだろうか。以下の4つの情報を保持する必要がある。</p>
<ol style="list-style-type: decimal">
<li>動的確保したストレージへのポインター</li>
<li>現在有効な要素数</li>
<li>動的確保したストレージのサイズ</li>
<li>アロケーター</li>
</ol>
<p>これを素直に考えると、ポインター1つ、整数2つ、アロケーター1つの4つのデータメンバーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = std::allocator&lt;T&gt; &gt;
<span class="kw">class</span> vector
{
<span class="kw">private</span> :
    <span class="co">// 動的確保したストレージへのポインター</span>
    pointer first = <span class="kw">nullptr</span> ;
    <span class="co">// 現在有効な要素数</span>
    size_type valid_size = <span class="kw">nullptr</span> ;
    <span class="co">// 動的確保したストレージのサイズ</span>
    size_type allocated_size = <span class="kw">nullptr</span> ;
    <span class="co">// アロケーターの値</span>
    allocator_type alloc ;
} ;</code></pre></div>
<p>確かに<code>std::vector</code>はこのようなデータメンバーでも実装できる。しかし多くの実装では以下のようなポインター3つとアロケーター1つになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = std::allocator&lt;T&gt; &gt;
<span class="kw">class</span> vector
{
<span class="kw">private</span> :
    <span class="co">// 先頭の要素へのポインター</span>
    pointer first ;
    <span class="co">// 最後の要素の1つ前方のポインター</span>
    pointer last ;
    <span class="co">// 確保したストレージの終端</span>
    pointer reserved_last ;
    <span class="co">// アロケーターの値</span>
    allocator_type alloc ;
} ;</code></pre></div>
<p>このように実装すると、現在有効な要素数は<code>last - first</code>で得られる。確保したストレージのサイズは<code>reserved_last - first</code>だ。ポインターで持つことによってポインターが必要な場面でポインターと整数の演算を必要としない。</p>
<p>効率的な実装はC++が実行される環境によっても異なるので、すべての環境に最適な実装はない。</p>
<h2 id="簡単なメンバー関数の実装">簡単なメンバー関数の実装</h2>
<p>簡易<code>vector</code>の簡単なメンバー関数を実装していく。ここでのサンプルコードはすべて簡易<code>vector</code>のクラス定義の中に書いたかのように扱う。例えば</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }</code></pre></div>
<p>とある場合、これは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = std::allocator&lt;T&gt; &gt;
<span class="kw">class</span> vector
{
    <span class="co">// その他のメンバーすべて</span>
<span class="kw">public</span> :
    <span class="dt">void</span> f() {}
} ;</code></pre></div>
<p>のように書いたものとして考えよう。</p>
<h3 id="イテレーター">イテレーター</h3>
<p>簡易<code>vector</code>は要素の集合を配列のように連続したストレージ上に構築された要素として保持する。したがってイテレーターは単にポインターを返すだけでよい。</p>
<p>まず通常のイテレーター</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">iterator begin() <span class="kw">noexcept</span>
{ <span class="kw">return</span> first ; }
iterator end() <span class="kw">noexcept</span>
{ <span class="kw">return</span> last ; }</code></pre></div>
<p>これは簡単だ。<code>iterator</code>型は実際には<code>T *</code>型へのエイリアスだ。このメンバー関数は例外を投げないので<code>noexcept</code>を指定する。</p>
<p><code>vector</code>のオブジェクトが<code>const</code>の場合、<code>begin/end</code>は<code>const_iterator</code>が返る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">1</span>) ;
    <span class="co">// std::vector&lt;int&gt;::iterator</span>
    <span class="kw">auto</span> i = v.begin() ;
    <span class="co">// OK、代入可能</span>
    *i = <span class="dv">0</span> ;
    <span class="co">// constなvectorへのリファレンス</span>
    <span class="kw">auto</span> <span class="dt">const</span> &amp; cv = v ;
    <span class="co">// std::vector&lt;int&gt;::const_iterator</span>
    <span class="kw">auto</span> ci = cv.begin() ;
    <span class="co">// エラー</span>
    <span class="co">// const_iteratorを参照した先には代入できない</span>
    *ci = <span class="dv">0</span> ;
}</code></pre></div>
<p>これを実現するには、メンバー関数を<code>const</code>修飾する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Foo
{
    <span class="co">// 非const版</span>
    <span class="dt">void</span> f() {}
    <span class="co">// const版</span>
    <span class="dt">void</span> f() <span class="dt">const</span> { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// aは非constなオブジェクト</span>
    Foo a ;
    <span class="co">// 非const版が呼ばれる</span>
    a.f() ;
    <span class="co">// constなリファレンス</span>
    <span class="dt">const</span> Foo &amp; cref = a ;
    <span class="co">// const版が呼ばれる</span>
    cref.f() ;
}</code></pre></div>
<p>すでに学んだように<code>const</code>修飾は<code>this</code>ポインターを修飾する。オブジェクトの<code>const</code>性によって、適切な方のメンバー関数が呼ばれてくれる。</p>
<p>簡易<code>vector</code>での実装は単に<code>const</code>修飾するだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">iterator begin() <span class="dt">const</span> <span class="kw">noexcept</span>
{ <span class="kw">return</span> first ; }
iterator end() <span class="dt">const</span> <span class="kw">noexcept</span>
{ <span class="kw">return</span> last ; }</code></pre></div>
<p><code>const</code>ではない<code>vector</code>のオブジェクトから<code>const_iterator</code>がほしいときに、わざわざ<code>const</code>なリファレンスに変換するのは面倒なので、<code>const_reference</code>を返す<code>cbegin</code>/<code>cend</code>もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">1</span>) ;
    <span class="co">// std::vector&lt;int&gt;::const_iterator</span>
    <span class="kw">auto</span> i = v.cbegin() ;
}</code></pre></div>
<p>この実装はメンバー関数名以外同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">const_iterator cbegin() <span class="dt">const</span> <span class="kw">noexcept</span>
{ <span class="kw">return</span> first ; }
const_iterator cend() <span class="dt">const</span> <span class="kw">noexcept</span>
{ <span class="kw">return</span> last ; }</code></pre></div>
<p><code>std::vector</code>にはリバースイテレーターを返すメンバー関数<code>rbegin</code>/<code>rend</code>と<code>crbegin</code>/<code>crend</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    <span class="co">// イテレーター</span>
    <span class="kw">auto</span> i = v.begin() ;
    *i ; <span class="co">// 1</span>

    <span class="co">// リバースイテレーター</span>
    <span class="kw">auto</span> r = v.rbegin() ;
    *r ; <span class="co">// 5</span>
}</code></pre></div>
<p><code>begin</code>に対する<code>rbegin</code>/<code>rend</code>の実装は以下のようになる。<code>crbegin</code>/<code>crend</code>は自分で実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">reverse_iterator rbegin() <span class="kw">noexcept</span>
{ <span class="kw">return</span> reverse_iterator{ last } ; }
reverse_iterator rend() <span class="kw">noexcept</span>
{ <span class="kw">return</span> reverse_iterator{ first } ; }</code></pre></div>
<p><code>return</code>文で<code>T{e}</code>という形の明示的な型変換を使っている。これには理由がある。</p>
<p>C++では引数が1つしかないコンストラクターを<code>変換コンストラクター</code>として特別に扱う。</p>
<p>例えば以下は数値のように振る舞う<code>Number</code>クラスの例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Number
{
    Number( <span class="dt">int</span> i ) ;
    Number( <span class="dt">double</span> d ) ;
    Number( std::string s ) ;
} ;</code></pre></div>
<p>この<code>Number</code>は初期値をコンストラクターで取る。そのとき、<code>int</code>型、<code>double</code>型、はては文字列で数値を表現した<code>std::string</code>型まで取る。この3つのコンストラクターは引数が1つしかないため変換コンストラクターだ。</p>
<p>クラスは変換コンストラクターの引数の型から暗黙に型変換できる。</p>
<p>例えば<code>Number</code>クラスを引数に取る関数があると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> print_number( Number n ) ;</code></pre></div>
<p>変換コンストラクターの型の値を渡せる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型から変換</span>
    print_number( <span class="dv">123</span> ) ;
    <span class="co">// double型から変換</span>
    print_number( <span class="fl">3.14</span> ) ;
    <span class="co">// std::string型から変換</span>
    print_number( <span class="st">&quot;3.14&quot;</span>s ) ;
}</code></pre></div>
<p><code>int</code>や<code>double</code>や<code>std::string</code>は<code>Number</code>ではないが、変換コンストラクターによって暗黙に型変換される。</p>
<p>戻り値として返すときにも変換できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Number型のゼロを返す</span>
Number zero()
{
    <span class="co">// int型から変換</span>
    <span class="kw">return</span> <span class="dv">0</span> ;
}</code></pre></div>
<p>しかし、場合によってはこのような暗黙の型変換を行いたくないこともある。そういう場合、コンストラクターに<code>explicit</code>キーワードを付けると、暗黙の型変換を禁止させることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Number
{
    <span class="kw">explicit</span> Number( <span class="dt">int</span> i ) ;
    <span class="kw">explicit</span> Number( <span class="dt">double</span> d ) ;
    <span class="kw">explicit</span> Number( std::string s ) ;
} ;</code></pre></div>
<p>実は<code>std::reverse_iterator&lt;Iterator&gt;</code>のコンストラクターにも<code>explicit</code>キーワードが付いている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">template</span>&lt; <span class="kw">typename</span>  Iterator &gt;
<span class="kw">class</span> reverse_iterator
{
    <span class="kw">constexpr</span> <span class="kw">explicit</span> reverse_iterator(Iterator x);
    <span class="co">// ...</span>
} ;
}</code></pre></div>
<p><code>explicit</code>キーワード付きの変換コンストラクターを持つクラスは、暗黙の型変換ができないので、明示的に型変換しなければならない。</p>
<h3 id="容量確認">容量確認</h3>
<p><code>std::vector</code>には容量を確認するメンバー関数がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// true、要素数0</span>
    <span class="dt">bool</span> a = v.empty() ;
    v.push_back(<span class="dv">0</span>) ;
    <span class="co">// false、要素数非ゼロ</span>
    <span class="dt">bool</span> b = v.empty() ;
    <span class="co">// 1、現在の要素数</span>
    <span class="kw">auto</span> s = v.size() ;
    <span class="co">// 実装依存、追加の動的メモリー確保をせずに格納できる要素の最大数</span>
    <span class="kw">auto</span> c = v.capacity() ;
}</code></pre></div>
<p>さっそく実装していこう。</p>
<p><code>size</code>は要素数を返す。イテレーターの距離を求めればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_type size() <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> end() - begin() ;
}</code></pre></div>
<p>イテレーターライブラリを使ってもよい。本物の<code>std::vector</code>では以下のように実装されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_type size() <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> std::distance( begin(), end() ) ;
}</code></pre></div>
<p><code>empty</code>は空であれば<code>true</code>、そうでなければ<code>false</code>を返す。「空」というのは要素数がゼロという意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> empty() <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> size() == <span class="dv">0</span> ;
}</code></pre></div>
<p>しかし<code>size() == 0</code>というのは、<code>begin() == end()</code>ということだ。なぜならば要素数が0であれば、イテレーターのペアはどちらも終端のイテレーターを差しているからだ。本物の<code>std::vector</code>では以下のように実装されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> empty() <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> begin() == end() ;
}</code></pre></div>
<p><code>capacity</code>は、追加の動的メモリー確保をせずに追加できる要素の最大数を返す。これを計算するには、動的確保したストレージの末尾の1つ次のポインターであるデータメンバーである<code>reserved_last</code>を使う。最初の要素へのポインターである<code>first</code>から<code>reserved_last</code>までの距離が答えだ。ポインターの距離はイテレーターと同じく引き算する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">size_type capacity() <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> reserved_last - first ;
}</code></pre></div>
<h3 id="要素アクセス">要素アクセス</h3>
<h4 id="operator">operator []</h4>
<p><code>std::vector</code>の<code>operator []</code>相当のものを簡易<code>vector</code>にも実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    v[<span class="dv">1</span>] ; <span class="co">// 2</span>
    v[<span class="dv">3</span>] ; <span class="co">// 4</span>
}</code></pre></div>
<p><code>operator []</code>は非<code>const</code>版と<code>const</code>版の2種類がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">reference <span class="kw">operator</span> []( size_type i )
{ <span class="kw">return</span> first[i] ; }
const_reference <span class="kw">operator</span> []( size_type i ) <span class="dt">const</span>
{ <span class="kw">return</span> first[i] ; }</code></pre></div>
<h4 id="at">at</h4>
<p>メンバー関数<code>at(i)</code>は<code>operator [](i)</code>と同じだが、範囲外のインデックスを指定した場合、<code>std::out_of_range</code>が例外として投げられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">try</span> {
        <span class="co">// 有効なインデックスはv[0]からv[4]まで</span>
        std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
        v[<span class="dv">0</span>] = <span class="dv">0</span> ; <span class="co">// OK</span>
        v[<span class="dv">3</span>] = <span class="dv">0</span> ; <span class="co">// OK</span>
        v[<span class="dv">5</span>] = <span class="dv">0</span> ; <span class="co">// エラー</span>
    } <span class="kw">catch</span>( std::out_of_range e )
    {
        std::cout &lt;&lt; e.what() ;
    }
}</code></pre></div>
<p>実装はインデックスを<code>size()</code>と比較して、範囲外であれば<code>std::out_of_range</code>を<code>throw</code>する。<code>operator []</code>と同じく、非<code>const</code>版と<code>const</code>版がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">reference at( size_type i )
{
    <span class="kw">if</span> ( i &gt;= size() )
        <span class="kw">throw</span> std::out_of_range( <span class="st">&quot;index is out of range.&quot;</span> ) ;

    <span class="kw">return</span> first[i] ;
}
const_reference at( size_type i ) <span class="dt">const</span>
{
    <span class="kw">if</span> ( i &gt;= size() )
        <span class="kw">throw</span> std::out_of_range( <span class="st">&quot;index is out of range.&quot;</span> ) ;

    <span class="kw">return</span> first[i] ;
}</code></pre></div>
<h4 id="frontback">front/back</h4>
<p><code>front()</code>は先頭要素へのリファレンスを返す。</p>
<p><code>back()</code>は末尾の要素へのリファレンスを返す</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    v.front() ; <span class="co">// 1</span>
    v.back() ; <span class="co">// 5</span>
}</code></pre></div>
<p>これにも<code>const</code>版と非<code>const</code>版がある。<code>vector</code>の<code>last</code>が最後の要素の次のポインターを指していることに注意。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">reference front()
{ <span class="kw">return</span> first ; }
const_reference front() <span class="dt">const</span>
{ <span class="kw">return</span> first ; }
reference back()
{ <span class="kw">return</span> last - <span class="dv">1</span> ; }
const_reference back() <span class="dt">const</span>
{ <span class="kw">return</span> last - <span class="dv">1</span> ; }</code></pre></div>
<h4 id="data">data</h4>
<p><code>data()</code>は先頭の要素へのポインターを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="dt">int</span> * ptr = v.data() ;
    *ptr ; <span class="co">// 1</span>
}</code></pre></div>
<p>実装は<code>first</code>を返すだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pointer data() <span class="kw">noexcept</span>
{ <span class="kw">return</span> first ; }
const_pointer data() <span class="dt">const</span> <span class="kw">noexcept</span>
{ <span class="kw">return</span> first ; }</code></pre></div>
<h1 id="vectorの実装-メモリー確保">vectorの実装 : メモリー確保</h1>
<h2 id="メモリー確保と解放の起こるタイミング">メモリー確保と解放の起こるタイミング</h2>
<p><code>std::vector</code>はどこでメモリーを確保と解放しているのだろうか。</p>
<p>デフォルト構築すると空になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    v.empty() ; <span class="co">// true</span>
}</code></pre></div>
<p>コンストラクターに要素数を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">100</span>) ;
    v.size() ; <span class="co">// 100</span>
}</code></pre></div>
<p>すると<code>std::vector</code>は指定した要素数の有効な要素を持つ。</p>
<p>コンストラクターに要素数と初期値を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">100</span>, <span class="dv">123</span>) ;
    v[<span class="dv">0</span>] ; <span class="co">// 123</span>
    v[<span class="dv">12</span>] ; <span class="co">// 123</span>
    v[<span class="dv">68</span>] ; <span class="co">// 123</span>
}</code></pre></div>
<p>すると、指定した要素数で、要素の値はすべて初期値になる。</p>
<p><code>vector</code>のオブジェクトを構築したあとでも、メンバー関数<code>resize(size)</code>で要素数を<code>size</code>個にできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    v.resize(<span class="dv">10</span>) ;
    v.size() ; <span class="co">// 10</span>
    <span class="co">// 減らす</span>
    v.resize(<span class="dv">5</span>) ;
    v.size() ; <span class="co">// 5</span>
}</code></pre></div>
<p><code>resize</code>で要素数が増える場合、増えた要素の初期値も指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    v.resize(<span class="dv">3</span>, <span class="dv">123</span>) ;
    <span class="co">// vは{123,123,123}</span>
}</code></pre></div>
<p><code>resize</code>で要素数が減る場合、末尾が削られる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    v.resize(<span class="dv">3</span>) ;
    <span class="co">// vは{1,2,3}</span>
}</code></pre></div>
<p>メンバー関数<code>push_back(value)</code>を呼び出すと要素数が1増え、要素の末尾の要素が値<code>value</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// vは{}</span>
    v.push_back(<span class="dv">1</span>) ;
    <span class="co">// vは{1}</span>
    v.push_back(<span class="dv">2</span>) ;
    <span class="co">// vは[1,2}</span>
    v.push_back(<span class="dv">3</span>) ;
    <span class="co">// vは{1,2,3}</span>
}</code></pre></div>
<p><code>reserve(size)</code>は少なくとも<code>size</code>個の要素が追加の動的メモリー確保なしで追加できるようにメモリーを予約する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// 少なくとも3個の要素を追加できるように動的メモリー確保</span>
    v.reserve(<span class="dv">3</span>) ;
    v.size() ; <span class="co">// 0</span>
    v.capacity() ; <span class="co">// 3以上</span>

    <span class="co">// 動的メモリー確保は発生しない</span>
    v.push_back(<span class="dv">1</span>) ;
    v.push_back(<span class="dv">2</span>) ;
    v.push_back(<span class="dv">3</span>) ;
    <span class="co">// 動的メモリー確保が発生する可能性がある。</span>
    v.push_back(<span class="dv">3</span>) ;
}</code></pre></div>
<p><code>clear()</code>は要素数を0にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    v.clear() ;
    v.size() ; <span class="co">// 0</span>
}</code></pre></div>
<p>この章ではここまでの実装をする。</p>
<h2 id="デフォルトコンストラクター">デフォルトコンストラクター</h2>
<p>簡易<code>vector</code>のデフォルトコンストラクターは何もしない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector( ) { }</code></pre></div>
<p>何もしなくてもポインターはすべて<code>nullptr</code>で初期化され、アロケーターもデフォルト構築されるからだ。</p>
<p>これで簡易<code>vector</code>の変数を作れるようになった。ただしまだ何もできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// まだ何もできない。</span>
}</code></pre></div>
<h2 id="アロケーターを取るコンストラクター">アロケーターを取るコンストラクター</h2>
<p><code>std::vector</code>のコンストラクターは最後の引数にアロケーターを取れる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::allocator&lt;<span class="dt">int</span>&gt; alloc ;
    <span class="co">// 空</span>
    std::vector&lt;<span class="dt">int</span>&gt; v1(alloc) ;
    <span class="co">// 要素数5</span>
    std::vector&lt;<span class="dt">int</span>&gt; v2(<span class="dv">5</span>, alloc) ;
    <span class="co">// 要素数5で初期値123</span>
    std::vector&lt;<span class="dt">int</span>&gt; v3(<span class="dv">5</span>, <span class="dv">123</span>, alloc) ;
}</code></pre></div>
<p>これを実装するには、アロケーターを取ってデータメンバーにコピーするコンストラクターを書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector( <span class="dt">const</span> allocator_type &amp; alloc ) <span class="kw">noexcept</span>
    : alloc( alloc )
{ }</code></pre></div>
<p>ほかのコンストラクターはこのコンストラクターにまずデリゲートすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector()
    : vector( allocator_type() )
{ }

vector( size_type size, <span class="dt">const</span> allocator_type &amp; alloc = allocator_type() )
    : vector( alloc )
{ <span class="co">/*実装*/</span> }
vector( size_type size, const_reference value, <span class="dt">const</span> allocator_type &amp; alloc = allocator_type() )
    : vector( alloc )
{ <span class="co">/*実装*/</span> }</code></pre></div>
<h2 id="要素数と初期値を取るコンストラクターの実装">要素数と初期値を取るコンストラクターの実装</h2>
<p>要素数と初期値を取るコンストラクターは<code>resize</code>を使えば簡単に実装できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector( size_type size, <span class="dt">const</span> allocator_type &amp; alloc )
    : vector( alloc )
{
    resize( size ) ;
}
vector( size_type size, const_reference value, <span class="dt">const</span> allocator_type &amp; alloc )
    : vector( alloc )
{
    resize( size, value ) ;
}</code></pre></div>
<p>しかしこれは実装を<code>resize</code>に丸投げしただけだ。<code>resize</code>の実装をする前に、実装を楽にするヘルパー関数を実装する。</p>
<h2 id="ヘルパー関数">ヘルパー関数</h2>
<p>ここでは<code>vector</code>の実装を楽にするためのヘルパー関数をいくつか実装する。このヘルパー関数はユーザーから使うことは想定しないので、<code>private</code>メンバーにする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 例</span>
<span class="kw">struct</span> vector
{
<span class="kw">private</span> :
    <span class="co">// ユーザーからは使えないヘルパー関数</span>
    <span class="dt">void</span> helper_function() ;
<span class="kw">public</span> :
    <span class="co">// ユーザーが使える関数</span>
    <span class="dt">void</span> func()
    {
        <span class="co">// ヘルパー関数を使って実装</span>
        helper_function() ;
    }
} ;</code></pre></div>
<h3 id="ネストされた型名traits">ネストされた型名traits</h3>
<p>アロケーターは<code>allocator_traits</code>を経由して使う。実際のコードはとても冗長になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Allocator &gt;
<span class="dt">void</span> f( Allocator &amp; alloc )
{
    std::allocator_traits&lt;Allocator&gt;::allocate( alloc, <span class="dv">1</span> ) ;
}</code></pre></div>
<p>この問題はエイリアス名を使えば解決できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">private</span> :
    <span class="kw">using</span> traits = std::allocator_traits&lt;allocator_type&gt; ;

    <span class="kw">template</span> &lt; <span class="kw">typename</span> Allocator &gt;
    <span class="dt">void</span> f( Allocator &amp; alloc )
    {
        traits::allocate( alloc, <span class="dv">1</span> ) ;
    }</code></pre></div>
<h3 id="allocatedeallocate">allocate/deallocate</h3>
<p><code>allocate(n)</code>はアロケーターから<code>n</code>個の要素を格納できる生のメモリーの動的確保をして先頭要素へのポインターを返す。</p>
<p><code>deallocate(ptr)</code>はポインター<code>ptr</code>を解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">private</span>: 
    pointer allocate( size_type n )
    { <span class="kw">return</span> traits::allocate( alloc, n ) ; }
    <span class="dt">void</span> deallocate( )
    { traits::deallocate( alloc, first, capacity() ) ; }</code></pre></div>
<h3 id="constructdestroy">construct/destroy</h3>
<p><code>construct(ptr)</code>は生のメモリーへのポインター<code>ptr</code>に<code>vector</code>の<code>value_type</code>型の値をデフォルト構築する。</p>
<p><code>construct(ptr, value)</code>は生のメモリーへのポインター<code>ptr</code>に値<code>value</code>のオブジェクトを構築する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="dt">void</span> construct( pointer ptr )
    { traits::construct( alloc, ptr ) ; }
    <span class="dt">void</span> construct( pointer ptr, const_reference value )
    { traits::construct( alloc, ptr, value ) ; }
    <span class="co">// ムーブ用</span>
    <span class="dt">void</span> construct( pointer ptr, value_type &amp;&amp; value )
    { traits::construct( alloc, ptr, std::move(value) ) ; }</code></pre></div>
<p>ムーブ用の<code>construct</code>についてはまだ気にする必要はない。この理解には、まずムーブセマンティクスを学ぶ必要がある。</p>
<p><code>destroy(ptr)</code>は<code>ptr</code>の指すオブジェクトを破棄する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">private</span> :
    <span class="dt">void</span> destroy( pointer ptr )
    { traits::destroy( alloc, ptr ) ; }</code></pre></div>
<h3 id="destroy_until"><code>destroy_until</code></h3>
<p><code>destroy_until(rend)</code>は、<code>vector</code>が保持する<code>rbegin()</code>からリバースイテレーター<code>rend</code>までの要素を破棄する。リバースイテレーターを使うので、要素の末尾から先頭に向けて順番に破棄される。なぜ末尾から先頭に向けて要素を破棄するかというと、C++では値の破棄は構築の逆順で行われるという原則があるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">private</span> :
    <span class="dt">void</span> destroy_until( reverse_iterator rend )
    {
        <span class="kw">for</span> ( <span class="kw">auto</span> riter = rbegin() ; riter != rend ; ++riter, --last )
        {
            destroy( &amp;*riter ) ;
        }
    }</code></pre></div>
<p><code>&amp;*riter</code>はやや泥臭い方法だ。簡易<code>vector&lt;T&gt;</code>の<code>iterator</code>は単なる<code>T *</code>だが、<code>riter</code>はリバースイテレーターなのでポインターではない。ポインターを取るために<code>*riter</code>でまず<code>T &amp;</code>を得て、そこに<code>&amp;</code>を適用することで<code>T *</code>を得ている。</p>
<p>破棄できたら有効な要素数を減らすために<code>--last</code>する。</p>
<h2 id="clear">clear</h2>
<p><code>clear()</code>はすべての要素を破棄する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> clear() <span class="kw">noexcept</span>
{
    destroy_until( rend() ) ;
}</code></pre></div>
<p>先ほど実装した<code>destroy_until(rend)</code>にリバースイテレーターの終端を渡せばすべての要素が破棄される。</p>
<h2 id="デストラクター">デストラクター</h2>
<p>ヘルパー関数を組み合わせることでデストラクターが実装できるようになった。</p>
<p><code>std::vector</code>のデストラクターは、</p>
<ol style="list-style-type: decimal">
<li>要素を末尾から先頭に向かう順番で破棄</li>
<li>生のメモリーを解放する</li>
</ol>
<p>この2つの処理はすでに実装した。デストラクターの実装は単にヘルパー関数を並べて呼び出すだけでよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">~vector()
{
    <span class="co">// 1. 要素を末尾から先頭に向かう順番で破棄</span>
    clear() ;
    <span class="co">// 2. 生のメモリーを解放する</span>
    deallocate() ;    
}         </code></pre></div>
<h2 id="reserveの実装">reserveの実装</h2>
<p><code>reserve</code>の実装は生の動的メモリーを確保してデータメンバーを適切に設定する。</p>
<p>ただし、いろいろと考慮すべきことが多い。</p>
<p>現在の<code>capacity</code>より小さい要素数が<code>reserve</code>された場合、無視してよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素数5</span>
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// 3個の要素を保持できるよう予約</span>
    v.reserve( <span class="dv">3</span> ) ;
    <span class="co">// 無視する</span>
}</code></pre></div>
<p>すでに指定された要素数以上に予約されているからだ。</p>
<p>動的メモリー確保が行われていない場合、単に動的メモリー確保をすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// おそらく動的メモリー確保</span>
    v.reserve( <span class="dv">10000</span> ) ;
}</code></pre></div>
<p>「おそらく」というのは、C++の規格は<code>vector</code>のデフォルトコンストラクターが予約するストレージについて何も言及していないからだ。すでに要素数10000を超えるストレージが予約されている実装も規格準拠だ。本書で実装している<code>vector</code>は、デフォルトコンストラクターでは動的メモリー確保をしない実装になっている。</p>
<p>有効な要素が存在する場合、その要素の値は引き継がなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素数3</span>
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="co">// 1万個の要素を保持できるだけのメモリーを予約</span>
    v.reserve( <span class="dv">10000</span> ) ;
    <span class="co">// vは{1,2,3}</span>
}</code></pre></div>
<p>つまり動的メモリー確保をしたあとに、既存の要素を新しいストレージにコピーしなければならないということだ。</p>
<p>まとめよう。</p>
<ol style="list-style-type: decimal">
<li>すでに指定された要素数以上に予約されているなら何もしない</li>
<li>まだ動的メモリー確保が行われていなければ動的メモリー確保をする</li>
<li>有効な要素がある場合は新しいストレージにコピーする</li>
</ol>
<p>古いストレージから新しいストレージに要素をコピーするとき、古いストレージと新しいストレージが一時的に同時に存在しなければならない。</p>
<p>疑似コード風に記述すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="co">// すでに動的確保した古いストレージ</span>
    <span class="kw">auto</span> old_ptr = <span class="kw">new</span> T ;

    <span class="co">// いま構築した新しいストレージ</span>
    <span class="kw">auto</span> new_ptr = <span class="kw">new</span> T ;
    <span class="co">// 古いストレージから新しいストレージにコピー</span>
    <span class="co">// *new_ptr = *old_ptr ;</span>
    <span class="co">// 古いストレージを解放</span>
    <span class="kw">delete</span> old_value ;
}</code></pre></div>
<p>このとき、<code>T</code>型がコピーの最中に例外を投げると、後続の<code>delete</code>が実行されなくなる。この問題に対処して例外安全にするために、C++20に入る見込みの標準ライブラリ、<code>std::scope_exit</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="co">// すでに動的確保した古いストレージ</span>
    <span class="kw">auto</span> old_ptr = <span class="kw">new</span> T ;

    <span class="co">// いま構築した新しいストレージ</span>
    <span class="kw">auto</span> new_ptr = <span class="kw">new</span> T ;

    <span class="co">// 関数fを抜けるときに古いストレージを解放する。</span>
    std::scope_exit e( [&amp;]{ <span class="kw">delete</span> old_ptr ; } ) ;

    <span class="co">// 古いストレージから新しいストレージにコピー</span>
    <span class="co">// *new_ptr = *old_ptr ;</span>

    <span class="co">// 変数eの破棄に伴って古いストレージが解放される</span>
}</code></pre></div>
<p>これを踏まえて<code>reserve</code>を実装する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reserve( size_type sz )
{
    <span class="co">// すでに指定された要素数以上に予約されているなら何もしない</span>
    <span class="kw">if</span> ( sz &lt;= capacity() )
        <span class="kw">return</span> ;

    <span class="co">// 動的メモリー確保をする</span>
    <span class="kw">auto</span> ptr = allocate( sz ) ;

    <span class="co">// 古いストレージの情報を保存</span>
    <span class="kw">auto</span> old_first = first ;
    <span class="kw">auto</span> old_last = last ;
    <span class="kw">auto</span> old_capacity = capacity() ;

    <span class="co">// 新しいストレージに差し替え</span>
    first = ptr ;
    last = first ;
    reserved_last = first + sz ;

    <span class="co">// 例外安全のため</span>
    <span class="co">// 関数を抜けるときに古いストレージを破棄する</span>
    std::scope_exit e( [&amp;]{
        traits::deallocate( alloc, old_first, old_capacity  ) ;
    } ) ;

    <span class="co">// 古いストレージから新しいストレージに要素をコピー構築</span>
    <span class="co">// 実際にはムーブ構築</span>
    <span class="kw">for</span> ( <span class="kw">auto</span> old_iter = old_first ; old_iter != old_last ; ++old_iter, ++last )
    {
        <span class="co">// このコピーの理解にはムーブセマンティクスの理解が必要</span>
        construct( last, std::move(*old_iter) ) ;
    }

    <span class="co">// 新しいストレージにコピーし終えたので</span>
    <span class="co">// 古いストレージの値は破棄</span>
    <span class="kw">for</span> (   <span class="kw">auto</span> riter = reverse_iterator(old_last), rend = reverse_iterator(old_first) ;
            riter != rend ; ++riter )
    {
        destroy( &amp;*riter ) ;
    }
    <span class="co">// scope_exitによって自動的にストレージが破棄される</span>
}</code></pre></div>
<p>ここではまだ学んでいないムーブの概念が出てくる。これはムーブセマンティクスの章で詳しく学ぶ。</p>
<h2 id="resize">resize</h2>
<p><code>resize(sz)</code>は要素数を<code>sz</code>個にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素数0</span>
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// 要素数10</span>
    v.resize(<span class="dv">10</span>) ;
    <span class="co">// 要素数5</span>
    v.resize(<span class="dv">5</span>)
    <span class="co">// 要素数変わらず</span>
    v.resize(<span class="dv">5</span>)
}</code></pre></div>
<p><code>resize</code>は呼び出し前より要素数を増やすことも減らすこともある。また変わらないこともある。</p>
<p>要素数が増える場合、増えた要素数の値はデフォルト構築された値になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X() { std::cout &lt;&lt; <span class="st">&quot;default constructed.</span><span class="ch">\n</span><span class="st">&quot;</span> ; }
} ;

<span class="dt">int</span> main()
{
    std::vector&lt;X&gt; v ;
    v.resize(<span class="dv">5</span>) ;
}</code></pre></div>
<p>このプログラムを実行すると、<code>&quot;default constructed.\n&quot;</code>は5回標準出力される。</p>
<p><code>resize(sz, value)</code>は<code>resize</code>を呼び出した結果要素が増える場合、その要素を<code>value</code>で初期化する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    v.resize(<span class="dv">5</span>, <span class="dv">4</span>) ;
    <span class="co">// vは{1,2,3,4,4} </span>
}</code></pre></div>
<p>要素数が減る場合、要素は末尾から順番に破棄されていく。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X()
    { std::cout &lt;&lt; <span class="st">&quot;destructed.</span><span class="ch">\n</span><span class="st">&quot;</span>s ; }
} ;

<span class="dt">int</span> main()
{
    std::vector&lt;X&gt; v(<span class="dv">5</span>) ;
    v.resize(<span class="dv">2</span>) ;
    std::cout &lt;&lt; <span class="st">&quot;resized.</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}</code></pre></div>
<p>このプログラムを実行すると、以下のように出力される。</p>
<pre><code>destructed.
destructed.
destructed.
resized.
destructed.
destructed.</code></pre>
<p>最初の<code>v.resize(2)</code>で、<code>v[4], v[3], v[2]</code>が書いた順番で破棄されていく。<code>main</code>関数を抜けるときに残りの<code>v[1], v[0]</code>が破棄される。</p>
<p><code>resize(sz)</code>を呼び出したときに<code>sz</code>が現在の要素数と等しい場合は何もしない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素数5</span>
    std::vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">5</span>) ;
    v.resize(<span class="dv">5</span>) ; <span class="co">// 何もしない   </span>
}</code></pre></div>
<p>まとめると<code>resize</code>は以下のように動作する。</p>
<ol style="list-style-type: decimal">
<li>現在の要素数より少なくリサイズする場合、末尾から要素を破棄する</li>
<li>現在の要素数より大きくリサイズする場合、末尾に要素を追加する</li>
<li>現在の要素数と等しくリサイズする場合、何もしない</li>
</ol>
<p>実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    <span class="dt">void</span> resize( size_type sz )
    {
        <span class="co">// 現在の要素数より少ない</span>
        <span class="kw">if</span> ( sz &lt; size() )
        {
            <span class="kw">auto</span> diff = size() - sz ;
            destroy_until( rbegin() + diff ) ;
            last = first + sz ;
        }
        <span class="co">// 現在の要素数より大きい</span>
        <span class="kw">else</span> <span class="kw">if</span> ( sz &gt; size() )
        {
            reserve( sz ) ;
            <span class="kw">for</span> ( ; last != reserved_last ; ++last )
            {
                construct( last ) ;
            }
        }
    }</code></pre></div>
<p>要素を破棄する場合、破棄する要素数だけ末尾から順番に破棄する。</p>
<p>要素を増やす場合、<code>reserve</code>を呼び出してメモリーを予約してから、追加の要素を構築する。</p>
<p><code>sz == size()</code>の場合は、どちらの<code>if</code>文の条件にも引っかからないので、何もしない。</p>
<p><code>size(sz, value)</code>は、追加の引数を取るほか、<code>construct( iter )</code>の部分が<code>construct( iter, value )</code>に変わるだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> resize( size_type sz, const_reference value )
{
    <span class="co">// ...</span>
            construct( iter, value ) ;
    <span class="co">// ...</span>
}</code></pre></div>
<p>これで自作の<code>vector</code>はある程度使えるようになった。コンストラクターで要素数を指定できるし、リサイズもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">10</span>, <span class="dv">1</span>) ;
    v[<span class="dv">2</span>] = <span class="dv">99</span> ;
    v.resize(<span class="dv">5</span>) ;
    <span class="co">// vは{1,1,99,1,1}</span>
}</code></pre></div>
<h2 id="push_back">push_back</h2>
<p><code>push_back</code>は<code>vector</code>の末尾に要素を追加する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="co">// vは{}</span>
    v.push_back(<span class="dv">1</span>) ;
    <span class="co">// vは{1}</span>
    v.push_back(<span class="dv">2</span>) ;
    <span class="co">// vは{1,2}</span>
}</code></pre></div>
<p><code>push_back</code>の実装は、末尾の予約された未使用のストレージに値を構築する。もし予約された未使用のストレージがない場合は、新しく動的メモリー確保する。</p>
<p>追加の動的メモリー確保なしで保持できる要素の個数はすでに実装した<code>capacity()</code>で取得できる。<code>push_back</code>は要素を1つ追加するので、<code>size() + 1 &lt;= capacity()</code>ならば追加の動的メモリー確保はいらない。逆に、<code>size() + 1 &gt; capacity()</code>ならば追加の動的メモリー確保をしなければならない。追加の動的メモリー確保はすでに実装した<code>reserve</code>を使えばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> push_back( const_reference value ) 
{
    <span class="co">// 予約メモリーが足りなければ拡張</span>
    <span class="kw">if</span> ( size() + <span class="dv">1</span> &gt; capacity() )
    {
        <span class="co">// 1つだけ増やす</span>
        reserve( size() + <span class="dv">1</span> ) ;
    }

    <span class="co">// 要素を末尾に追加</span>
    construct( last, value ) ;
    <span class="co">// 有効な要素数を更新</span>
    ++last ;
}</code></pre></div>
<p>これは動く。ただし、効率的ではない。自作の<code>vector</code>を使った以下のような例を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素数10000</span>
    vector&lt;<span class="dt">int</span>&gt; v(<span class="dv">1000</span>) ;
    <span class="co">// 10001個分のメモリーを確保する</span>
    <span class="co">// 10000個の既存の要素をコピーする</span>
    v.push_back(<span class="dv">0</span>) ;
    <span class="co">// 10002個分のメモリーを確保する</span>
    <span class="co">// 10001個の既存の要素をコピーする</span>
    v.push_back(<span class="dv">0</span>) ;
}</code></pre></div>
<p>たった1つの要素を追加するのに、毎回動的メモリー確保と既存の全要素のコピーをしている。これは無駄だ。</p>
<p><code>std::vector</code>は<code>push_back</code>で動的メモリー確保が必要な場合、<code>size()+1</code>よりも多くメモリーを確保する。こうすると、<code>push_back</code>を呼び出すたびに毎回動的メモリー確保と全要素のコピーを行う必要がなくなるので、効率的になる。</p>
<p>ではどのくらい増やせばいいのか。10個ずつ増やす戦略は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> push_back( const_reference value ) 
{
    <span class="co">// 予約メモリーが足りなければ拡張</span>
    <span class="kw">if</span> ( size() + <span class="dv">1</span> &gt; capacity() )
    {
        <span class="co">// 10個増やす</span>
        reserve( capacity() + <span class="dv">10</span> ) ;
    }
    construct( last, value ) ;
    ++last ;
}</code></pre></div>
<p>しかしこの場合、以下のようなコードで効率が悪い。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="kw">for</span> ( <span class="kw">auto</span> i = <span class="dv">0</span> ; i != <span class="dv">10000</span> ; ++i )
    {
        v.push_back(i) ;
    }
}</code></pre></div>
<p>10個ずつ増やす戦略では、この場合に1000回の動的メモリー確保と全要素のコピーが発生する。</p>
<p>上のような場合、<code>vector</code>の利用者が事前に<code>v.reserve(10000)</code>とすれば効率的になる。しかし、コンパイル時に要素数がわからない場合、その手も使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; inputs ;
    <span class="co">// 要素数は実行時にしかわからない</span>
    <span class="co">// 10万個の入力が行われるかもしれない</span>
    std::copy(
        std::ostream_iterator&lt;<span class="dt">int</span>&gt;(std::cin),
        std::ostream_iterator&lt;<span class="dt">int</span>&gt;(),
        std::back_inserter(inputs) ) ;
}</code></pre></div>
<p>よくある実装は、現在のストレージサイズの2倍のストレージを確保する戦略だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> push_back( const_reference value ) 
{
    <span class="co">// 予約メモリーが足りなければ拡張</span>
    <span class="kw">if</span> ( size() + <span class="dv">1</span> &gt; capacity() )
    {
        <span class="co">// 現在のストレージサイズ</span>
        <span class="kw">auto</span> c = size() ;
        <span class="co">// 0の場合は1に</span>
        <span class="kw">if</span> ( c == <span class="dv">0</span> )
            c = <span class="dv">1</span> ;
        <span class="kw">else</span>
            <span class="co">// それ以外の場合は2倍する</span>
            c *= <span class="dv">2</span> ;

        reserve( c ) ;
    }
    construct( last, value ) ;
    ++last ;
}</code></pre></div>
<p><code>size()</code>は<code>0</code>を返す場合もあるということに注意。単に<code>reserve(size()*2)</code>としたのでは<code>size() == 0</code>のときに動かない。</p>
<h3 id="shrink_to_fit"><code>shrink_to_fit</code></h3>
<p><code>shrink_to_fit()</code>は<code>vector</code>が予約しているメモリーのサイズを実サイズに近づけるメンバー関数だ。</p>
<p>本書で実装してきた自作の<code>vector</code>は、<code>push_back</code>時に予約しているメモリーがなければ、現在の要素数の2倍のメモリーを予約する実装だった。すると以下のようなコードで、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    vector&lt;<span class="dt">int</span>&gt; v ;
    std::copy( std::istream_iterator&lt;<span class="dt">int</span>&gt;(std::cin), std::istream_iterator&lt;<span class="dt">int</span>&gt;(),
        std::back_inserter(v) ) ;
}</code></pre></div>
<p>ユーザーが4万個の<code>int</code>型の値を入力した場合、65536個の<code>int</code>型の値を保持できるだけのメモリーが確保されてしまい、差し引き<code>sizeof(int) * 25536</code>バイトのメモリーが未使用のまま確保され続けてしまう。</p>
<p>メモリー要件の厳しい環境ではこのようなメモリーの浪費を避けたい。しかし、実行時にユーザーから任意の個数の入力を受けるプログラムを書く場合には、<code>push_back</code>を使いたい。</p>
<p>こういうとき、<code>shrink_to_fit</code>は<code>vector</code>が予約するメモリーを切り詰めて実サイズに近くする、かもしれない。「かもしれない」というのは、C++の標準規格は<code>shrink_to_fit</code>が必ずメモリーの予約サイズを切り詰めるよう規定してはいないからだ。</p>
<p>自作の<code>vector</code>では必ず切り詰める実装にしてみよう。</p>
<p>まず予約するメモリーを切り詰めるとはどういうことか。現在予約しているメモリーで保持できる最大の要素数は<code>capacity()</code>で得られる。実際に保持している要素数を返すのは<code>size()</code>だ。すると<code>size() == capacity()</code>になるようにすればいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector&lt;<span class="dt">int</span>&gt; v ;
<span class="co">// ...</span>
v.shrink_to_fit() ;
v.size() == v.capacity() ; <span class="co">// trueにする</span></code></pre></div>
<p><code>shrink_to_fit()</code>を呼んだとき、すでに<code>size() == capacity()</code>が<code>true</code>である場合は、何もしなくてもよい。</p>
<p>それ以外の場合は、現在の有効な要素数分の新しいストレージを確保し、現在の値を新しいストレージにコピーし、古いメモリーは破棄する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> shrink_to_fit()
{
    <span class="co">// 何もする必要がない</span>
    <span class="kw">if</span> ( size() == capacity() )
        <span class="kw">return</span> ;

    <span class="co">// 新しいストレージを確保</span>
    <span class="kw">auto</span> ptr = allocate( size() ) ;
    <span class="co">// コピー</span>
    <span class="kw">auto</span> current_size = size() ;
    <span class="kw">for</span> (   <span class="kw">auto</span> raw_ptr = ptr, iter = begin(), iter_end = end() ;
            iter != iter_end ; ++iter, ++raw_ptr )
    {
        construct( raw_ptr, *iter ) ;
    }
    <span class="co">// 破棄</span>
    clear() ;
    deallocate() ;
    <span class="co">// 新しいストレージを使う</span>
    first = ptr ;
    last = ptr + current_size ;
    reserved_last = last ;
}</code></pre></div>
<p>この実装は<code>reserve</code>と似ている。</p>
<h1 id="vectorのその他のコンストラクター">vectorのその他のコンストラクター</h1>
<h2 id="イテレーターのペア">イテレーターのペア</h2>
<p><code>std::vector</code>はイテレーターのペアを取り、その参照する値で要素を初期化できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array&lt;<span class="dt">int</span>, <span class="dv">5</span>&gt; a {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; v( std::begin(a), std::end(a) ) ;
    <span class="co">// vは{1,2,3,4,5}</span>
}</code></pre></div>
<p>これはすでに実装したメンバー関数を使えば簡単に実装できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> InputIterator &gt;
vector( InputIterator first, InputIterator last, <span class="dt">const</span> Allocator &amp; = Allocator() )
{
    reserve( std::distance( first, last ) ;
    <span class="kw">for</span> ( <span class="kw">auto</span> i = first ; i != last ; ++i )
    {
        push_back( *i ) ;
    }
}</code></pre></div>
<h2 id="初期化リスト">初期化リスト</h2>
<p><code>std::vector</code>は配列のように初期化できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
}</code></pre></div>
<p>このような初期化を<em>リスト初期化</em>と呼ぶ。</p>
<p>リスト初期化に対応するためには、<code>std::initializer_list&lt;T&gt;</code>を引数に取るコンストラクターを追加する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, Allocator = std::allocator&lt;T&gt; &gt;
{
<span class="co">// コンストラクター</span>
vector( std::initializer_list&lt;value_type&gt; init, <span class="dt">const</span> Allocator &amp; = Allocator() ) ; 
    <span class="co">// 省略...</span>
} ;</code></pre></div>
<p><code>std::initializer_list&lt;T&gt;</code>は<code>T</code>型の要素を格納する標準ライブラリで、<code>{a,b,c,...}</code>のようなリスト初期化で構築することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::initializer_list&lt;<span class="dt">int</span>&gt; init = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;</code></pre></div>
<p><code>std::initializer_list</code>は<code>begin/end</code>によるイテレーターを提供しているので、すでに実装したコンストラクターにデリゲートすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector( std::initializer_list&lt;value_type&gt; init, <span class="dt">const</span> Allocator &amp; alloc = Allocator() ) ; 
    : vector( std::begin(init), std::end(init), alloc )
{ }</code></pre></div>
<h1 id="コピー">コピー</h1>
<p>クラスにコピーを正しく実装するためには、まずコピーが何であるかを理解しなければならない。</p>
<h2 id="普通のコピー">普通のコピー</h2>
<p>C++を書くユーザーは、クラス型のオブジェクトを使うとき、クラスが普通の型(regular type)のように振る舞うことを期待している。この普通にはさまざまな意味がある。</p>
<p><code>int</code>型の変数をコピーするとき、コピー先の変数はコピー元の変数と等しくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> source = <span class="dv">42</span> ;
<span class="dt">int</span> destination = source ;</code></pre></div>
<p>この例では変数<code>destination</code>は変数<code>source</code>と等しくなる。<code>source == destination</code>は<code>true</code>となり、<code>destination</code>の値は<code>42</code>になる。</p>
<p>コピーの結果、コピー先の変数は値が書き換えられる。コピー元の変数は変わらない。上の例で、変数<code>source</code>が勝手に別の値になることは「普通」はない。</p>
<p>我々が普通にコピーと認識しているものは、C++の文法的にはコピー構築とコピー代入に分けることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">T source ;
<span class="co">// コピー構築</span>
T a = source ;
T b(source) ;
T c{source}

T d ;
<span class="co">// コピー代入</span>
d = source ;</code></pre></div>
<p>ユーザーは普通、コピー構築とコピー代入のコピーが両方とも同じ挙動をすると期待している。コピー構築とコピー代入のどちらか片方が使えるならば、もう片方も使えるべきで、そのコピーの挙動は同じであるべきだ。</p>
<p>コピー代入にはコピーの普通に加えて、さらにユーザーが代入に期待する普通がある。</p>
<p>代入式を評価した結果は、代入されるオブジェクトへの<code>lvalue</code>リファレンスになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x, y, z ;
    <span class="co">// x, y, zに0を代入</span>
    x = y = z = <span class="dv">0</span> ;
}</code></pre></div>
<p>これはまず<code>z = 0</code>が評価される。変数<code>z</code>の値は<code>0</code>になり、式を評価した結果の値は<code>z</code>への<code>lvalue</code>リファレンスだ。なので、<code>y = z = 0</code>というのは、<code>y = (z=0)</code>となる。<code>z=0</code>については<code>z</code>であるので、<code>y = z</code>となる。ここでの<code>z</code>は<code>0</code>を代入されたあとの<code>z</code>なので、値は<code>0</code>だ。その結果変数<code>y</code>の値は<code>0</code>になる。変数<code>x</code>の場合も同様だ。</p>
<p>以下のような例も見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x ;
    (x = <span class="dv">0</span>) = <span class="dv">1</span> ;
}</code></pre></div>
<p>これは<code>(x = 0)</code>の結果に<code>1</code>を代入している。<code>x=0</code>の結果は<code>x</code>なので、<code>x</code>には<code>0</code>が代入されたあとに<code>1</code>が代入される。結果として<code>x</code>の値は<code>1</code>になる。</p>
<h2 id="コピーコンストラクター">コピーコンストラクター</h2>
<p>コピー構築の場合、コピーコンストラクターが呼ばれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Value
{
    <span class="co">// コピーコンストラクター</span>
    X( <span class="dt">const</span> X &amp; source )
    { }
} ;

<span class="dt">int</span> main()
{
    Value source ;
    <span class="co">// コピーコンストラクターを呼ぶ</span>
    Value b = source ;
    Value c(source) ;
    Value d{source} ;
}</code></pre></div>
<p>コピーコンストラクターは<code>クラス型へのlvalueリファレンス型</code>を引数に取る<code>コンストラクター</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">const</span> X &amp; source ) { }
} ;</code></pre></div>
<p>引数は通常は<code>constなlvalueリファレンス型</code>だが、<code>非constなlvalueリファレンス型</code>を引数に取るコンストラクターも<code>コピーコンストラクター</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( X &amp; source ) { }
} ;</code></pre></div>
<p>ただし、非<code>const</code>な<code>lvalue</code>リファレンス型を引数に取るコピーコンストラクターは通常は使わない。なぜならば、コピーの結果、コピー元が書き換えられるような挙動は不自然だからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> funny_number
{
    <span class="dt">int</span> n ;
    funny_number( <span class="dt">int</span> n = <span class="dv">0</span> )
        : n(n) { }
    funny_number( funny_number &amp; source )
        : n( source.n )
    {
        source.n = <span class="dv">0</span> ;
    }
} ;

<span class="dt">int</span> main()
{
    funny_number a = <span class="dv">1</span> ;
    <span class="co">// コピー</span>
    funny_number b = a ;
    <span class="co">// a == 0</span>
    <span class="co">// b == 1</span>
}</code></pre></div>
<p>このおかしな<code>funny_number</code>のコピーコンストラクターはコピー元を0に書き換えてしまう。このコードは完全に合法なC++のコードだが、このようにコピーコンストラクターを実装するのはおすすめできない。なぜならば、ユーザーはコピーについて上で示したような意味を普通だと想定しているため、普通から外れるような型はユーザーのあてが外れてしまうからだ。</p>
<h2 id="コピー代入演算子">コピー代入演算子</h2>
<p>コピー代入演算子は<code>クラス型へのlvalueリファレンス型</code>を引数に取る<code>operator =</code>のオーバーロードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> X &amp; source )
    {
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
} ;</code></pre></div>
<p>コピーコンストラクターと同じく、コピー代入演算子の引数は非<code>const</code>な<code>lvalue</code>リファレンスでもよい。ただし、ユーザーの期待する普通にはそぐわない結果になる。</p>
<p>コピー代入演算子の戻り値の型はクラス型への非<code>const</code>な<code>lvalue</code>リファレンスでなくてもよい。ただし、その場合もユーザーの期待にそぐわないことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">void</span> <span class="kw">operator</span> = ( <span class="dt">const</span> X &amp; source ) { }
} ;

<span class="dt">int</span> main()
{
    X a, b, c ;
    <span class="co">// OK</span>
    a = b ;
    <span class="co">// エラー</span>
    a = b = c ;
}</code></pre></div>
<p><code>a = b = c</code>は、クラス<code>X</code>のコピー代入演算子の戻り値の型が<code>void</code>なので動かない。ユーザーは普通、これが動くことを期待している。ユーザーの普通の期待に答えるためにはクラスへの非<code>const</code>な<code>lvalue</code>リファレンスを返さなければならない。</p>
<h2 id="コピーの挙動">コピーの挙動</h2>
<p>クラスのコピーは何をすればいいのだろうか。クラスにコピーコンストラクターとコピー代入演算子を書かない場合、デフォルトのコピーコンストラクター、コピー代入演算子が生成される。</p>
<p>デフォルトのコピーは、クラスのデータメンバーをそれぞれコピーする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Point
{
    <span class="dt">int</span> x ;
    <span class="dt">int</span> y ;
    <span class="dt">int</span> z ;
} ;

<span class="dt">int</span> main()
{
    Point a{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    Point b = a ;
    Point c ;
    c = a ;
}</code></pre></div>
<p>上記のコードは、以下のように書いたのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Point b{ a.x, a.y, a.z } ;
Point c ;
c.x = a.x ;
c.y = a.y ;
c.z = a.z ;</code></pre></div>
<p>つまり、以下のようなコピーコンストラクターとコピー代入演算子を書いたのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Point
{
    <span class="dt">int</span> x ;
    <span class="dt">int</span> y ;
    <span class="dt">int</span> z ;

    Point( <span class="dt">const</span> Point &amp; r )
        : x(r.x), y(r.y), z(r.z)
    { }

    Point &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> Point &amp; r )
    {
        x = r.x ;
        y = r.y ;
        z = r.z ;
    }
} ;</code></pre></div>
<p>では<code>std::vector</code>のコピーはどうなるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; w = v ;
    <span class="co">// wは{1,2,3,4,5}</span>
}</code></pre></div>
<p><code>std::vector</code>をコピーした場合、その値がコピーされる。</p>
<p>自作の<code>vector</code>のコピーはどのように実装すればいいだろうか。デフォルトのコピーに任せてもいいのだろうか。デフォルトのコピーを使う場合、コピーコンストラクターは以下のように書いたものと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> Allocator = std::allocator&lt;T&gt; &gt;
<span class="kw">class</span> vector
{
    <span class="co">// ... その他のメンバー</span>
<span class="kw">private</span> :
    pointer first = <span class="kw">nullptr</span> ;
    pointer last = <span class="kw">nullptr</span> ;
    pointer reserved_last = <span class="kw">nullptr</span> ;
    allocator_type alloc ;

<span class="kw">public</span> :
    <span class="co">// コピーコンストラクター</span>
    vector( <span class="dt">const</span> vector &amp; r )
        : first( r.first ), last( r.last ),
        , reserved_last( r.reserved_last ),
        , alloc( r.alloc )
    { }
} ;</code></pre></div>
<p>これは問題だ。以下のコードを考える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    vector&lt;<span class="dt">int</span>&gt; v{<span class="dv">1</span>} ;
    vector&lt;<span class="dt">int</span>&gt; w = v ;
    <span class="co">// wのデストラクターが呼ばれる</span>
    <span class="co">// vのデストラクターが呼ばれる</span>
}</code></pre></div>
<p><code>w = v</code>で、<code>v</code>のデータメンバーの値がそれぞれ<code>w</code>のデータメンバーにコピーされる。</p>
<p><code>main</code>関数を抜けるので、構築の逆順に変数が破棄される。この場合<code>w</code>が先に破棄される。破棄にあたっては<code>w</code>のデストラクターが呼ばれる。</p>
<p>この場合、<code>w</code>のデストラクターは、</p>
<ol style="list-style-type: decimal">
<li>ポインター<code>first</code>が指すオブジェクトのデストラクターを呼び出す</li>
<li>ポインター<code>first</code>の指す生のストレージを解放</li>
</ol>
<p>する。</p>
<p>次に<code>v</code>が破棄される。<code>v</code>のデストラクターは<code>w</code>のデストラクターとまったく同じことをする。ただし、ポインター<code>first</code>の指すオブジェクトはすでにデストラクターが呼び出されているし、ポインター<code>first</code>の指す生のストレージも解放されている。</p>
<p>すでにデストラクターを呼び出したオブジェクトに対してもう一度デストラクターを呼び出した場合の挙動は未定義だ。すでに解放したストレージを指すポインターに対してもう一度ストレージの解放した場合の挙動は未定義だ。したがって、このプログラムの挙動は未定義となる。</p>
<p>コピー代入も同じ問題を抱えている。しかも別の問題まである。例えば以下の例を見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    vector&lt;<span class="dt">int</span>&gt; w = {<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>} ;
    w = v ;
}</code></pre></div>
<p>変数<code>w</code>はまず要素を保持するためのメモリーを動的確保する。その後、<code>w</code>に<code>v</code>が代入されるわけだが、このとき<code>w</code>が動的確保したメモリーを指すポインターの値が上書きされてしまう。<code>w</code>が破棄されるとき、<code>w</code>がもともと持っていた要素は破棄されなくなり、ストレージも解放されなくなる。</p>
<h2 id="所有するクラス">所有するクラス</h2>
<p>この問題は「所有」という考え方を使うと解決できる。</p>
<p>問題を簡単にするために、以下のようなクラスを考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> own
{
<span class="kw">private</span> :
    T * ptr ;
<span class="kw">public</span> :
    own( )
        : ptr( <span class="kw">new</span> T )
    { }
    ~own()
    { <span class="kw">delete</span> ptr ; }

    T * get() <span class="dt">const</span> { <span class="kw">return</span> ptr ; }

} ;</code></pre></div>
<p>このクラスはコンストラクターでテンプレートパラメーター<code>T</code>型のオブジェクトを動的メモリー確保をし、デストラクターでメモリーの解放をする。</p>
<p>コピーコンストラクターとコピー代入演算子は定義していないので、デフォルトのコピーが使われる。</p>
<p>デフォルトのコピーを使うことを明示する方法もある。<code>= default</code>を使うのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> own
{
    <span class="co">// その他のメンバー</span>
<span class="kw">public</span> :
    own( <span class="dt">const</span> own &amp; ) = <span class="kw">default</span> ;
    own &amp; <span class="kw">operator</span> ==( <span class="dt">const</span> own &amp; ) = <span class="kw">default</span> ;
}</code></pre></div>
<p>コピーコンストラクター、コピー代入演算子となる宣言に<code>= default</code>を使うと、デフォルトのコピー実装を使うということを明示的に宣言したことになる。この文法はややわかりにくいが、こういうものだと思って覚えておこう。</p>
<p>このようなクラスを「デフォルトのコピー」でコピーしたとき、コピーされるのはポインターの値だ。ポインターが参照する先は同じだ。</p>
<p>この場合、クラスはポインターの参照するオブジェクトを所有していると考えることができる。ポインターの値をコピーするということは、所有権を共有するということだ。所有権を共有していることを考慮しないまま、クラスのオブジェクトが破棄されたときにポインターの参照先まで破棄してしまうと、所有したつもりになっているクラスのオブジェクトが出来上がってしまう。</p>
<p>普通の型のように振る舞うコピーを実装するには、コピーの際に所有権を共有しない実装をする。具体的には、コピーのときに新しく動的メモリー確保し、値をコピーするのだ。</p>
<p>コピーコンストラクターは以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">own( <span class="dt">const</span> own &amp; r )
    : ptr( <span class="kw">new</span> T( *r.ptr ) )
{ }</code></pre></div>
<p>今回の場合、コピー代入演算子で動的メモリー確保をする必要はない。なぜならば、コピー代入演算子が呼ばれたということは、いずれかのコンストラクターがすでに呼ばれていて、動的メモリー確保はされているからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">own &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> own &amp; r )
{
    *ptr = *r.ptr ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<p>このコードには少し問題がある。変数は自分自身に代入ができるのだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1GBもの巨大なサイズのクラス</span>
<span class="kw">struct</span> one_giga_byte { std::byte storage[<span class="dv">1&#39;000&#39;000&#39;000</span>] ; }

<span class="dt">int</span> main()
{
    own&lt;one_giga_byte&gt; x ;
    <span class="co">// 1GBのコピーが発生</span>
    x = x ;
}</code></pre></div>
<p>自分自身に代入というのは少し奇妙だが、これはC++では普通のことだ。クラス型はできるだけ普通に振る舞うべきだ。</p>
<p>普通のクラスは、自分自身への代入で特に何かをする必要はない。したがって、単に自分自身への代入が行われたことを判定したならば、コピーを行わないという処理でいい。</p>
<p>自分自身への代入を判定するには、コピー代入演算子の引数のリファレンスが指すオブジェクトのポインターが<code>this</code>ポインターと等しいかどうかを調べればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">own &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> own &amp; r )
{
    <span class="co">// 自分自身への代入でなければ</span>
    <span class="kw">if</span> ( <span class="kw">this</span> != &amp;r )
    {
        <span class="co">// コピー処理</span>
        *ptr = *r.ptr ;
    }
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<h2 id="ownuからowntへの変換"><code>own&lt;U&gt;</code>から<code>own&lt;T&gt;</code>への変換</h2>
<p>C++では、<code>int</code>型から<code>long</code>型に、変換することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">123</span> ;
    <span class="co">// 変換してコピー</span>
    <span class="dt">long</span> b = a ;
}</code></pre></div>
<p>これは厳密には変換であってコピーではないのだが、コピーによく似ている。</p>
<p>これと同じことを、<code>own&lt;T&gt;</code>でやるにはどうすればいいのだろうか。つまり<code>own&lt;int&gt;</code>から<code>own&lt;long&gt;</code>への変換だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    own&lt;<span class="dt">int</span>&gt; a ;
    *a.get() = <span class="dv">123</span> ;
    own&lt;<span class="dt">long</span>&gt; b = a ;
    *b.get() ; <span class="co">// long型の123</span>
}</code></pre></div>
<p>単に<code>own&lt;int&gt;</code>からの変換だけであれば、<code>own&lt;int&gt;</code>型から変換するコンストラクターを書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> own
{
<span class="kw">private</span> :
    T * ptr ;
<span class="kw">public</span> :
    <span class="co">// 変換コンストラクター</span>
    own( <span class="dt">const</span> own&lt;<span class="dt">int</span>&gt; &amp; r )
        : ptr( <span class="kw">new</span> T(*r.get()) )
    { }
    <span class="co">// ...</span>
}</code></pre></div>
<p>このような自分自身以外の型の引数を1つだけ取るコンストラクターのことを、<code>変換コンストラクター</code>という。</p>
<p>しかしこれでは<code>own&lt;int&gt;</code>からの変換にしか対応できない。しかも<code>int</code>型から変換できない型を使うとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int型から変換できない型</span>
<span class="kw">struct</span> I_hate_int
{
    <span class="co">// デフォルトのデフォルトコンストラクター</span>
    I_hate_int() = <span class="kw">default</span> ;
    <span class="co">// intからの変換コンストラクター</span>
    I_hate_int(<span class="dt">int</span>) = <span class="kw">delete</span> ;
}

<span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    own&lt;I_hate_int&gt; a ;
}</code></pre></div>
<p>関数の宣言に<code>= delete</code>を書くと、その関数を消すことができる。「消す」というのは、その関数を使った時点でプログラムがコンパイルエラーになるという意味だ。</p>
<p>この問題を解決するにはテンプレートを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> own
{
<span class="kw">private</span> :
    T * ptr ;
<span class="kw">public</span> :
    <span class="kw">template</span> &lt; <span class="kw">typename</span> U &gt;
    own( <span class="dt">const</span> own&lt;U&gt; &amp; r )
        : ptr( <span class="kw">new</span> T(*r.get()) )
    { }
    <span class="co">// ...</span>
}</code></pre></div>
<p>こうすると任意の型<code>T, U</code>について、<code>U</code>型から<code>T</code>型に変換構築できるのであれば、<code>own&lt;U&gt;</code>から<code>own&lt;T&gt;</code>への変換構築ができる。</p>
<p>しかし、上のクラス<code>I_hate_int</code>型は任意の型から変換できないので、この変換コンストラクターテンプレートの存在は問題にならならないのだろうか。心配御無用。テンプレートは具体的なテンプレート実引数が与えられて初めてコードが生成される。実際に使わない限りは問題にならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 問題なし</span>
    own&lt;I_hate_int&gt; a ;
    <span class="co">// 問題なし</span>
    own&lt;<span class="dt">int</span>&gt; b ;

    <span class="co">// エラー</span>
    <span class="co">// 実際に使われた</span>
    a = b ;
}</code></pre></div>
<h2 id="もう少し複雑な所有するクラス">もう少し複雑な所有するクラス</h2>
<p>同じく所有するクラスだが、もう少し複雑な例を考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> dynamic_array
{
<span class="kw">private</span> :
    T * first ;
    T * last ;
<span class="kw">public</span> :
    dynamic_array( std::size_t size = <span class="dv">0</span> )
        : first( <span class="kw">new</span> T[size]), last( first + size )
    { }
    ~dynamic_array()
    { <span class="kw">delete</span>[] first ; }

    T &amp; <span class="kw">operator</span> [] ( std::size_t i )  <span class="dt">const</span> <span class="kw">noexcept</span>
    { <span class="kw">return</span> first[i] ; }
    std::size_t size() <span class="dt">const</span> <span class="kw">noexcept</span>
    { <span class="kw">return</span> last - first ; }
    T * begin() <span class="dt">const</span> <span class="kw">noexcept</span>
    { <span class="kw">return</span> first ; }
    T * end() <span class="dt">const</span> <span class="kw">noexcept</span>
    { <span class="kw">return</span> last ; }
} ;

<span class="dt">int</span> main()
{
    dynamic_array&lt;<span class="dt">int</span>&gt; a(<span class="dv">10</span>) ;
    a[<span class="dv">0</span>] = <span class="dv">1</span> ;
    a[<span class="dv">1</span>] = <span class="dv">2</span> ;
}</code></pre></div>
<p>この<code>dynamic_array&lt;T&gt;</code>は<code>T</code>型の動的な配列クラスだ。配列のサイズは実行時に指定できる。</p>
<p>このようなクラスのコピーはどうなるだろうか。</p>
<p>コピーコンストラクターは簡単だ。コピー元と同じサイズの配列を動的確保し、要素をコピーすればいいだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dynamic_array( <span class="dt">const</span> dynamic_array &amp; r )
    : first( <span class="kw">new</span> T[r.size()]), last( first + r.size() ) 
{
    std::copy( r.begin(), r.end(), begin() ) ;
}</code></pre></div>
<p>コピー代入演算子でも、場合によっては動的メモリー確保が必要になる。現在所有しているメモリーとは異なるサイズのオブジェクトからコピーする場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    dynamic_array&lt;<span class="dt">int</span>&gt; a(<span class="dv">5</span>) ;
    dynamic_array&lt;<span class="dt">int</span>&gt; b(<span class="dv">10</span>) ;
    <span class="co">// aの所有するメモリーはサイズ不足</span>
    a = b ;
}</code></pre></div>
<p>コピー元よりコピー先の方がメモリーが多い場合、つまり<code>b = a</code>の場合は動的メモリー確保をしないという実装もできるが、その場合実際に確保したメモリーサイズと、クラスが認識しているメモリーサイズが異なることになる。今回はサイズが違う場合は必ず動的メモリー確保をすることにしよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dynamic_array &amp; <span class="kw">operator</span> == ( <span class="dt">const</span> dynamic_array &amp; r )
{
    <span class="co">// 自分自身への代入ではない場合</span>
    <span class="co">// かつ</span>
    <span class="co">// サイズが違う場合</span>
    <span class="kw">if</span> ( <span class="kw">this</span> != &amp;r &amp;&amp; size() != r.size() )
    {
        <span class="co">// コピー処理</span>
    }
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<p><code>new</code>したメモリーは<code>delete</code>しなければならない。そこで、コピー代入演算子はまず自分の所有するメモリーを<code>delete</code>してから<code>new</code>し、値をコピーすることになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dynamic_array &amp; <span class="kw">operator</span> == ( <span class="dt">const</span> dynamic_array &amp; r )
{
    <span class="kw">if</span> ( <span class="kw">this</span> != &amp;r &amp;&amp; size() != r.size() )
    {
        <span class="co">// コピー先が所有しているメモリーの解放</span>
        <span class="kw">delete</span> first ;
        <span class="co">// コピー元と同じサイズの動的メモリー確保</span>
        first = <span class="kw">new</span> T[r.size()] ;
        last = first + r.size() ;
        <span class="co">// コピー元の値をコピー</span>
        std::copy( r.begin(), r.end(), begin() ) ;
    }
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<h2 id="vectorのコピー">vectorのコピー</h2>
<p>自作の<code>vector</code>のコピーを実装していこう。</p>
<h3 id="コピーコンストラクター-1">コピーコンストラクター</h3>
<p><code>std::vector</code>では、アロケーターのコピーだけがちょっと特殊になっている。コンテナーのコピーにあたってアロケーターをコピーすべきかどうかは、アロケーターの実装が選べるようになっている。このために、<code>std::allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction(alloc)</code>を呼び出し、その戻り値でアロケーターを初期化する。<code>std::allocator_traits&lt;allocator_type&gt;</code>という型については、すでに<code>traits</code>というエイリアスを宣言しているので、以下のようにする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector( <span class="dt">const</span> vector &amp; r )
    <span class="co">// アロケーターのコピー</span>
    : alloc( traits::select_on_container_copy_construction(r.alloc) )
{
    <span class="co">// コピー処理</span>
}</code></pre></div>
<p>残りのコピー処理を実装していこう。</p>
<ol style="list-style-type: decimal">
<li>コピー元の要素数を保持できるだけのストレージを確保</li>
<li>コピー元の要素をコピー構築</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector( <span class="dt">const</span> vector &amp; r )
    : alloc( traits::select_on_container_copy_construction( r.alloc ) )
{
    <span class="co">// コピー元の要素数を保持できるだけのストレージを確保</span>
    reserve( r.size() ) ;
    <span class="co">// コピー元の要素をコピー構築</span>
    <span class="co">// destはコピー先</span>
    <span class="co">// [src, last)はコピー元</span>
    <span class="kw">for</span> (   <span class="kw">auto</span> dest = first, src = r.begin(), last = r.end() ;
            src != last ; ++dest, ++src )
    {
        construct( dest, *src ) ;
    }
    last = first + r.size() ;
}</code></pre></div>
<h3 id="コピー代入演算子-1">コピー代入演算子</h3>
<p>コピー代入演算子ではアロケーターのコピーをする必要はない。ただし自分自身への代入への対応が必要だ。そして、コピー代入のコピー先とコピー元の要素数が同じであるとは限らない。</p>
<p>コピー先とコピー元の要素数が同じである場合、単に要素にコピー代入をすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; w(<span class="dv">3</span>) ;
    w = v ;
}</code></pre></div>
<p>これは単に以下のようなコードを実行したものと同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">w[<span class="dv">0</span>] = v[<span class="dv">0</span>] ;
w[<span class="dv">1</span>] = v[<span class="dv">1</span>] ;
w[<span class="dv">2</span>] = v[<span class="dv">2</span>] ;</code></pre></div>
<p>要素数が違う場合、2通りの場合がある。</p>
<p>コピー先がコピー元の要素数以上の予約数を持っている場合、有効な要素についてはコピー代入され、それ以降の要素はコピー構築される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 要素数5</span>
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// 要素数3</span>
    std::vector&lt;<span class="dt">int</span>&gt; w(<span class="dv">3</span>) ;
    <span class="co">// 予約数5</span>
    w.reserve(<span class="dv">5</span>) ;
    w = v ;
}</code></pre></div>
<p>この場合、<code>w[0], w[1], w[2]</code>についてはそれぞれ<code>v[0], v[1], v[2]</code>からコピー代入される。<code>w[3],w[4]</code>はそれぞれ<code>v[3], v[4]</code>からコピー構築される。</p>
<p>コピー先がコピー元の要素数以上の予約数を持っていない場合、コピー元の要素数以上のストレージが予約される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// 予約数2だとする。</span>
    std::vector&lt;<span class="dt">int</span>&gt; w(<span class="dv">2</span>) ;
    <span class="co">// 古いストレージが破棄され</span>
    <span class="co">// 新しいストレージが確保され</span>
    <span class="co">// コピー構築される</span>
    w = v ;
}</code></pre></div>
<p>このとき、コピー先の既存の要素をわざわざ新しいストレージにコピー構築する必要はない。なぜならば、既存の要素の値はもういらないからだ。</p>
<p>まとめよう。</p>
<ol style="list-style-type: decimal">
<li>自分自身への代入であれば何もしない</li>
<li>要素数が同じならば要素ごとにコピー代入</li>
<li>それ以外の場合で、予約数が十分ならば有効な要素にはコピー代入、残りはコピー構築</li>
<li>それ以外の場合で、予約数が不十分ならば、現在の要素はすべて破棄して新たなストレージを確保してコピー構築</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">vector &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> vector &amp; r )
{
    <span class="co">// 1. 自分自身への代入なら何もしない</span>
    <span class="kw">if</span> ( <span class="kw">this</span> == &amp;r )
        <span class="kw">return</span> *<span class="kw">this</span> ;

    <span class="co">// 2. 要素数が同じならば</span>
    <span class="kw">if</span> ( size() == r.size() )
    {   <span class="co">// 要素ごとにコピー代入</span>
        std::copy( r.begin(), r.end(), begin() ) ;
    }
    <span class="co">// 3. それ以外の場合で</span>
    <span class="kw">else</span> 
        <span class="co">// 予約数が十分ならば、</span>
        <span class="kw">if</span> ( capacity() &gt;= r.size() )
        {
            <span class="co">// 有効な要素はコピー</span>
            std::copy( r.begin(), r.begin() + r.size(), begin() ) ;
            <span class="co">// 残りはコピー構築</span>
            <span class="kw">for</span> (   <span class="kw">auto</span> src_iter = r.begin() + r.size(), src_end = r.end() ;
                    src_iter != src_end ; ++src_iter, ++last )
            {
                construct( last, *src_iter ) ;
            }
        }
        <span class="co">// 4. 予約数が不十分ならば</span>
        <span class="kw">else</span>
        {
            <span class="co">// 要素をすべて破棄</span>
            destroy_all() ;
            <span class="co">// 予約</span>
            reserve( r.size() ) ;
            <span class="co">// コピー構築</span>
            <span class="kw">for</span> ( <span class="kw">auto</span> src_iter = r.begin(), src_end = r.end(), dest_iter = begin() ;
                src_iter != src_end ; ++src_iter, ++dest_iter, ++last )
            {
                construct( dest_iter, *src_iter ) ;
            }
        }
    <span class="kw">return</span> *<span class="kw">this</span> ;  
}</code></pre></div>
<h1 id="ムーブ">ムーブ</h1>
<h2 id="ムーブの使い方">ムーブの使い方</h2>
<p>ムーブ(move)とはコピー(copy)と対になる概念だ。ムーブはちょっと特殊なコピーと考えることもできる。コピーが値をコピー（複製）するのに対し、ムーブは値をムーブ（移動）させる。</p>
<p>コピーの仕方を振り返ってみよう。コピーにはコピー構築とコピー代入がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">T source ;
<span class="co">// コピー構築</span>
T a = source ;
T b( source ) ;
T c{ source ) ;

T e ;
<span class="co">// コピー代入</span>
e = source ;</code></pre></div>
<p>コピーにはコピー先とコピー元がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
std::vector&lt;<span class="dt">int</span>&gt; destination = source ;
<span class="co">// destinationは{1,2,3}</span></code></pre></div>
<p>一般にコピー後のコピー先の値はコピー元の値と等しくなることが期待されている。</p>
<p>ムーブはコピーと似ている。コピーをするときに、ムーブ元の変数を<code>source</code>を<code>std::move(source)</code>のように標準ライブラリ<code>std::move</code>に渡してその戻り値をコピー元の値とすることでムーブになる。ムーブにもコピーと同様にムーブ構築とムーブ代入がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">T source ;
<span class="co">// ムーブ構築</span>
T a = std::move(source) ;
T b( std::move(source) ) ;
T c{ std::move(source) ) ;

T e ;
<span class="co">// ムーブ代入</span>
e = std::move(source) ;</code></pre></div>
<p>ムーブにもムーブ先とムーブ元がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
<span class="co">// destinationはムーブ先</span>
<span class="co">// sourceはムーブ元</span>
std::vector&lt;<span class="dt">int</span>&gt; destination = std::move(source) ;
<span class="co">// destinationの値は{1,2,3}</span>
<span class="co">// sourceの値はわからない</span></code></pre></div>
<p>コピーと同じく、ムーブ後のムーブ先の値は、ムーブ前のムーブ元の値と等しくなる。</p>
<p>ムーブ後のムーブ元の値はわからない。なぜわからないかというと、値を移動しているからだ。</p>
<p>ムーブのコストはコピーとまったく同じか、コピーよりも低くなる。</p>
<p>ムーブはムーブ元の値をムーブ後に使わない場合に、コピーの代わりに使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;

    std::vector&lt;<span class="dt">int</span>&gt; w = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    <span class="co">// ムーブ</span>
    v = std::move(w) ;
    <span class="co">// このあとwは使えない</span>

    std::for_each( std::begin(v), std::end(v), 
        []( <span class="kw">auto</span> x ){
            std::cout &lt;&lt; x ;
        } ) ;
}</code></pre></div>
<p>実際には、上記のコードはムーブ後に変数<code>w</code>を使っている。<code>main</code>関数のスコープを抜けるときに<code>w</code>が破棄されるが、そのときにデストラクターが実行される。</p>
<p>C++の標準ライブラリはムーブ後の状態について、その値は「妥当だが未規定の状態」になる。</p>
<p>なのでこの場合でもデストラクターを正常に呼び出すことはできる。このとき、<code>w.size()</code>が返す値はわからない。ただし、<code>w.resize(n)</code>を呼び出すと<code>n</code>個の要素を持つようになる。この結果、再び使うこともできるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    std::vector&lt;<span class="dt">int</span>&gt; w = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    v = std::move(w) ;
    <span class="co">// 要素数5</span>
    w.resize(<span class="dv">5</span>) ;
    <span class="co">// 妥当に使える</span>
    w[<span class="dv">0</span>] = <span class="dv">1</span> ;
}</code></pre></div>
<h2 id="ムーブの中身">ムーブの中身</h2>
<p>ムーブはいったい何をしているのか。ムーブの実装方法を理解するためには、<code>rvalueセマンティクス</code>と<code>値カテゴリー</code>とテンプレートの<code>フォワードリファレンス</code>という難しいC++の機能を理解しなければならない。この機能は次の章から解説するが、その機能を学ぶ動機づけにムーブが何をしているのかを具体的に学ぼう。</p>
<p><code>int</code>や<code>double</code>といった単なるバイト列で表現された値だけで表現できる基本型のオブジェクトの場合、ムーブというのはコピーと何ら変わらない。単に値を表現するバイト列をコピーするだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">0</span> ;
<span class="co">// コピー</span>
<span class="dt">int</span> b = a ;
<span class="co">// ムーブ</span>
<span class="co">// 中身は単なるコピー</span>
<span class="dt">int</span> c = std::move(a) ;</code></pre></div>
<p>そのため、<code>int</code>や<code>double</code>のムーブでは、ムーブ後もムーブ元のオブジェクトをそのまま使うことができるし、値も変わらない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="dv">123</span> 
<span class="dt">int</span> b = std::move(a) ;
<span class="co">// 123</span>
std::cout &lt;&lt; a ;
a = <span class="dv">456</span> ;</code></pre></div>
<p>生のポインターのムーブもコピーと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> object { } ;
<span class="dt">int</span> * source = object ;
<span class="co">// 中身は単なるコピー</span>
<span class="dt">int</span> * destination = std::move(source) ;</code></pre></div>
<p>クラスはどうか。クラスはデフォルトのコピーコンストラクターとコピー代入演算子を生成するように、デフォルトのムーブコンストラクターとムーブ代入演算子を生成する。これはコピーと同じく、メンバーごとにムーブを行う。</p>
<p>以下のように書くと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> x ;
    <span class="dt">int</span> y ;
    <span class="dt">int</span> z ;
} ;

<span class="dt">int</span> main()
{
    X a{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    X b ;
    b = std::move(a) ;
}</code></pre></div>
<p>以下のように書いたものとほぼ同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    X a{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    X b ;
    b.x = std::move(a.x) ;
    b.y = std::move(a.y) ;
    b.z = std::move(a.z) ;
}</code></pre></div>
<p>この場合のムーブは単なるコピーなので、実際には以下のように書くのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    X a{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    X b ;
    b = a ;
}</code></pre></div>
<p>C++の基本型とクラスのデフォルトのムーブの実装は、単なるコピーと同じだ。コピーと同じなのでムーブ後の値もそのまま使うことができる。</p>
<p>ではなぜコピーとムーブが区別され、ムーブ後のオブジェクトは使えないのか。C++ではコピーとムーブが区別されているので、自作のクラスはコピーとムーブで別の実装をすることができる。</p>
<p>ムーブ後のオブジェクトは使えない状態になるということは、ムーブ後のオブジェクトの値はどうなってもいいということだ。</p>
<p><code>std::vector</code>のようなクラスは動的メモリー確保をしてポインターでストレージを参照している。自作の<code>vector</code>にコピーを実装するときは、コピー先でも動的メモリー確保をして要素を1つずつコピーしなければならないことを学んだ。</p>
<p>とても簡単な、<code>T</code>型の配列を確保する<code>dynamic_array&lt;T&gt;</code>を考えてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> dynamic_array
{
<span class="kw">private</span> :
    T * first ;
    T * last ;
<span class="kw">public</span> :
    dynamic_array( std::size_t size = <span class="dv">0</span> )
        : first( <span class="kw">new</span> T[size]), last( first + size )
    { }
    ~dynamic_array()
    { <span class="kw">delete</span>[] first ; }

    <span class="co">// コピーコンストラクター</span>
    dynamic_array( <span class="dt">const</span> dynamic_array &amp; r ) ;
} ;</code></pre></div>
<p>このクラスのコピーコンストラクターの定義は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
dynamic_array&lt;T&gt;::dynamic_array( <span class="dt">const</span> dynamic_array &amp; r )
    : first( <span class="kw">new</span> T[r.size()] ), last( first + r.size() ) 
{
    std::copy( r.begin(), r.end(), begin() ) ;
}</code></pre></div>
<p>これはコストがかかる。以下のようにすればコストがかからないがなぜできないのだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"> &lt; <span class="kw">typename</span> T &gt;
dynamic_array&lt;T&gt;::dynamic_array( <span class="dt">const</span> dynamic_array &amp; r )
    : first( r.first ), last( r.last ) 
{
    <span class="co">// 何もしない</span>
}</code></pre></div>
<p>コピーの章でも学んだように、この実装ではコピー先とコピー元が同じポインターを所有してしまうために、デストラクターが実行されるときに同じポインターが2回<code>delete</code>されてしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    dynamic_array&lt;<span class="dt">int</span>&gt; source(<span class="dv">10</span>) ;
    dynamic_array&lt;<span class="dt">int</span>&gt; destination = source ;
    <span class="co">// destinationに対してデストラクターが実行される</span>
    <span class="co">// sourceに対してデストラクターが実行される</span>
}</code></pre></div>
<p>ならば、コピー元からポインターの所有権を奪ってしまえばいいのではないだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"> &lt; <span class="kw">typename</span> T &gt;
dynamic_array&lt;T&gt;::dynamic_array( dynamic_array &amp; r )
    : first( r.first ), last( r.last ) 
{
    <span class="co">// コピー元を変更</span>
    r.first = <span class="kw">nullptr</span> ;
    r.last = <span class="kw">nullptr</span> ;
}</code></pre></div>
<p>引数が<code>const</code>ではないことに注目しよう。リファレンス型の引数を変更するには、<code>const</code>にはできない。</p>
<p>このコピーコンストラクターはコピー元を変更する。<code>delete式</code>は<code>nullptr</code>に対して適用した場合、何もしないことが保証されている。そのため、この場合にデストラクターでnullポインターのチェックは必要がない。</p>
<p>このコピーコンストラクターはとてもコストが低いが、このようなコピーの実装はユーザーが期待していない。この実装ではコピー後にコピー元が使えなくなってしまうからだ。</p>
<p>例えば、以下のコードが動かないとしたらどうだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    std::vector&lt;<span class="dt">int</span>&gt; w = v ;

    <span class="co">// これがエラーだとしたら？</span>
    v[<span class="dv">0</span>] = <span class="dv">0</span> ; 
}</code></pre></div>
<p>C++ではコピーはコピー元を変更しないという慣習がある。このような慣習はすべてC++の標準規格で定められている。</p>
<p>このため、C++はコピーのほかにムーブを定めている。ムーブを使うにはムーブ元の変数<code>x</code>を<code>std::move(x)</code>のようにしてコピーする。<code>std::move</code>はこのコピーはコピーではなくムーブしてもよいというヒントになる。</p>
<p>ムーブを実装するためには、まず基礎知識として次の章で学ぶ<code>rvalue</code>リファレンス、値カテゴリー、テンプレートのフォワードリファレンスの深い理解が必要になる。</p>
<h1 id="rvalueリファレンス">rvalueリファレンス</h1>
<h2 id="概要-1">概要</h2>
<p>いままで使っているリファレンスは、正式には<code>lvalue</code>リファレンスという名前がついている。これは<code>lvalue</code>へのリファレンスという意味だ。<code>lvalue</code>へのリファレンスがあるからには、<code>lvalue</code>ではないリファレンスがあるということだ。C++には<code>rvalue</code>へのリファレンスがある。これを<code>rvalue</code>リファレンスという。</p>
<p>この章で説明する内容はとても難しい。完全に理解するためには、何度も読み直す必要があるだろう。</p>
<h2 id="rvalueリファレンスの宣言">rvalueリファレンスの宣言</h2>
<p><code>T</code>型への<code>lvalue</code>型リファレンス型は<code>T &amp;</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">T &amp; lvalue_reference = ... ;</code></pre></div>
<p><code>T</code>型への<code>rvalue</code>リファレンス型は<code>T &amp;&amp;</code>と書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">T &amp;&amp; rvalue_reference = ... ;</code></pre></div>
<p><code>lvalue</code>リファレンスは<code>lvalue</code>で初期化する。<code>rvalue</code>リファレンスは<code>rvalue</code>で初期化する。</p>
<p><code>lvalue</code>とは名前付きのオブジェクトや戻り値の型としての<code>lvalue</code>リファレンスのことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> object { } ;
<span class="dt">int</span> &amp; f() { <span class="kw">return</span> object ; }

<span class="dt">int</span> main()
{
    <span class="co">// lvalueリファレンス</span>
    <span class="dt">int</span> &amp; a = object ;
    <span class="dt">int</span> &amp; b = f() ;
}</code></pre></div>
<p>ここで、式<code>object</code>や式<code>f()</code>を評価した結果は<code>lvalue</code>だ。</p>
<p><code>rvalue</code>とは、名前なしのオブジェクトや計算結果の一時オブジェクト、戻り値の型としての<code>rvalue</code>リファレンスのことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp;&amp; g() { <span class="kw">return</span> <span class="dv">0</span> ; }
<span class="dt">int</span> h() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="dt">int</span> main()
{
    <span class="co">// rvalueリファレンス</span>
    <span class="dt">int</span> &amp;&amp; a = <span class="dv">0</span> ;
    <span class="dt">int</span> &amp;&amp; b = <span class="dv">1</span> + <span class="dv">1</span> ;
    <span class="dt">int</span> &amp;&amp; c = g() ;
    <span class="dt">int</span> &amp;&amp; d = h() ;
}</code></pre></div>
<p>ここで、式<code>0</code>、式<code>1 + 1</code>、式<code>g()</code>を評価した結果は<code>rvalue</code>だ。</p>
<p><code>rvalue</code>リファレンスを<code>lvalue</code>で初期化することはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> object { } ;
<span class="dt">int</span> &amp; f() { <span class="kw">return</span> object ; }

<span class="dt">int</span> main()
{
    <span class="co">// すべてエラー</span>
    <span class="dt">int</span> &amp;&amp; a = object ;
    <span class="dt">int</span> &amp;&amp; b = f() ;
}</code></pre></div>
<p><code>lvalue</code>リファレンスを<code>rvalue</code>で初期化することはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp;&amp; g() { <span class="kw">return</span> <span class="dv">0</span> ; }
<span class="dt">int</span> h() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="dt">int</span> main()
{
    <span class="co">// すべてエラー</span>
    <span class="dt">int</span> &amp; a = <span class="dv">0</span> ;
    <span class="dt">int</span> &amp; b = <span class="dv">1</span> + <span class="dv">1</span> ;
    <span class="dt">int</span> &amp; c = g() ;
    <span class="dt">int</span> &amp; d = h() ;
}</code></pre></div>
<p>リファレンスを初期化することを、リファレンスはリファレンス先を束縛するという。<code>lvalue</code>リファレンスは<code>lvalue</code>を束縛する。<code>rvalue</code>リファレンスは<code>rvalue</code>を束縛する。</p>
<p>ただし、<code>const</code>な<code>lvalue</code>リファレンスは<code>rvalue</code>を束縛することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp;&amp; g() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="dt">int</span> main()
{
    <span class="co">// OK、constなlvalueリファレンス</span>
    <span class="dt">const</span> <span class="dt">int</span> &amp; a = <span class="dv">0</span> ;
    <span class="dt">const</span> <span class="dt">int</span> &amp; b = <span class="dv">1</span> + <span class="dv">1</span> ;
    <span class="dt">const</span> <span class="dt">int</span> &amp; c = g() ;
}</code></pre></div>
<p><code>rvalue</code>リファレンス自体は<code>lvalue</code>だ。なぜならば<code>rvalue</code>リファレンスはオブジェクトに名前を付けて束縛するからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// rvalueリファレンス</span>
    <span class="dt">int</span> &amp;&amp; a = <span class="dv">0</span> ;
    <span class="co">// OK、rvalueリファレンスaはlvalue</span>
    <span class="dt">int</span> &amp; b = a ;
    <span class="co">// エラー、rvalueリファレンスaはrvalueではない</span>
    <span class="dt">int</span> &amp;&amp; b = a ;
}</code></pre></div>
<h2 id="値カテゴリー">値カテゴリー</h2>
<p><code>lvalue</code>と<code>rvalue</code>とは何か。もともと<code>lvalue</code>とは左辺値(left-hand value)、<code>rvalue</code>とは右辺値(right-hand value)という語源を持っている。これはまだC言語すらなかったはるか昔から存在する用語で、代入式の左辺に書くことができる値を<code>lvalue</code>、右辺に書くことができる値を<code>rvalue</code>と読んでいたことに由来する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">lvalue = rvalue ;</code></pre></div>
<p>例えば、<code>int</code>型の変数<code>x</code>は代入式の左辺に書くことができるから<code>lvalue</code>、整数リテラル<code>0</code>は右辺に書くことができるから<code>rvalue</code>といった具合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x ;
x = <span class="dv">0</span> ;</code></pre></div>
<p>C++では<code>lvalue</code>と<code>rvalue</code>をこのような意味では使っていない。</p>
<p><code>lvalue</code>と<code>rvalue</code>を理解するには、値カテゴリーを理解しなければならない。</p>
<ol style="list-style-type: decimal">
<li>式(expression)とは<code>glvalue</code>か<code>rvalue</code>である。</li>
<li><code>glvalue</code>とは<code>lvalue</code>か<code>xvalue</code>である。</li>
<li><code>rvalue</code>とは<code>prvalue</code>か<code>xvalue</code>である。</li>
</ol>
<p>この関係を図示すると以下のようになる。</p>
<div class="figure">
<img src="fig-kurema/fig37-01.svg" />

</div>
<h3 id="lvalue">lvalue</h3>
<p><code>lvalue</code>はすでに説明したとおり名前付きのオブジェクトのことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lvalue</span>
<span class="dt">int</span> object ;
<span class="dt">int</span> &amp; ref = object ;</code></pre></div>
<p>通常使うほとんどのオブジェクトは<code>lvalue</code>になる。</p>
<h3 id="prvalue">prvalue</h3>
<p><code>prvalue</code>は純粋な<code>rvalue</code>(pure rvalue)のことだ。つまり、名前なしのオブジェクトや計算結果の一時オブジェクトのことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="co">// prvalue</span>
<span class="dv">0</span> ;
<span class="dv">1</span> + <span class="dv">1</span> ;
f() ;</code></pre></div>
<p>ほとんどの<code>prvalue</code>は式を評価するときに自動的に生成され、自動的に破棄されるので、あまり意識することはない。</p>
<p>関数の戻り値の型がリファレンスではない場合、一時オブジェクトが生成される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X { } ;
X f() ;</code></pre></div>
<p>演算子も関数の一種なので、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> result = x + y + z ;</code></pre></div>
<p>のような式がある場合、まず<code>x + y</code>が評価され、その結果が一時オブジェクトとして返される。その一時オブジェクトを仮に<code>temp</code>とすると、<code>temp + z</code>が評価され、また一時オブジェクトが生成され、変数<code>result</code>に代入される。</p>
<p>式文全体を評価し終わったあとに、一時オブジェクトは自動的に破棄される。</p>
<p>一時オブジェクトは自動的に生成され、自動的に破棄される。ここがとても重要な点だ。これは次の章で説明するムーブセマンティクスに関わってくる。</p>
<h3 id="xvalue">xvalue</h3>
<p><code>xvalue</code>とは寿命が尽きかけている<code>lvalue</code>(eXpiring lvalue)のことだ。<code>xvalue</code>は<code>lvalue</code>や<code>prvalue</code>から変換することで発生する。</p>
<p><code>xvalue</code>となる値は以下のような場合だ。</p>
<ul>
<li>戻り値の型がオブジェクトの型への<code>rvalue</code>リファレンスである関数の呼び出しの結果</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp;&amp; f() { <span class="kw">return</span> <span class="dv">0</span> ; }

<span class="dt">int</span> main()
{
    <span class="co">// xvalue</span>
    <span class="dt">int</span> &amp;&amp; r = f() ;
}</code></pre></div>
<ul>
<li>オブジェクトの型への<code>rvalue</code>リファレンスへのキャスト</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> object{} ;
    <span class="co">// xvalue</span>
    <span class="dt">int</span> &amp;&amp; r = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> &amp;&amp;&gt;(object) ;
}</code></pre></div>
<ul>
<li><code>xvalue</code>配列への添字操作</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="dt">int</span> &amp;&amp; r = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> (&amp;&amp;)[<span class="dv">3</span>]&gt;(a)[<span class="dv">0</span>] ;
}</code></pre></div>
<p><code>xvalue</code>配列というのは配列のオブジェクトを配列への<code>rvalue</code>リファレンス型にキャストすると得られる。<code>xvalue</code>配列への添字操作の結果は<code>xvalue</code>だ。</p>
<ul>
<li><code>xvalue</code>なクラスのオブジェクトへのリファレンスではない非<code>static</code>データメンバーへのアクセス</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X { <span class="dt">int</span> data_member ; } ;

<span class="dt">int</span> main()
{
    X x{} ;
    <span class="dt">int</span> &amp;&amp; r = <span class="kw">static_cast</span>&lt;X &amp;&amp;&gt;(x).data_member ;
}</code></pre></div>
<ul>
<li>式<code>.*</code>で最初のオペランドが<code>xvalue</code>で次のオペランドがデータメンバーへのポインターの場合</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X { <span class="dt">int</span> data_member ; } ;

<span class="dt">int</span> main()
{
    X x{} ;
    <span class="dt">int</span> &amp;&amp; r = <span class="kw">static_cast</span>&lt;X &amp;&amp;&gt;(x).*&amp;X::data_member ;
}</code></pre></div>
<p>これも配列と似ていて、<code>xvalue</code>のクラスオブジェクトに対するメンバーへのポインター経由でのメンバーの参照結果は<code>xvalue</code>になるということだ。</p>
<p>重要なのは最初の2つだ。残りは覚える必要はない。重要なのは、<code>xvalue</code>とは、<code>lvalue</code>か<code>prvalue</code>から変換した結果発生するものだ。</p>
<h3 id="rvalue">rvalue</h3>
<p><code>prvalue</code>と<code>xvalue</code>を合わせて、<code>rvalue</code>という。<code>rvalue</code>リファレンスというのは、<code>rvalue</code>でしか初期化できない。<code>rvalue</code>というのは<code>prvalue</code>か<code>xvalue</code>のどちらかだ。</p>
<p><code>lvalue</code>は<code>xvalue</code>に変換できるので、結果として<code>rvalue</code>に変換できることになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// lvalueなオブジェクト</span>
    <span class="dt">int</span> lvalue { } ;

    <span class="co">// OK、lvalueリファレンスはlvalueで初期化できる</span>
    <span class="dt">int</span> &amp; l_ref = lvalue ;

    <span class="co">// OK、rvalueリファレンスはrvalueで初期化できる</span>
    <span class="co">// rvalueリファレンスにキャストした結果はrvalue</span>
    <span class="dt">int</span> &amp;&amp; r_ref = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> &amp;&amp;&gt;(lvalue) ;
}</code></pre></div>
<p><code>lvalue</code>はそのままでは<code>rvalue</code>ではないが、<code>xvalue</code>に変換すれば<code>rvalue</code>になる。</p>
<p><code>prvalue</code>はもともと<code>rvalue</code>である。</p>
<p>この性質は次の章で説明するムーブセマンティクスで利用する。</p>
<h3 id="glvalue">glvalue</h3>
<p><code>glvalue</code>は一般的な<code>lvalue</code>(generalized lvalue)という意味だ。<code>glvalue</code>とは、<code>lvalue</code>か<code>xvalue</code>のことだ。</p>
<p><code>lvalue</code>から変換した<code>xvalue</code>はもともと<code>lvalue</code>だったのだから、<code>glvalue</code>となるのも自然だ。<code>xvalue</code>に変換した<code>prvalue</code>は<code>glvalue</code>になれる。</p>
<p>この性質はムーブセマンティクスで利用する。</p>
<h2 id="rvalueリファレンスのライブラリ">rvalueリファレンスのライブラリ</h2>
<h3 id="stdmove">std::move</h3>
<p><code>std::move(e)</code>は値<code>e</code>を<code>xvalue</code>にするための標準ライブラリだ。<code>std::move(e)</code>は値<code>e</code>の型<code>T</code>への<code>rvalue</code>リファレンス型にキャストしてくれるので、<code>xvalue</code>になる。そして<code>xvalue</code>は<code>rvalue</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> lvalue { } ;
    <span class="dt">int</span> &amp;&amp; r = std::move(lvalue) ;
}</code></pre></div>
<p>これは以下のように書いたものと同じようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> lvalue { } ;
    <span class="dt">int</span> &amp;&amp; r = <span class="kw">static_cast</span>&lt;<span class="dt">int</span> &amp;&amp;&gt;(lvalue) ;
}</code></pre></div>
<h3 id="stdmoveの実装">std::moveの実装</h3>
<p><code>std:move(e)</code>の実装は少し難しい。根本的には、式<code>e</code>のリファレンスではない型<code>T</code>に対して、<code>static_cast&lt;T &amp;&amp;&gt;(e)</code>をしているだけだ。</p>
<p>すると以下のような実装だろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T &amp;&amp; move( T &amp; t ) <span class="kw">noexcept</span>
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;T &amp;&amp;&gt;(t) ;
}</code></pre></div>
<p>この実装は<code>lvalue</code>を<code>xvalue</code>に変換することはできるが、<code>rvalue</code>(<code>prvalue</code>と<code>xvalue</code>)を<code>xvalue</code>に変換することはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、prvalueを変換できない</span>
    <span class="dt">int</span> &amp;&amp; r1 = move(<span class="dv">0</span>) ;

    <span class="dt">int</span> lvalue { } ;
    <span class="co">// エラー、xvalueをxvalueに変換できない</span>
    <span class="dt">int</span> &amp;&amp; r2 = move(move(lvalue)) ;
}</code></pre></div>
<p><code>rvalue</code>は<code>rvalue</code>リファレンスで受け取れるので、<code>lvalue</code>リファレンスを関数の引数として受け取る<code>move</code>のほかに、<code>rvalue</code>リファレンスを関数の引数として受け取る<code>move</code>を書くとよい。</p>
<p>すると以下のように書けるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lvalueリファレンス</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T &amp;&amp; move( T &amp; t ) <span class="kw">noexcept</span>
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;T &amp;&amp;&gt;(t) ;
}

<span class="co">// rvalueリファレンス</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T &amp;&amp; move( T &amp;&amp; t ) <span class="kw">noexcept</span>
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;T &amp;&amp;&gt;(t) ;
}</code></pre></div>
<p>しかしこれでは関数の本体の中身がまったく同じ関数が2つできてしまう。もっと複雑な関数を書くときにこのようなコードの重複があると、ソースコードの修正が難しくなる。せっかくテンプレートを使っているのにこれでは意味がない。</p>
<h3 id="フォワーディングリファレンス">フォワーディングリファレンス</h3>
<p>C++のテンプレートはコードの重複を省くためにある。そのため、C++ではテンプレートパラメーターへの<code>rvalue</code>リファレンスを関数の仮引数として取る場合を、フォワーディングリファレンス(forwarding reference)として、特別に<code>lvalue</code>でも<code>rvalue</code>でも受け取れるようにしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// T &amp;&amp;はフォワーディングリファレンス</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp;&amp; t ) ;</code></pre></div>
<p>このような関数テンプレートの仮引数<code>t</code>に実引数として<code>rvalue</code>を渡すと、<code>T</code>は<code>rvalue</code>の型となり、結果として<code>t</code>の型は<code>T &amp;&amp;</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Tはint</span>
f(<span class="dv">0</span>) ;</code></pre></div>
<p>もし実引数として型<code>U</code>の<code>lvalue</code>を渡すと、テンプレートパラメーター<code>T</code>が<code>U &amp;</code>となる。そして、テンプレートパラメーター<code>T</code>に対するリファレンス宣言子(<code>&amp;</code>, <code>&amp;&amp;</code>)は単に無視される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> lvalue{} ;
<span class="co">// Tはint &amp;</span>
<span class="co">// T &amp;&amp;はint &amp;</span>
f(lvalue) ;</code></pre></div>
<p>ここで、関数テンプレート<code>f</code>のテンプレートパラメーター<code>T</code>は<code>int &amp;</code>となる。この<code>T</code>にリファレンス宣言子を<code>T &amp;</code>や<code>T &amp;&amp;</code>のように使っても、単に無視されて、<code>T &amp;</code>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp;&amp; t )
{
    <span class="kw">using</span> A = T &amp; ;
    <span class="kw">using</span> B = T &amp;&amp; ; 
}

<span class="dt">int</span> main()
{
    <span class="co">// prvalue</span>
    f(<span class="dv">0</span>) ;
    <span class="dt">int</span> lvalue{} ;
    <span class="co">// lvalue</span>
    f(lvalue) ;
}</code></pre></div>
<p><code>f(0)</code>は<code>prvalue</code>を渡している。この場合、<code>T</code>の型は<code>int</code>となる。<code>A</code>は<code>int &amp;</code>、<code>B</code>は<code>int &amp;&amp;</code>となる。</p>
<p><code>f(lvalue)</code>は<code>lvalue</code>を渡している。この場合、<code>T</code>の型は<code>int &amp;</code>となる。この場合の<code>T</code>に<code>&amp;</code>や<code>&amp;&amp;</code>を付けても無視される。なので、<code>A</code>, <code>B</code>の型はどちらも<code>int &amp;</code>になる。</p>
<p>したがって、以下のように書くと<code>move</code>は<code>lvalue</code>も<code>rvalue</code>も受け取ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lvalueもrvalueも受け取ることができるmove</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T &amp;&amp; move( T &amp;&amp; t ) <span class="kw">noexcept</span>
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;T &amp;&amp;&gt;(t) ;
}</code></pre></div>
<p>ただし、この実装にはまだ問題がある。この<code>move</code>に<code>lvalue</code>を渡した場合、<code>lvalue</code>の型を<code>U</code>とすると、テンプレートパラメーター<code>T</code>は<code>U &amp;</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">U lvalue{} ;
<span class="co">// TはU &amp;</span>
move( lvalue ) ;</code></pre></div>
<p>テンプレートパラメーター名<code>T</code>がリファレンスのとき、<code>T</code>にリファレンス宣言子<code>&amp;&amp;</code>を付けても単に無視されることを考えると、上の<code>move</code>に<code>int &amp;</code>型の<code>lvalue</code>が実引数として渡されたときは、以下のように書いたものと等しくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp; move( <span class="dt">int</span> &amp; t ) <span class="kw">noexcept</span>
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">int</span> &amp;&gt;(t) ;
}</code></pre></div>
<p><code>move(e)</code>は<code>e</code>が<code>lvalue</code>であれ<code>rvalue</code>であれ、<code>xvalue</code>にする関数だ。そのためには、<code>rvalue</code>リファレンスにキャストしなければならない。テンプレートではフォーワーディングリファレンスという例外的な仕組みによって<code>lvalue</code>も<code>rvalue</code>も<code>T &amp;&amp;</code>で受け取れるが、<code>lvalue</code>を受け取ったときには<code>T &amp;&amp;</code>が<code>lvalue</code>リファレンスになってしまうのでは、<code>xvalue</code>にキャストできない。</p>
<p>この問題は別のライブラリによって解決できる。</p>
<h3 id="stdremove_reference_t">std::remove_reference_t<T></h3>
<p><code>std::remove_reference_t&lt;T&gt;</code>は<code>T</code>型からリファレンス型を除去してくれるライブラリだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int</span>
    <span class="kw">using</span> A = std::remove_reference_t&lt;<span class="dt">int</span>&gt; ;
    <span class="co">// int</span>
    <span class="kw">using</span> B = std::remove_reference_t&lt;<span class="dt">int</span> &amp;&gt; ;
    <span class="co">// int</span>
    <span class="kw">using</span> C = std::remove_reference_t&lt;<span class="dt">int</span> &amp;&amp;&gt; ;
}</code></pre></div>
<p>ということは、これとリファレンス宣言子を組み合わせると、どのような型がテンプレート実引数に渡されても<code>rvalue</code>リファレンスにできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="kw">using</span> RT = std::remove_reference_t&lt;T&gt; &amp;&amp; ;
}</code></pre></div>
<p><code>add_pointer_t/remove_pointer_t</code>があるように、<code>remove_reference_t</code>にも対となるリファレンスを追加するライブラリが存在する。ただしリファレンスには<code>lvalue</code>リファレンスと<code>rvalue</code>リファレンスがあるので、それぞれ<code>std::add_lvalue_reference_t&lt;T&gt;</code>、<code>std::add_rvalue_reference_t&lt;T&gt;</code>となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int &amp;</span>
    <span class="kw">using</span> A = std::add_lvalue_reference_t&lt;<span class="dt">int</span>&gt; ;
    <span class="co">// int &amp;&amp;</span>
    <span class="kw">using</span> B = std::add_rvalue_reference_t&lt;<span class="dt">int</span>&gt; ;
}</code></pre></div>
<h3 id="stdmoveの正しい実装">std::moveの正しい実装</h3>
<p><code>std::remove_reference_t&lt;T&gt;</code>を使うと、<code>move</code>は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
std::remove_reference_t&lt;T&gt; &amp;&amp; move( T &amp;&amp; t ) <span class="kw">noexcept</span>
{
    <span class="kw">return</span> <span class="kw">static_cast</span>&lt; std::remove_reference_t&lt;T&gt; &amp;&amp; &gt;(t) ;
}</code></pre></div>
<h3 id="stdforward">std::forward</h3>
<p>テンプレートパラメーターに<code>rvalue</code>リファレンス宣言子を使うと<code>lvalue</code>も<code>rvalue</code>も受け取れる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp;&amp; t ) { }

<span class="dt">int</span> main()
{
    <span class="dt">int</span> lvalue{} ;
    f(lvalue) ;
    f(<span class="dv">0</span>) ;
}</code></pre></div>
<p>この関数<code>f</code>から別の関数<code>g</code>に値を渡したい場合を考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> g( T &amp;&amp; t ) { }

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp;&amp; t )
{
    g(t) ;
}</code></pre></div>
<p>このとき、関数<code>f</code>に渡されたものが<code>lvalue</code>でも<code>rvalue</code>でも、関数<code>g</code>に渡される値は<code>lvalue</code>になってしまう。</p>
<p>なぜならば、名前付きの<code>rvalue</code>リファレンスに束縛されたオブジェクトは<code>lvalue</code>だからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 名前付きのrvalueリファレンス</span>
    <span class="dt">int</span> &amp;&amp; rvalue_ref = <span class="dv">0</span> ;
    <span class="co">// これはlvalue</span>
    <span class="dt">int</span> &amp; lvalue_ref = rvalue_ref ;
}</code></pre></div>
<p>なので、<code>g(t)</code>の<code>t</code>は<code>lvalue</code>となる。</p>
<p>ここで<code>rvalue</code>を渡すのは簡単だ。<code>std::move</code>を使えばいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp;&amp; t )
{
    g( std::move(t) ) ;
}</code></pre></div>
<p>ただし、これは<code>t</code>が<code>lvalue</code>のときも問答無用で<code>xvalue</code>にしてしまう。</p>
<p><code>t</code>が<code>lvalue</code>ならば<code>lvalue</code>として、<code>rvalue</code>ならば<code>xvalue</code>として、渡された値カテゴリーのまま別の関数に渡したい場合、<code>std::forward&lt;T&gt;(t)</code>が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T &amp;&amp; t )
{
    g( std::forward&lt;T&gt;(t) ) ;
}</code></pre></div>
<p><code>std::forward&lt;T&gt;(t)</code>の<code>T</code>にはテンプレートパラメーター名を書く。こうすると、<code>t</code>が<code>lvalue</code>ならば<code>lvalue</code>リファレンス、<code>rvalue</code>ならば<code>rvalue</code>リファレンスが戻り値として返される。</p>
<p><code>std::forward</code>の実装は以下のとおりだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="kw">constexpr</span> 
T &amp;&amp;
forward(remove_reference_t&lt;T&gt;&amp; t) <span class="kw">noexcept</span>
{ <span class="kw">return</span> <span class="kw">static_cast</span>&lt;T&amp;&amp;&gt;(t) ; }

<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="kw">constexpr</span> 
T &amp;&amp;
forward(remove_reference_t&lt;T&gt;&amp;&amp; t) <span class="kw">noexcept</span>
{ <span class="kw">return</span> <span class="kw">static_cast</span>&lt;T&amp;&amp;&gt;(t) ; }</code></pre></div>
<p>もし<code>std::forward&lt;T&gt;(t)</code>に<code>lvalue</code>が渡された場合、上の<code>forward</code>が呼ばれる。その場合、<code>T</code>は<code>lvalue</code>リファレンスになっているはずなので<code>rvalue</code>リファレンス宣言子は無視され、<code>lvalue</code>リファレンスが戻り値の型になる。</p>
<p><code>rvalue</code>が渡された場合、<code>rvalue</code>リファレンスが戻り値の型になる。</p>
<h1 id="ムーブの実装">ムーブの実装</h1>
<p>ムーブ(move)とはコピー(copy)と対になる概念だ。ムーブというのはやや特殊なコピーとみなすこともできる。</p>
<p>ムーブの使い方とその内部の挙動についてはムーブの章で説明した。</p>
<p>実際に自作のクラスでムーブを実装するには、<code>rvalue</code>リファレンスの章で説明した<code>rvalue</code>リファレンス、値カテゴリー、テンプレートのフォワードリファレンスの詳細な理解が必要になる。</p>
<p>まだこの2つの章を読んでいない読者はこの章を理解する準備ができていない。一度だけしか読んでいない読者は完全に理解はできないだろうから、この章を読んだ後にもう一度立ち返って読み直すべきだ。</p>
<p>この章ではサンプルコードの簡略化のために、メンバー関数の定義をあたかもクラスの中で書いたかのように扱う。</p>
<p>例えば、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> S { T x ; } ;</code></pre></div>
<p>があり、このクラス<code>S&lt;T&gt;</code>のコンストラクターを続いて</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">S( T <span class="dt">const</span> &amp; x ) : x(x) { }</code></pre></div>
<p>と書くことがある。これは実際には間違いで、正しくは以下のように書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> S
{
    T x ;
    <span class="co">// 宣言</span>
    S( T <span class="dt">const</span> &amp; ) ;
} ;
<span class="co">// 定義</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
S&lt;T&gt;::S( T <span class="dt">const</span> &amp; x ) : x(x) { }</code></pre></div>
<p>この章では煩わしいので簡略した書き方を使う。</p>
<h2 id="コピーとムーブの判別">コピーとムーブの判別</h2>
<p>ムーブはムーブ元のオブジェクトを無効にする可能性がある。そのためムーブはムーブをしても安全な場合にしか行われない。</p>
<p>コピーはコピーコンストラクターとコピー代入演算子で実装する。</p>
<p>コピーは<code>lvalue</code>リファレンスを取る。通常は<code>const</code>な<code>lvalue</code>リファレンス型を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// コピーコンストラクター</span>
    X( <span class="dt">const</span> X &amp; ) ;
    <span class="co">// コピー代入演算子</span>
    X &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> X &amp; ) ;
} ;</code></pre></div>
<p>ムーブはムーブコンストラクターとムーブ代入演算子で実装する。</p>
<p>ムーブは<code>rvalue</code>リファレンスを取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// ムーブコンストラクター</span>
    X( X &amp;&amp; ) ;
    <span class="co">// ムーブ代入演算子</span>
    X &amp; <span class="kw">operator</span> = ( X &amp;&amp; ) ;
} ;</code></pre></div>
<p>コピーとムーブの区別は<code>lvalue</code>/<code>rvalue</code>リファレンスで行われる。なぜこれで動くのかというと、<code>rvalue</code>リファレンスで束縛できる値は、</p>
<ol style="list-style-type: decimal">
<li>無名の一時オブジェクト(<code>prvalue</code>)</li>
<li>明示的に<code>rvalue</code>リファレンスにキャストされたオブジェクト(<code>xvalue</code>)</li>
</ol>
<p>のどちらかだからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">const</span> <span class="dt">int</span> &amp; ) 
{
    std::cout &lt;&lt; <span class="st">&quot;lvalue</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}
<span class="dt">void</span> f( <span class="dt">int</span> &amp;&amp; )
{
    std::cout &lt;&lt; <span class="st">&quot;rvalue</span><span class="ch">\n</span><span class="st">&quot;</span>s ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> object { } ;

    f( object ) ; <span class="co">// lvalue</span>
    f( object + object ) ; <span class="co">// rvalue</span>
    f( []{ <span class="kw">return</span> object ; }() ) ; <span class="co">// rvalue</span>
    f( std::move(object) ) ; <span class="co">// rvalue</span>
}</code></pre></div>
<p>変数名を書いた式<code>object</code>を評価した結果は<code>lvalue</code>なので<code>lvalue</code>と表示される。</p>
<p>変数を演算子<code>+</code>で加算する式<code>object + object</code>を評価した結果は<code>prvalue</code>なので<code>rvalue</code>と表示される。</p>
<p>戻り値の型が<code>int</code>型のラムダ式を呼び出す式<code>[]{ return 0 ; }()</code>を評価した結果は<code>prvalue</code>なので<code>rvalue</code>と表示される。</p>
<p><code>std::move(object)</code>を評価した結果は<code>xvalue</code>なので<code>rvalue</code>と表示される。</p>
<p><code>prvalue</code>は無名の一時オブジェクトなので、その値はすぐに破棄される。どうせ破棄されるのであれば、所有権を横取りしてもよい。</p>
<p><code>xvalue</code>はユーザーが明示的に<code>rvalue</code>リファレンスにキャストした値だ。明示的に<code>rvalue</code>リファレンスにキャストしたということは、ユーザーはその値について、それ以降興味がないという意思を示したことになる。なので、そのような値からは所有権を横取りしてもよい。</p>
<p>特殊なルールとして、関数のローカル変数をオペランドに指定した<code>return</code>文はムーブをする可能性がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::vector&lt;<span class="dt">int</span>&gt; f()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    v.push_back(<span class="dv">1</span>) ;
    v.push_back(<span class="dv">2</span>) ;
    v.push_back(<span class="dv">3</span>) ;
    <span class="co">// ムーブをする可能性がある</span>
    <span class="kw">return</span> v ;
}</code></pre></div>
<p>これは関数のローカル変数は<code>return</code>文が実行されたときには無効になるので、特別に存在するルールだ。そもそも、関数の<code>return</code>文はコピーもムーブもしない可能性がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 先ほどの関数f</span>
    <span class="kw">auto</span> v = f() ;
}</code></pre></div>
<p>C++コンパイラーは以下のようにコードを変形することも許されているからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v ;
    v.push_back(<span class="dv">1</span>) ;
    v.push_back(<span class="dv">2</span>) ;
    v.push_back(<span class="dv">3</span>) ;
}</code></pre></div>
<h2 id="ムーブの実装-1">ムーブの実装</h2>
<p>以下のようなクラスにムーブを実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> dynamic_array
{
<span class="kw">private</span> :
    T * first ;
    T * last ;
<span class="kw">public</span> :
    dynamic_array( std::size_t size = <span class="dv">0</span> )
        : first( <span class="kw">new</span> T[size]), last( first + size )
    { }
    ~dynamic_array()
    { <span class="kw">delete</span>[] first ; }
} ;</code></pre></div>
<p>ムーブは所有権の移動だ。所有権の移動は、単にポインターをコピーするだけで済む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dynamic_array&lt;<span class="dt">int</span>&gt; source(<span class="dv">10</span>) ;
<span class="co">// ムーブ</span>
dynamic_array&lt;<span class="dt">int</span>&gt; destination = std::move(source) ;</code></pre></div>
<p>具体的な処理としては、</p>
<ol style="list-style-type: decimal">
<li>ムーブ先へ所有権の移動</li>
<li>ムーブ元の所有権の放棄</li>
</ol>
<p>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1. ムーブ先へ所有権の移動</span>
destination.first = source.first ;
destination.last = source.last ;
<span class="co">// 2. ムーブ元の所有権の放棄</span>
source.first = <span class="kw">nullptr</span> ;
source.last = <span class="kw">nullptr</span> ;</code></pre></div>
<p>とするのと同じだ。ストレージの所有権を<code>source</code>から<code>destination</code>に移動している。移動後、<code>source</code>の破棄に伴ってストレージが<code>delete</code>されないために、<code>source</code>のポインターの値は<code>nullptr</code>にする。移動後の<code>source</code>はもうストレージを所有していない。</p>
<h3 id="ムーブコンストラクター">ムーブコンストラクター</h3>
<p>ムーブコンストラクターは以下のように実装できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dynamic_array( dynamic_array &amp;&amp; r )
    <span class="co">// ムーブ先へ所有権の移動</span>
    : first( r.first ), last( r.last )
{
    <span class="co">// ムーブ元の所有権の放棄</span>
    r.first = <span class="kw">nullptr</span> ;
    r.last = <span class="kw">nullptr</span> ;
}</code></pre></div>
<h3 id="ムーブ代入演算子">ムーブ代入演算子</h3>
<p>ムーブ代入の場合、すでにクラスのオブジェクトは構築されている。つまりムーブ先のクラスのオブジェクトはすでにストレージを所有しているかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dynamic_array&lt;<span class="dt">int</span>&gt; source(<span class="dv">10</span>) ;
dynamic_array&lt;<span class="dt">int</span>&gt; destination(<span class="dv">10</span>) ;
<span class="co">// destinationはすでにストレージを所有</span>
destination = std::move(source) ;</code></pre></div>
<p>そのため、ムーブ代入演算子はまず自身が所有しているストレージを解放する必要がある。そのため、処理は以下のようになる。</p>
<ol style="list-style-type: decimal">
<li>ムーブ先の所有権の解放</li>
<li>ムーブ先へ所有権の移動</li>
<li>ムーブ元の所有権の放棄</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1. ムーブ先の所有権の解放</span>
<span class="kw">delete</span> destination.first ;
<span class="co">// 2. ムーブ先へ所有権の移動</span>
destination.first = source.first ;
destination.last = source.last ;
<span class="co">// 3. ムーブ元の所有権の放棄</span>
source.first = <span class="kw">nullptr</span> ;
source.last = <span class="kw">nullptr</span> ;</code></pre></div>
<p>ただし、この実装は自分自身へのムーブ代入に対応できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">destination = std::move( destination ) ;</code></pre></div>
<p>これは意図的なものだ。</p>
<p>一般的なムーブ代入、つまり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a = std::move(b) ;</code></pre></div>
<p>というコードでムーブが実行された場合、変数<code>b</code>はその後使えない状態になる。もし<code>b</code>が<code>a</code>と同じである場合、<code>b</code>が使えない状態になるということは<code>a</code>も使えない状態になることはやむを得ないのが普通の挙動だ。</p>
<p>普通の挙動がコピー代入と異なるのは、歴史的経緯やムーブという破壊的な操作の性質から来るものだ。</p>
<p>C++の標準ライブラリは自分自身へのムーブ代入後のオブジェクトの状態について、「有効だが未規定の状態」としている。</p>
<p>たとえば、現在の主要なC++の実装では、<code>std::vector</code>で自分自身へのムーブ代入を行うと<code>clear()</code>が呼び出される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;
    v = std::move(v) ;
    v.size() ; <span class="co">// 0</span>
}</code></pre></div>
<p>ムーブ代入でも、コピー代入のように何もしない実装にすることもできる。しかし、C++ではさまざまな議論の結果、ムーブ代入は自己代入を積極的に何もしない挙動にはしないということになっている。</p>
<p>自分自身へのムーブ代入は誤りである。</p>
<p>自分自身へのムーブ代入がうっかり発生する場合は、エイリアシングによるものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> moving( T &amp; a, T &amp; b )
{
    a = std::move(b) ;
}</code></pre></div>
<p>このコードが以下のように呼ばれた場合、変数<code>a</code>, <code>b</code>ともに同じオブジェクトを指しているので、自分自身へのムーブ代入になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,} ;
    moving( v, v ) ;
}</code></pre></div>
<p>そのため、素性のわからない間接参照を挟むオブジェクトをムーブ代入するときは、自分自身へのムーブ代入の回避が必要になる。</p>
<p>そのための方法は2つある。</p>
<p>1つはポインターを比較することだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> moving( T &amp; a, T &amp; b )
{
    <span class="kw">if</span> ( &amp;a != &amp;b )
        a = std::move(b) ;
}</code></pre></div>
<p>ただしこれは追加の比較が入るのでパフォーマンスに影響を与える。</p>
<p>もう1つは、ユーザーにエイリアシングを起こさないことを求めることだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 仕様</span>
<span class="co">// この関数のa, bに同じオブジェクトを渡してはならない</span>
<span class="co">// 渡した場合の挙動は未定義</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> moving( T &amp; a, T &amp; b )
{
    a = std::move(b) ;
}</code></pre></div>
<p>これはつまり、ユーザーに責任を押し付けるということだ。</p>
<p>ムーブ代入演算子は以下のように実装できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">dynamic_array &amp; <span class="kw">operator</span> = ( dynamic_array &amp;&amp; r )
{
    <span class="co">// ムーブ先のストレージの解放</span>
    <span class="kw">delete</span> first ;

    <span class="co">// ムーブ先へ所有権の移動</span>
    first = r.first ;
    last = r.last ;
    <span class="co">// ムーブ元の所有権の放棄</span>
    r.first = <span class="kw">nullptr</span> ;
    r.last = <span class="kw">nullptr</span> ;

    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<h2 id="デフォルトのムーブ">デフォルトのムーブ</h2>
<p>クラスがムーブを実装しない場合、デフォルトのムーブが暗黙に定義される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> i {} ;
    std::vector&lt;<span class="dt">int</span>&gt; v ;
} ;

<span class="dt">int</span> main()
{
    X a ;
    X b ;
    b = std::move(a) ;
}</code></pre></div>
<p>デフォルトのムーブはクラスのメンバーをそれぞれムーブする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">b.i = std::move(a.i) ;
b.v = std::move(a.v) ;</code></pre></div>
<p>デフォルトのコピーと似ている。</p>
<h2 id="コピーの禁止">コピーの禁止</h2>
<p>型によっては、コピーという概念が存在しないものがある。</p>
<p>例えばコピー不可能なシステムのリソースを扱うクラスだ。</p>
<p>具体的にはファイル、スレッド、プロセス、ネットワークソケットといったリソースだ。このようなリソースを管理するクラスを作ったとして、いったいコピーをどうすればいいのだろうか。</p>
<p>コピーできないクラスは<code>deleted定義</code>を使ってコピーコンストラクターとコピー代入演算子を消すことができる。</p>
<p><code>deleted定義</code>は関数の本体<code>{...}</code>の代わりに<code>= delete</code>を書く。<code>deleted定義</code>されている関数を使うとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// コピーコンストラクター</span>
    X( <span class="dt">const</span> X &amp; ) = <span class="kw">delete</span> ;
    <span class="co">// コピー代入演算子</span>
    X &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> X &amp; ) = <span class="kw">delete</span> ;

    <span class="co">// デフォルトコンストラクター</span>
    X() { }
    <span class="co">// ムーブコンストラクター</span>
    X ( X &amp;&amp; ) { }
    <span class="co">// ムーブ代入演算子</span>
    X &amp; <span class="kw">operator</span> = ( X &amp;&amp; ) { }
} ;</code></pre></div>
<p>このようなクラス<code>X</code>は、コピーできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// デフォルト構築できる</span>
    X a ;
    <span class="co">// エラー、コピーできない</span>
    X b = a ;
    b = a ;
    <span class="co">// OK、ムーブはできる。</span>
    X c = std::move(a) ;
}</code></pre></div>
<p>クラス<code>X</code>はコピーコンスラクターとコピー代入演算子が<code>deleted定義</code>されているために、コピーをすることができない。</p>
<p>コピーやムーブが禁止されている型をデータメンバーに持つクラスは、デフォルトのコピーやムーブができなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// コピーできない型</span>
<span class="kw">struct</span> Uncopyable
{
    Uncopyable(){}
    Uncopyable( <span class="dt">const</span> Uncopyable &amp; ) = <span class="kw">delete</span> ;
    Uncopyable &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> Uncopyable &amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="co">// デフォルトのコピーができない</span>
<span class="kw">struct</span> X
{
    Uncopyable member ;
} ;</code></pre></div>
<p><code>deleted定義</code>を使えばムーブも禁止できる。ただし、ムーブを禁止するというのは現実的にはあまり実用性がない。というのも、コピーはムーブでもあるので、コピーを提供している型はムーブとしてコピーを行えばムーブも提供できることになる。</p>
<h2 id="原則">5原則</h2>
<p>C++には「5原則」という作法がある。</p>
<p>5原則とは、</p>
<ol style="list-style-type: decimal">
<li>コピーコンストラクター</li>
<li>コピー代入演算子</li>
<li>ムーブコンストラクター</li>
<li>ムーブ代入演算子</li>
<li>デストラクター</li>
</ol>
<p>このうちの1つを独自に定義したならば、残りの4つも定義すべきである。</p>
<p>というものだ。</p>
<p>なぜか。コピーやムーブを独自に定義するということは、デフォルトのコピーやムーブでは足りない何らかの処理をしたいはずだ。その処理には、たいていの場合何らかの破棄の処理が必要で、するとデストラクターも定義しなければならない。</p>
<p>同様に、デストラクターで何らかの独自の処理をするということは、コピーやムーブでも何らかの処理をしたいはずだ。</p>
<h1 id="スマートポインター-1">スマートポインター</h1>
<p>この章では、コピーできないがムーブできる型として、スマートポインターを説明する。</p>
<p>ストレージを動的確保した場合、解放しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="dt">int</span> * ptr = <span class="kw">new</span> <span class="dt">int</span>(<span class="dv">0</span>) ;
    <span class="kw">delete</span> * ptr ;
}</code></pre></div>
<p>これを正しく行うのは難しい。というのも、動的確保を複数する場合、動的確保が失敗する可能性があるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="dt">int</span> * p1 = <span class="kw">new</span> <span class="dt">int</span>(<span class="dv">0</span>) ;
    <span class="dt">int</span> * p2 = <span class="kw">new</span> <span class="dt">int</span>(<span class="dv">1</span>) ;

    <span class="kw">delete</span> p2 ;
    <span class="kw">delete</span> p1 ;
}</code></pre></div>
<p>この何気ない一見問題のなさそうなコードには問題がある。もし<code>new int(1)</code>が失敗した場合、例外が投げられ、そのまま関数<code>f</code>の実行は終わってしまう。後続の<code>delete</code>は実行されない。</p>
<p>そのような場合にスマートポインターが使える。スマートポインターはポインターの解放とムーブを代わりに行ってくれる便利なライブラリだ。</p>
<h2 id="unique_ptr">unique_ptr</h2>
<p><code>std::unique_ptr&lt;T&gt;</code>は以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> ptr = std::make_unique&lt;型&gt;( 初期化コンストラクターへの引数 )</code></pre></div>
<p>具体的には以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="co">// std::unique_ptr&lt;int&gt;</span>
    <span class="kw">auto</span> p1 = std::make_unique&lt; <span class="dt">int</span> &gt;( <span class="dv">0</span> ) ;
    <span class="kw">auto</span> p2 = std::make_unique&lt; <span class="dt">int</span> &gt;( <span class="dv">1</span> ) ;
}</code></pre></div>
<p><code>delete</code>がないが問題はない。<code>delete</code>は<code>unique_ptr</code>のデストラクターが自動で呼んでくれるからだ。</p>
<p><code>p2</code>の動的確保が失敗した場合でも問題はない。</p>
<p><code>unique_ptr</code>はポインターとほぼ同じように使うことができる。例えばポインターが参照するオブジェクトを間接的に使いたい場合は<code>operator *</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> p = std::make_unique&lt; <span class="dt">int</span> &gt;( <span class="dv">0</span> ) ;

    *p = <span class="dv">123</span> ;
    std::cout &lt;&lt; *p ;
}</code></pre></div>
<p>メンバーにアクセスするときには<code>operator -&gt;</code>も使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> p = std::make_unique&lt; std::vector&lt;<span class="dt">int</span>&gt; &gt; () ;
    p-&gt;push_back(<span class="dv">0</span>) ;
}</code></pre></div>
<p><code>unique_ptr</code>はたいへん便利なのであらゆる箇所で生のポインターの代わりに使うべきだが、古い関数に生のポインターを渡さなければならない場合などは<code>unique_ptr</code>を渡せない。そのような場合のために<code>unique_ptr</code>、生のポインターを得る方法がある。メンバー関数<code>get</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 古臭い時代遅れの生ポインターを引数に取る関数</span>
<span class="dt">void</span> old_outdated_ugly_function( <span class="dt">int</span> * ptr ) ;

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> ptr = std::make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    old_outdated_ugly_function( ptr.get() ) ;
}</code></pre></div>
<p>ただし<code>get</code>を使うときは生のポインターを使う期間が<code>unique_ptr</code>の寿命の期間内でなければならない。</p>
<p>以下のような場合は使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 前回渡したポインターの参照する値と</span>
<span class="co">// 今回渡したポインターの参照する値が</span>
<span class="co">// 等しい場合にtrueを返す</span>
<span class="dt">int</span> * last_ptr ;
<span class="dt">bool</span> is_equal_to_last_ptr( <span class="dt">int</span> * ptr )
{
    <span class="kw">if</span> ( last_ptr == <span class="kw">nullptr</span> )
        last_ptr = ptr ;

    <span class="dt">bool</span> b =  *ptr == *last_ptr ;
    last_ptr = ptr ;
    <span class="kw">return</span> b ;
}

<span class="dt">void</span> f()
{
    <span class="kw">auto</span> p = std::make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    is_equal_to_last_ptr( p.get() ) ;
}

<span class="dt">int</span> main()
{
    f() ;
    <span class="co">// エラー</span>
    f() ; 
}</code></pre></div>
<p>これは関数<code>f</code>が<code>unique_ptr</code>の寿命の期間を超えてポインターを保持して参照しているからだ。</p>
<p><code>unique_ptr</code>はコピーができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> p = std::make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="co">// エラー、コピーはできない</span>
    <span class="kw">auto</span> q = p ;
}</code></pre></div>
<p>これはポインターの値をコピーして、ポインターの所有権を持つオブジェクトが複数存在することを防ぐためだ。</p>
<p>ムーブはできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> p = std::make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="kw">auto</span> q = std::move(p) ;
}</code></pre></div>
<p>ムーブしたあとの変数<code>p</code>はポインターの所有権を持たない。</p>
<p><code>unique_ptr</code>の実装はとても簡単だ。例えば簡易的なものならば1ページに収まるほどのコード量で書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> unique_ptr
{
    T * ptr = <span class="kw">nullptr</span> ;
<span class="kw">public</span> :
    unique_ptr() { }
    <span class="kw">explicit</span> unique_ptr( T * ptr )
        : ptr( ptr ) { }
    ~unique_ptr()
    { <span class="kw">delete</span> ptr ; }

    <span class="co">// コピーは禁止</span>
    unique_ptr( <span class="dt">const</span> unique_ptr &amp; ) = <span class="kw">delete</span> ;
    unique_ptr &amp; <span class="kw">operator</span> =( <span class="dt">const</span> unique_ptr &amp; ) = <span class="kw">delete</span> ;

    <span class="co">// ムーブ</span>
    unique_ptr( unique_ptr &amp;&amp; r )
        : ptr( r.ptr )
    { r.ptr = <span class="kw">nullptr</span> ; }
    unique_ptr &amp; <span class="kw">operator</span> = ( unique_ptr &amp;&amp; r )
    {
        <span class="kw">delete</span> ptr ;
        ptr = r.ptr ;
        r.ptr = <span class="kw">nullptr</span> ;
    }

    T &amp; <span class="kw">operator</span> * () <span class="kw">noexcept</span> { <span class="kw">return</span> *ptr ; }
    T * <span class="kw">operator</span> -&gt;() <span class="kw">noexcept</span> { <span class="kw">return</span> ptr ; } 
    T * get() <span class="kw">noexcept</span> { <span class="kw">return</span> ptr ; }
} ;</code></pre></div>
<p>コンストラクターでポインターを受け取り、デストラクターで破棄する。コピーは禁止。ムーブは所有権を移動。特に解説するまでもなくコードを読むだけでいいほどの単純な実装だ。</p>
<p>現実の<code>unique_ptr</code>はもう少し便利な機能を提供しているので、実装はもう少し複雑になっているが、基本的な実装としては変わらない。</p>
<h2 id="shared_ptr">shared_ptr</h2>
<p><code>unique_ptr</code>は便利だがコピーができない。コピーができないのは<code>unique_ptr</code>がポインターの所有権を排他的に独占するからだ。これはどうにもならないが、コピーしたいものはコピーしたい。</p>
<p>そこで、コピーができるスマートポインターとして<code>shared_ptr</code>がある。</p>
<p><code>unique_ptr&lt;T&gt;</code>は<code>make_unique&lt;T&gt;(...)</code>で作るように、<code>shared_ptr&lt;T&gt;</code>は<code>std::make_shared&lt;T&gt;(...)</code>で作る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> p = std::make_shared&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
}</code></pre></div>
<p><code>unique_ptr</code>と同じようにポインターのように使うことができる。</p>
<p><code>shared_ptr</code>はコピーができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> p1 = std::make_shared&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
<span class="kw">auto</span> p2 = p1 ;
<span class="kw">auto</span> p3 = p1 ;</code></pre></div>
<p>しかも、コピーはすべて同じポインターを持っている。例えば以下のようにすると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">*p3 = <span class="dv">123</span> ;</code></pre></div>
<p><code>*p1, *p2, *p3</code>はいずれも<code>123</code>になる。</p>
<p>これはどれも同じポインターの値を保持しているためだ。<code>p1.get(), p2.get(), p3.get()</code>はすべて同じポインターの値を返す。</p>
<p><code>shared_ptr</code>は本当に何も考えずに気軽にコピーしてもよい。例えば以下のような本当に汚いコードですら動く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::shared_ptr&lt;<span class="dt">int</span>&gt; last_ptr ;

<span class="dt">bool</span> is_equal_to_last_ptr( std::shared_ptr&lt;<span class="dt">int</span>&gt; ptr )
{
    <span class="kw">if</span> ( last_ptr == <span class="kw">nullptr</span> )
        last_ptr = ptr ;

    <span class="dt">bool</span> b = *last_ptr == *ptr ;
    last_ptr = ptr ;
    <span class="kw">return</span> b ; 
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> p1 = std::make_shared&lt;<span class="dt">int</span>&gt;(<span class="dv">1</span>) ;
    <span class="kw">auto</span> p2 = std::make_shared&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>) ;

    <span class="co">// true</span>
    is_equal_to_last_ptr( p1 ) ;
    <span class="co">// false</span>
    is_equal_to_last_ptr( p2 ) ;
    *p2 = <span class="dv">1</span> ;
    <span class="co">// true</span>
    is_equal_to_last_ptr( p1 ) ;
}</code></pre></div>
<p><code>shared_ptr</code>はコピーされたすべての<code>shared_ptr</code>のオブジェクトが同じポインターを共有する。ポインターを所有する最後の<code>shared_ptr</code>のオブジェクトが破棄されたときに、ポインターが<code>delete</code>される。</p>
<p>そのため、<code>shared_ptr</code>を使うときは、ポインターが有効なオブジェクトを指すかどうかを気にしなくてよい。そのポインターを所有する<code>shared_ptr</code>のオブジェクトが1つでも生き残っている限り、ポインターは有効になっている。</p>
<p><code>shared_ptr</code>はどうやって実装されているのだろうか。<code>shared_ptr&lt;T&gt;</code>は<code>T</code>へのポインターのほかに、現在何個の<code>shared_ptr</code>のオブジェクトがポインターを所有しているのかを数えるカウンターへのポインターを持っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> shared_ptr
{
    T * ptr ;
    std::size_t * count ;
} ;</code></pre></div>
<p><code>shared_ptr</code>が初めて作られるとき、このカウンター用にストレージが動的確保され、値が<code>1</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">explicit</span> shared_ptr( T * ptr )
    : ptr( ptr ), count( <span class="kw">new</span> std::size_t(<span class="dv">1</span>) )
{ }</code></pre></div>
<p>コピーされるとき、カウンターがインクリメントされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">shared_ptr( <span class="dt">const</span> shared_ptr &amp; r )
    : ptr( r.ptr ), count( r.count )
{
    ++*count ;
}</code></pre></div>
<p>デストラクターでは、カウンターがデクリメントされる。そしてカウンターがゼロの場合、ポインターが<code>delete</code>される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">~shared_ptr()
{
    <span class="co">// カウンターが妥当なポインターを指しているかどうか確認</span>
    <span class="kw">if</span> ( count == <span class="kw">nullptr</span> )
        <span class="kw">return</span> ;

    <span class="co">// デクリメント</span>
    --*count ;
    <span class="co">// 所有者が0ならば</span>
    <span class="kw">if</span> ( *count == <span class="dv">0</span> )
    {   <span class="co">// 解放する</span>
        <span class="kw">delete</span> ptr ;
        ptr = <span class="kw">nullptr</span> ;
        <span class="kw">delete</span> count ;
        count = <span class="kw">nullptr</span> ;
    }
}</code></pre></div>
<p>全体としては少し長いが、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> shared_ptr
{
    T * ptr = <span class="kw">nullptr</span> ;
    std::size_t * count = <span class="kw">nullptr</span> ;

    <span class="dt">void</span> release()
    {
        <span class="kw">if</span> ( count == <span class="kw">nullptr</span> )
            <span class="kw">return</span> ;

        --*count ;
        <span class="kw">if</span> ( *count == <span class="dv">0</span> )
        {
            <span class="kw">delete</span> ptr ;
            ptr = <span class="kw">nullptr</span> ;
            <span class="kw">delete</span> count ;
            count = <span class="kw">nullptr</span> ;
        }
    }
<span class="kw">public</span> :

    shared_ptr() { }
    <span class="kw">explicit</span> shared_ptr( T * ptr )
        : ptr(ptr), count( <span class="kw">new</span> std::size_t(<span class="dv">1</span>) )
    { }
    ~shared_ptr()
    {
        release() ;
    }

    shared_ptr( <span class="dt">const</span> shared_ptr &amp; r )
        : ptr( r.ptr ), count( r.count )
    {
        ++*count ;
    }
    shared_ptr &amp; <span class="kw">operator</span> =( <span class="dt">const</span> shared_ptr &amp; r )
    {
        <span class="kw">if</span> ( <span class="kw">this</span> == &amp;r )
            <span class="kw">return</span> *<span class="kw">this</span> ;

        release() ;
        ptr = r.ptr ;
        count = r.count ;
        ++*count ;
    }

    shared_ptr( shared_ptr &amp;&amp; r )
        : ptr(r.ptr), count(r.count)
    {
        r.ptr = <span class="kw">nullptr</span> ;
        r.count = <span class="kw">nullptr</span> ;
    }

    shared_ptr &amp; <span class="kw">operator</span> =( shared_ptr &amp;&amp; r )
    {
        release() ;
        ptr = r.ptr ;
        count = r.count ;
        r.ptr = <span class="kw">nullptr</span> ;
        r.count = <span class="kw">nullptr</span> ;
    }

    T &amp; <span class="kw">operator</span> * () <span class="kw">noexcept</span> { <span class="kw">return</span> *ptr ; }
    T * <span class="kw">operator</span> -&gt;() <span class="kw">noexcept</span> { <span class="kw">return</span> ptr ; } 
    T * get() <span class="kw">noexcept</span> { <span class="kw">return</span> ptr ; }
} ;</code></pre></div>
<p>これはとても簡易的な<code>shared_ptr</code>の実装だ。本物の<code>std::shared_ptr</code>はもっと複雑で、もっと高度な機能を提供している。</p>
<h1 id="自作の数値クラスで演算をムーブに対応する方法">自作の数値クラスで演算をムーブに対応する方法</h1>
<p>自作の数値計算をするクラスを実装するとしよう。無限精度整数、ベクトル、行列など、自作のクラスで実装したい数値と演算は世の中にたくさんある。</p>
<p>そのとき、数値の状態を表現するためにストレージを動的確保するとしよう。ここでは例のため、とても簡単な整数型を考える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
    <span class="dt">int</span> * ptr ;
} ;</code></pre></div>
<h2 id="基本の実装">基本の実装</h2>
<p>まずは基本となるコンストラクターとデストラクター、コピー、ムーブを実装しよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Integer
{
    <span class="dt">int</span> * ptr ;
<span class="kw">public</span> :
    <span class="kw">explicit</span> Integer( <span class="dt">int</span> value = <span class="dv">0</span> )
        : ptr ( <span class="kw">new</span> <span class="dt">int</span>(value) ) { }
    ~Integer( )
    { <span class="kw">delete</span> ptr ; } 

    <span class="co">// コピー</span>
    Integer( <span class="dt">const</span> Integer &amp; r )
        : ptr( <span class="kw">new</span> <span class="dt">int</span>( *r.ptr ) ) { }
    Integer &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> Integer &amp; r )
    {
        <span class="kw">if</span> ( <span class="kw">this</span> != &amp;r )
            *ptr = *r.ptr ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }

    <span class="co">// ムーブ</span>
    Integer( Integer &amp;&amp; r )
        : ptr( r.ptr )
    { r.ptr = <span class="kw">nullptr</span> ; }
    Integer <span class="kw">operator</span> =( Integer &amp;&amp; r )
    {
        <span class="kw">delete</span> ptr ;
        ptr = r.ptr ;
        r.ptr = <span class="kw">nullptr</span> ;
        <span class="kw">return</span> *<span class="kw">this</span> ;
    }
} ;</code></pre></div>
<p>コンストラクターは動的確保をする。デストラクターは解放する。コピーは動的確保をする。ムーブは所有権の移動をする。とてもよくあるクラスの実装だ。</p>
<p>実用的には<code>std::unique_ptr&lt;int&gt;</code>を使うべきだが、低級な処理を説明するためにあえて生のポインターを使っている。</p>
<p>今回のコピー代入演算子は単に値をコピーしているが、コピー元とコピー先で確保したストレージのサイズが異なるような型、たとえば無限精度整数や動的なサイズのベクトルや行列などの場合は、コピー代入演算子でもコピー先のストレージを破棄してコピー元と同じサイズのストレージを確保するなどの処理が必要な場合もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 行列クラス</span>
<span class="kw">class</span> matrix
{
    <span class="co">// オブジェクトごとにサイズが異なる</span>
    unique_ptr&lt;<span class="dt">double</span>&gt; ptr ;
    std::size_t rows ;
    std::size_t columns ;
<span class="kw">public</span> :
    <span class="co">// コピー代入演算子</span>
    matrix &amp; <span class="kw">operator</span> = ( <span class="dt">const</span> matrix &amp; r )
    {
        <span class="co">// 自分自身への代入</span>
        <span class="kw">if</span> ( <span class="kw">this</span> == &amp;r )
            <span class="kw">return</span> *<span class="kw">this</span> ;

        <span class="co">// 行列のサイズが同じかどうか確認</span>
        <span class="kw">if</span> ( rows == r.rows &amp;&amp; columns == r.columns )
        {
            <span class="co">// コピー元の行列の値をコピー先にコピー</span>
            <span class="co">// コピー先のストレージはそのまま使える</span>
        }
        <span class="kw">else</span>
        {
            <span class="co">// コピー先のストレージを解放</span>
            <span class="co">// コピー先はコピー元の行列サイズと同じストレージを確保</span>
            <span class="co">// 値をコピー</span>
        }
    }
} ;</code></pre></div>
<h2 id="複合代入演算子">複合代入演算子</h2>
<p>複合代入演算子というのは、<code>operator +=</code>や<code>operator -=</code>のような演算子だ。これはコピー代入演算子と同じように実装できる。違いは代入の結果、演算をするだけだ。</p>
<p>クラス<code>Integer</code>の場合、演算の結果ストレージのサイズが変わるということはないので、愚直な実装で済む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer &amp; <span class="kw">operator</span> +=( <span class="dt">const</span> Integer &amp; r )
{
    *ptr += *r.ptr ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}

Integer &amp; <span class="kw">operator</span> -=( <span class="dt">const</span> Integer &amp; r )
{
    *ptr -= *r.ptr ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<p>複合代入演算子をムーブ代入演算子として実装する理由は、通常はない。</p>
<h2 id="単項演算子-1">単項演算子</h2>
<p>演算を表現するクラスでオーバーロードしたい単項演算子には<code>operator +</code>と<code>operator -</code>がある。特に<code>operator -</code>は実用上の意味があるので実装してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a(<span class="dv">10</span>) ;
<span class="kw">auto</span> b = -a ;
<span class="co">// これは二項演算子 operator +の結果に</span>
<span class="co">// 単項演算子operator -を適用</span>
<span class="kw">auto</span> c = -(a + a) ;</code></pre></div>
<p><code>*this</code>が<code>lvalue</code>の場合の単項演算子の実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer <span class="kw">operator</span> -() <span class="dt">const</span>
{
    Integer result( -*ptr ) ;
    <span class="kw">return</span> result ;
}

<span class="co">// operator +()の実装は省略</span></code></pre></div>
<p>単項演算子<code>operator -</code>は<code>*this</code>を書き換えない。負数にした値のコピーを返す。</p>
<p>変数<code>result</code>は<code>return文</code>のあとは使われないので、<code>return std::move(result)</code> と書くこともできる。しかし、そのように書く必要はない。というのも<code>return文</code>は特別な扱いを受けているので、関数の中の変数を<code>return</code>した場合、自動でムーブが行われるからだ。もちろん、<code>std::move</code>を明示的に書いてもよい。</p>
<p>単項演算子<code>operator -</code>は<code>*this</code>が<code>lvalue</code>のときには上のように実装するしかない。しかしこの実装は非効率的だ。なぜならば、コードを読めばわかるように、追加の一時変数が生成され、追加の動的メモリー確保が行われるからだ。</p>
<p>そのため、もしクラス<code>Integer</code>がコピーしか実装していない場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a ;
<span class="kw">auto</span> b = -a ;</code></pre></div>
<p>というコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a ;
<span class="kw">auto</span> b = a ;
b.make_it_negative() ; </code></pre></div>
<p>のような現在の値をそのまま負数にするメンバー関数<code>make_it_negative</code>を実装して使った方が効率がよくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer 
{
    <span class="dt">int</span> * ptr ;
<span class="kw">public</span> :
    <span class="dt">void</span> make_it_negative()
    {
        *ptr = -*ptr ;
    }
} ;</code></pre></div>
<p>幸い、クラス<code>Integer</code>はムーブコンストラクターを実装しているので、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> b = -a ;</code></pre></div>
<p>というコードは、式<code>-a</code>によって生成された一時オブジェクトが変数<code>b</code>にムーブされる。</p>
<p>しかし、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> c = -(a + a) ;</code></pre></div>
<p>というコードは依然として非効率的になる。まだ二項演算子<code>operator +</code>は実装していないが、これは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> temp1 = a + a ;
<span class="kw">auto</span> temp2 = -temp1 ;
<span class="kw">auto</span> c = temp2 ;</code></pre></div>
<p>になるからだ。すると以下のように書いた方が効率がよくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a ;
<span class="kw">auto</span> c = a ;
c += a ;
c.make_it_negative() ;</code></pre></div>
<p>こんなコードを書くのは面倒だ。単に<code>-(a+a)</code>と書いて効率的に動いてほしい。そのために単項演算子<code>operator -</code>をムーブに対応させる。</p>
<p>単項演算子はクラスのメンバー関数として実装する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
<span class="kw">public</span> ;
    Integer <span class="kw">operator</span> -() <span class="dt">const</span> ;
} ;</code></pre></div>
<p>これが非メンバー関数ならば、単に<code>rvalue</code>リファレンスを取ればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer negate( Integer &amp;&amp; object ) ;</code></pre></div>
<p>メンバー関数の場合、<code>object</code>に相当するのは<code>*this</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
<span class="kw">public</span> :
    <span class="co">// *thisがobjectに相当する</span>
    Integer negate() ;
} ;</code></pre></div>
<p><code>this</code>がポインターになっているのは歴史的な都合で、本来はリファレンスになっているべきだった。メンバー関数は以下のような隠し引数があるものとして考えるとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
<span class="kw">public</span> :
    <span class="co">// 隠し引数</span>
    Integer negate( Integer &amp; THIS )
    {
        Integer * <span class="kw">this</span> = &amp;THIS ;
    }
} ;</code></pre></div>
<p>もちろん、このような隠し引数<code>THIS</code>をC++のプログラムから参照する方法はない。あくまでも参考のためのコードだ。</p>
<p>メンバー関数を<code>const</code>修飾するというのは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer 
{
<span class="kw">public</span> :
    Integer negate() <span class="dt">const</span> ;
} ;</code></pre></div>
<p>この隠し引数を<code>const</code>修飾するのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
<span class="kw">public</span> :
    Integer negate( <span class="dt">const</span> Integer &amp; THIS )
    {
        <span class="dt">const</span> Integer * <span class="kw">this</span> = &amp;THIS ;
        <span class="co">// ...</span>
    }
} ;</code></pre></div>
<p>これによって<code>const</code>修飾の有無でメンバー関数を呼び分けられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">void</span> f() ;
    <span class="dt">void</span> f() <span class="dt">const</span> ; 
} ;

<span class="dt">int</span> main()
{
    X x ;
    x.f() ; <span class="co">// 非const</span>
    <span class="dt">const</span> X &amp; cx = x ;
    cx.f() ; <span class="co">// const</span>
}</code></pre></div>
<p>C++には<code>const</code>修飾と同様に、「リファレンス修飾」という機能がある。これを使えば隠し引数に<code>lvalue</code>/<code>rvalue</code>リファレンスの修飾ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// lvalueリファレンス修飾子</span>
    <span class="dt">void</span> f() &amp; ;
    <span class="co">// rvalueリファレンス修飾子</span>
    <span class="dt">void</span> f() &amp;&amp; ; 
} ;

<span class="dt">int</span> main()
{
    X lvalue ;
    <span class="co">// lvalueリファレンス</span>
    lvalue.f() ;
    <span class="co">// rvalueリファレンス</span>
    std::move(lvalue).f() ;
}</code></pre></div>
<p>これは実質的以下のような隠し引数があるものと考えてよい。もちろん隠し引数を使うことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// lvalueリファレンス</span>
    <span class="dt">void</span> f( X &amp; THIS )
    {
        X * <span class="kw">this</span> = &amp;THIS ;
    }
    <span class="dt">void</span> f( X &amp;&amp; THIS )
    {
        X * <span class="kw">this</span> = &amp;THIS ;
    }
} ;</code></pre></div>
<p><code>void f() &amp;&amp;</code>のメンバー関数の中では、<code>*this</code>は<code>lvalue</code>だ。<code>rvalue</code>リファレンスの変数は<code>lvalue</code>であることを思い出そう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> &amp; ) ;
<span class="dt">void</span> f( <span class="dt">int</span> &amp;&amp; ) ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> lvalue {} ;
    <span class="dt">int</span> &amp;&amp; rvalue = std::move(lvalue) ;
    <span class="co">// int &amp;を呼び出す</span>
    <span class="co">// rvalueリファレンスの変数はlvalue</span>
    f( rvalue ) ;
}</code></pre></div>
<p>クラスでメンバー関数にリファレンス修飾子を書かなかった場合、<code>lvalue</code>リファレンス修飾子を書いたものとみなされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// lvalueリファレンス</span>
    <span class="dt">void</span> f() ;
} ;</code></pre></div>
<p>もしメンバー関数にリファレンス修飾子を書いた場合、同じ名前のすべてのメンバー関数にリファレンス修飾子を書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// エラー、リファレンス修飾子がない</span>
    <span class="dt">void</span> f() ;
    <span class="dt">void</span> f() &amp; ;

    <span class="co">// OK、リファレンス修飾子がある</span>
    <span class="dt">void</span> g() &amp; ;
    <span class="dt">void</span> g() &amp;&amp; ;

    <span class="co">// OK リファレンス修飾子を使っていない</span>
    <span class="co">// デフォルトでlvalueリファレンス修飾子</span>
    <span class="dt">void</span> h() ;
} ;</code></pre></div>
<p>リファレンス修飾子を使い、<code>*this</code>が<code>lvalue</code>と<code>rvalue</code>の場合で実装を分けることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
    <span class="dt">int</span> * ptr ;
<span class="kw">public</span> :
    <span class="co">// lvalue版</span>
    Integer <span class="kw">operator</span> -() <span class="dt">const</span> &amp;
    {
        <span class="kw">auto</span> result = ( -*ptr ) ;
        <span class="kw">return</span> result ;
    }
    <span class="co">// rvalue版</span>
    Integer <span class="kw">operator</span> -() &amp;&amp;
    {
        <span class="kw">auto</span> result = std::move(*<span class="kw">this</span>) ;
        *result.ptr = -*result.ptr ;
        <span class="kw">return</span> result ;
    }
} ;</code></pre></div>
<p><code>rvalue</code>リファレンス修飾子を使った単項演算子<code>operator -</code>の実装は、<code>*this</code>自身が<code>rvalue</code>であるので、自分自身をムーブしている。ムーブ以降、<code>this-&gt;ptr</code>は<code>nullptr</code>になる。なぜならば、<code>Integer</code>のムーブ代入演算子がそのような実装になっているからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">///</span> 上で示したのと同じムーブ代入演算子の抜粋
Integer <span class="kw">operator</span> =( Integer &amp;&amp; r )
{
    <span class="kw">delete</span> ptr ;
    ptr = r.ptr ;
    <span class="co">// ムーブ元のポインターをnullptrにする</span>
    r.ptr = <span class="kw">nullptr</span> ;
    <span class="kw">return</span> *<span class="kw">this</span> ;
}</code></pre></div>
<h2 id="二項演算子-1">二項演算子</h2>
<p>せっかく数値を表現するクラスなのだから二項演算子を使った演算がしたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    Integer a(<span class="dv">1</span>) ;
    Integer b(<span class="dv">2</span>) ;
    Integer c = a + b ;
}</code></pre></div>
<p>これをどうやって実装するのかというと、<code>operator +</code>演算子のオーバーロードで実装する。</p>
<p>演算子のオーバーロードはメンバー関数による方法と、非メンバー関数による方法がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="co">// メンバー関数</span>
    X <span class="kw">operator</span> +( <span class="dt">const</span> X &amp; r ) ;
} ;

<span class="co">// 非メンバー関数</span>
X <span class="kw">operator</span> +( <span class="dt">const</span> X &amp; l, <span class="dt">const</span> X &amp; r ) ;</code></pre></div>
<p><code>operator =</code>のような特殊な演算子以外は、どちらの方法で書いてもいい。メンバー関数として書いた場合、第一引数は<code>*this</code>に、第二引数が関数の引数<code>r</code>になる。</p>
<p>例えば以下のようなコードで、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">X a ;
X b ;
a + b ;</code></pre></div>
<p>メンバー関数の場合、<code>*this</code>は<code>a</code>、<code>r</code>は<code>b</code>になる。</p>
<p>非メンバー関数の場合、<code>l</code>は<code>a</code>は、<code>r</code>は<code>b</code>になる。</p>
<h3 id="ムーブしない実装">ムーブしない実装</h3>
<p>二項演算子のオペランドがどちらも<code>lvalue</code>であった場合はムーブができないので、引数は<code>const</code>な<code>lvalue</code>リファレンスで受け取り、<code>prvalue</code>を返す。</p>
<p>メンバー関数の場合の実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
    <span class="dt">int</span> * ptr ;
<span class="kw">public</span> :
    <span class="co">// 省略...</span>

    Integer <span class="kw">operator</span> +( <span class="dt">const</span> Integer &amp; r ) <span class="dt">const</span>
    { <span class="kw">return</span> Integer( *ptr + *r.ptr ) ; } 
} ;</code></pre></div>
<p>非メンバー関数の場合は、<code>Integer::ptr</code>が<code>private</code>メンバーであることが問題になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; l, <span class="dt">const</span> Integer &amp; r )
{
    <span class="co">// エラー、Integer::ptrはprivateメンバー</span>
    <span class="kw">return</span> Integer( *l.ptr + *r.ptr ) ;
}</code></pre></div>
<p>これを解決するための方法はいくつかある。</p>
<ol style="list-style-type: decimal">
<li>クラスのメンバー関数として処理を実装し、そのメンバー関数を呼び出す方法</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
    <span class="dt">int</span> * ptr ;
<span class="kw">public</span> :
    Integer plus( <span class="dt">const</span> Integer &amp; r ) <span class="dt">const</span>
    { <span class="kw">return</span> Integer( *ptr + r.ptr ) ; }
} ;

Integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; l, <span class="dt">const</span> Integer &amp; r )
{
    <span class="kw">return</span> l.plus( r ) ;
}</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>friend宣言する方法</li>
</ol>
<p>クラスが別のクラスや関数を<code>friend</code>宣言すると、その関数はクラスの<code>private</code>なメンバーを使えるようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> X
{
    <span class="dt">int</span> member ;
    <span class="co">// friend宣言</span>
    <span class="kw">friend</span> <span class="dt">int</span> get_member( <span class="dt">const</span> X &amp; ) ;
} ;

<span class="dt">int</span> get_member( <span class="dt">const</span> X &amp; obj )
{
    <span class="co">// OK、friendなので使える</span>
    <span class="kw">return</span> obj.member ;
}</code></pre></div>
<p>これを使うと、以下のように<code>friend</code>宣言すれば、動かなかった非メンバー関数による<code>operator +</code>のオーバーロードが動くようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
    <span class="kw">friend</span> Integer <span class="kw">operator</span> +( <span class="dt">const</span> Integer &amp;, <span class="dt">const</span> Integer &amp; ) ;
} ;</code></pre></div>
<h3 id="ムーブをしたくなる状況">ムーブをしたくなる状況</h3>
<p>上の二項演算子の実装だけで、クラス<code>Integer</code>は加算ができるようになった。ただし、効率がよくない。</p>
<p>例えば以下のようなコードを考えよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a ;
<span class="kw">auto</span> b = a + a + a ;</code></pre></div>
<p>これはどのように評価されるかというと、<code>a+a+a</code>は、<code>(a+a)+a</code>となり、<code>(a+a)</code>を評価した結果の一時オブジェクトが生成され、その一時オブジェクトを仮に<code>temp</code>と呼ぶと、<code>temp+a</code>される。</p>
<p>結果として、以下のようなコードと同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a ;
<span class="kw">auto</span> temp = a + a ;
<span class="kw">auto</span> b = temp + a ;</code></pre></div>
<p>ムーブを実装していない場合、以下のように書いた方が効率がよくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a ;
<span class="kw">auto</span> b = a ;
b += a ;
b += a ;</code></pre></div>
<p>このようなコードは面倒だ。できれば<code>a + a + a</code>と書きたい。</p>
<p>二項演算子は<code>operator +</code>だけではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> result = a + b - c * d / e ;</code></pre></div>
<p>のようなコードも書きたい。これを効率化のために、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> result = a;
a += b ;
<span class="kw">auto</span> temp = c ;
temp *= d ;
temp /= e ;
result -= temp ;</code></pre></div>
<p>のように書かなければならないとしたら悲惨だ。</p>
<p><code>a+a+a</code>のような式が効率的に動くためには、二項演算子で<code>lvalue</code>/<code>rvalue</code>リファレンスを取り、<code>rvalue</code>リファレンスの場合はムーブするコードを書く。<code>rvalue</code>からは所有権を横取りしてもよいからだ。</p>
<p>二項演算子は引数が2つあり、それぞれに<code>lvalue</code>/<code>rvalue</code>があるので、4通りのオーバーロードを書かなければならない。</p>
<p>非メンバー関数で実装するには、以下のように宣言を書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer 
{
    <span class="kw">friend</span> integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; l, <span class="dt">const</span> Integer &amp; r ) ;
    <span class="kw">friend</span> integer <span class="kw">operator</span> + ( Integer &amp;&amp; l, <span class="dt">const</span> Integer &amp; r ) ;
    <span class="kw">friend</span> integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; l, Integer &amp;&amp; r ) ;
    <span class="kw">friend</span> integer <span class="kw">operator</span> + ( Integer &amp;&amp; l, Integer &amp;&amp; r ) ;
} ;

<span class="co">// lvalue + lvalue</span>
Integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; l, <span class="dt">const</span> Integer &amp; r ) ;
<span class="co">// rvalue + lvalue</span>
Integer <span class="kw">operator</span> + ( Integer &amp;&amp; l, <span class="dt">const</span> Integer &amp; r ) ;
<span class="co">// lvalue + rvalue</span>
Integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; l, Integer &amp;&amp; r ) ;
<span class="co">// rvalue + rvalue</span>
Integer <span class="kw">operator</span> + ( Integer &amp;&amp; l, Integer &amp;&amp; r ) ;</code></pre></div>
<p>具体的な実装としては、まず<code>rvalue</code>リファレンスで束縛したリファレンスを関数のローカル変数にムーブしたあとで、その変数を<code>return</code>する。</p>
<p>第一引数が<code>rvalue</code>の場合は、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer <span class="kw">operator</span> + ( Integer &amp;&amp; l, <span class="dt">const</span> Integer &amp; r )
{
    <span class="kw">auto</span> result = std::move(l) ;
    result += r ;
    <span class="kw">return</span> result ;    
}</code></pre></div>
<p>第一引数は<code>rvalue</code>なので、ムーブしてもよい。</p>
<p>先ほども説明したように、<code>'return文'</code>が関数のローカル変数を返すときは自動でムーブしてくれる。もちろん<code>'return std::move(result)'</code> と書いてもよい。</p>
<p>第二引数が<code>rvalue</code>の場合は、ムーブすべきオブジェクトが第二引数になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; l, Integer &amp;&amp; r )
{
    <span class="kw">auto</span> result = std::move(r) ;
    result += l ;
    <span class="kw">return</span> result ;    
}</code></pre></div>
<p>この実装はすべてに使えるわけではない。加算の場合は、一般に交換法則を満たすことが期待できる。つまり、</p>
<p><span class="math display">\[ a + b = b + a \]</span></p>
<p>であることが期待できるが、除算演算子<code>operator /</code>は交換法則を満たさない。今回の<code>Integer</code>のような簡単な作りのクラスならば実装できるが、クラスの実装と演算次第では第二引数のみが<code>rvalue</code>の場合にはムーブできない場合もあるだろう。そういう場合には実装しなくてもよい。実装できないものは実装しないのが正しい。</p>
<p>第一引数、第二引数のいずれかが<code>rvalue</code>であるときにムーブする演算子のオーバーロードを両方とも実装した場合、両方の引数が<code>rvalue</code>である場合のオーバーロードも実装しなければならない。</p>
<p>第一引数、第二引数が両方共<code>rvalue</code>である場合というのは、例えば以下のような場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer a ;
<span class="kw">auto</span> b = (a + a) + (a + a) ;</code></pre></div>
<p><code>a+a</code>を評価した結果は<code>rvalue</code>だ。この式では<code>rvalue</code>と<code>rvalue</code>を<code>operator +</code>に渡しているので、引数は両方とも<code>rvalue</code>になる。</p>
<p>もし、<code>rvalue + lvalue</code>と<code>lvalue + rvalue</code>に対応する演算子しかオーバーロードしていない場合、関数呼び出しが曖昧になってしまう。そこで、<code>rvalue + rvalue</code>の演算子オーバーロードも書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer <span class="kw">operator</span> +( Integer &amp;&amp; l, Integer &amp;&amp; r )
{
    <span class="kw">return</span> std::move(l) + r ;
} ;</code></pre></div>
<p>この実装は単に<code>rvalue + lvalue</code>の演算子オーバーロードに実際の処理を丸投げしている。変数<code>r</code>はここでは<code>lvalue</code>だ。何度も言うように<code>rvalue</code>を束縛した<code>rvalue</code>リファレンスの変数は<code>lvalue</code>だ。ここでは第一引数をムーブし、第二引数は<code>lvalue</code>として扱っている。</p>
<p>メンバー関数で実装する場合、二項演算子の第一引数は<code>*this</code>、第二引数がメンバー関数の第一引数になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Integer
{
<span class="kw">public</span> :
    <span class="co">// lvalue + lvalue</span>
    Integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; r ) <span class="dt">const</span> &amp; ;
    <span class="co">// rvalue + lvalue</span>
    Integer <span class="kw">operator</span> + ( <span class="dt">const</span> Integer &amp; r ) &amp;&amp; ;
    <span class="co">// lvalue + rvalue</span>
    Integer <span class="kw">operator</span> + ( Integer &amp;&amp; r ) <span class="dt">const</span> &amp; ;
    <span class="co">// rvalue + rvalue</span>
    Integer <span class="kw">operator</span> + ( Integer &amp;&amp; r ) &amp;&amp; ;
} ;</code></pre></div>
<p><code>a + b</code>のとき、<code>*this</code>が<code>a</code>、<code>r</code>が<code>b</code>だ。あとの実装は非メンバー関数の場合と変わらない。</p>
<p>例えばメンバー関数で<code>rvalue + lvalue</code>の実装は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">Integer Integer::<span class="kw">operator</span> +( <span class="dt">const</span> Integer &amp; r ) &amp;&amp;
{
    <span class="kw">auto</span> result = std::move(*<span class="kw">this</span>) ;
    result += r ;
    <span class="kw">return</span> result ;
}</code></pre></div>
<h1 id="文字列-1">文字列</h1>
<h2 id="はじめに">はじめに</h2>
<p>とうとう文字列を学ぶべきときがやってきた。文字列自体は最初から使ってきた。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> s = <span class="st">&quot;hello&quot;</span>s ;</code></pre></div>
<p>これは文字列の表面的な使い方だけだ。しかも、本書ではこれまで文字列に日本語を使ってこなかった。これには理由がある。たとえば、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="st">&quot;こんにちは&quot;</span>s ;
}</code></pre></div>
<p>のようなコードが動くかどうかは実装依存だからだ。試しにコンパイルして実行してみよう。もし画面に「こんにちは」と表示されたのであれば、どうやら読者の環境はこのコードで日本語を出力、表示できるようだ。</p>
<h2 id="基本ソース文字セット">基本ソース文字セット</h2>
<p>C++では、基本ソース文字セットと呼ばれる文字がある。C++のソースコードで安全に使うことができる文字だ。ラテンアルファベットの大文字小文字、記号、制御文字からなる文字セットで、96文字ある。</p>
<p>空白文字、水平タブ、垂直タブ、フォームフィード、改行の5文字と、印字可能な以下の91文字だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
<span class="dv">0</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span> <span class="dv">8</span> <span class="dv">9</span>
_ { } [ ] <span class="er">#</span> ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ~ ! = , \ <span class="st">&quot; &#39;</span></code></pre></div>
<h2 id="基本実行文字セット">基本実行文字セット</h2>
<p>基本実行文字セットは基本ソース文字セットにアラート、バックスペース、キャリッジリターン、null文字を加えたものだ。</p>
<p>null文字は整数の<code>0</code>に等しいという特別な特徴を持つ文字だ。</p>
<h2 id="文字を表現する方法">文字を表現する方法</h2>
<p>文字をコンピューターで扱うには、ビット列で文字を表現できなければならない。C++でアドレス可能な最小単位はバイトなので、文字というのはバイト列で表現する。</p>
<h3 id="ascii">ASCII</h3>
<p>ASCIIはとても広く普及した文字のエンコード方法だ。ASCIIでは7ビットの整数値で1文字を表現する。</p>
<p>C++の基本実行文字セットは特定の文字エンコードであると規定されてはいないが、ASCIIを参考にしている。ただしASCIIには基本実行文字セットにはない、ダラーサイン($)、アットマーク(@)、バッククオート(`)といくつかの制御文字がある。</p>
<h3 id="unicode">Unicode</h3>
<p>Unicode、もしくはISO/IEC 10646(Universal Coded Character Set, UCS)は文字のコードポイントを定める規格だ。</p>
<p>Unicodeは当初、16bitの符号なし整数値でコードポイントを表現する規格であった。この当時、1コードポイントは1文字であり16bitであった。</p>
<p>そのような当初の目論見はすぐに破綻し、いまでは1コードポイントは21bit弱(U+0000からU+10FFFF)であり、1コードポイントは1文字を意味しないようになった。複数のコードポイントを組み合わせて1文字が表現されることもあるからだ。</p>
<p>Unicodeはコードポイントについて定めた規格であり、バイト列で文字を表現する規格ではない。Unicodeを元にしたバイト列によって文字を表現するエンコード方式に、UTF-8, UTF-16, UTF-32が存在する。</p>
<h4 id="utf-16">UTF-16</h4>
<p>UTF-16は16bitの符号なし整数値によってUnicodeのコードポイントを表現するエンコード方式だ。まだUnicodeが16bitのコードポイントですべての文字を表現すると考えていたころに考案されたUCS-2が元になっている。</p>
<p>その後、Unicodeのコードポイントが21bit弱に拡張されたので、UCS-2からUTF-16が考案された。</p>
<p>UTF-16は16bitを1単位とした符号なし整数で21bit弱のコードポイントを表現するために、1単位で表現できないコードポイントを、サロゲートペアと呼ばれる連続した2単位で表現する。</p>
<p>そのため、UTF-16の任意の1単位を切り出すと、それは1つのコードポイントを表現するサロゲートペアの片方である可能性があり、文字として壊れてしまう可能性がある。</p>
<h4 id="utf-32">UTF-32</h4>
<p>UTF-32は32bitの符号なし整数値によってUnicodeのコードポイントを表現するエンコード方式だ。UTF-32の1単位は32bit符号なし整数なので、Unicodeの任意の1コードポイントを表現できる。</p>
<p>ただし問題は、Unicodeではもはや1コードポイントは1文字ではないということだ。したがってUTF-32の1単位は1文字ではない。</p>
<p>UTF-32の1単位は1コードポイントだが、UTF-32の任意の1単位を切り出すことはできない。</p>
<p>連続した複数のコードポイントによって表現された1文字が壊れる可能性があるからだ。</p>
<h4 id="エンディアンの問題">エンディアンの問題</h4>
<p>UTF-16とUTF-32は1単位が複数のバイトからなるエンコード方式だ。複数バイトからなる整数にはエンディアン(Endian)の問題がある。</p>
<p>エンディアンとは複数の連続したバイト列の順序のことだ。</p>
<p>1バイトが8bitの環境で2バイトの符号なし整数を考えよう。C++には16bit符号なし整数型である<code>std::uint16_t</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uint16_t value = <span class="bn">0b00000001&#39;00000010</span> ;</code></pre></div>
<p>2バイトの符号なし整数である<code>value</code>の2つの連続したバイトの上位桁を表現するバイトを上位バイト、下位桁を表現するバイトを下位バイトと呼ぶ。上のコードは上位バイトに1、下位バイトに2が表現されている。このバイト列を直接見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// byte表示用の関数</span>
<span class="dt">void</span> print( std::byte x )
{
    std::cout &lt;&lt; <span class="kw">static_cast</span>&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt;(x) ;
} 

<span class="dt">int</span> main()
{
    <span class="co">// 上位バイトに1</span>
    <span class="co">// 下位バイトに2</span>
    std::uint16_t value = <span class="bn">0b00000001&#39;00000010</span> ;

    <span class="co">// 2バイトの配列</span>
    std::byte rep[<span class="dv">2</span>] ;

    <span class="co">// バイト列をコピー</span>
    std::memcpy( rep, &amp;value, <span class="dv">2</span> ) ;

    <span class="co">// 上位バイト</span>
    print( rep[<span class="dv">0</span>] ) ;
    <span class="co">// 下位バイト</span>
    print( rep[<span class="dv">1</span>] ) ;
}</code></pre></div>
<p>筆者の環境では<code>&quot;21&quot;</code>と表示される。これはつまり、2つのバイトのうち、下位バイトの方が先に配置されているということだ。</p>
<p>世の中にはリトルエンディアン(Little Endian)とビッグエンディアン(Big Endian)がある。これは複数バイトの順序の違いだ。</p>
<p>リトルエンディアンは下位バイトから配置する。</p>
<p>ビッグエンディアンは上位バイトから配置する。</p>
<p>リトルエンディアン環境では、上のプログラムは<code>&quot;21&quot;</code>と表示する。ビッグエンディアン環境では、<code>&quot;12&quot;</code>と表示する。</p>
<p>エンディアンの存在により、UTF-16とUTF-32は2つのバイト列表現が存在することになる。</p>
<h4 id="utf-8">UTF-8</h4>
<p>UTF-8は最も後発のUnicodeのコードポイントの文字エンコードだ。</p>
<p>UTF-8は8bitを1単位とし、1単位から4単位までの連続した単位列によってUnicodeの1コードポイントを表現する。</p>
<p>UTF-8が1単位だけでコードポイントを表現するとき、下位7bitはASCIIの文字の値に等しい。その点でUTF-8はASCIIと互換性がある。</p>
<p>これにより従来ASCIIを使っていたコードやシステムとの親和性が高く、普及した。</p>
<p>UTF-8は現在最も普及している文字コードだ。</p>
<h2 id="os">OS</h2>
<p>C++プログラムが実行できるOSとしては以下のようなものがある。</p>
<ul>
<li>GNU/Linux</li>
<li>Android</li>
<li>FreeBSD</li>
<li>DragonflyBSD</li>
<li>OpenBSD</li>
<li>NetBSD</li>
<li>Apple macOS</li>
<li>Apple iOS</li>
<li>Microsoft Windows</li>
</ul>
<p>このほかにもOSはさまざまあるが、情報を得るだけでもNDAを結ぶ必要がある表に出てこないOSであったり、実験的すぎたりして、C++を学習する環境としては不適切だ。</p>
<p>このうち、Microsoft Windowsを除くOSはUTF-8を使用している。</p>
<p>Microsoft WindowsはUTF-16を使用している。ただし、この状況はMicrosoft Windowsは最近UTF-8ロケールを実装したので将来的に変わるだろう。</p>
<h2 id="リテラル">リテラル</h2>
<h3 id="通常の文字リテラル">通常の文字リテラル</h3>
<p>通常の文字リテラルは単一引用符で1つの文字を囲む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&#39;a&#39;</span>
<span class="st">&#39;b&#39;</span>
<span class="st">&#39;c&#39;</span></code></pre></div>
<p>通常の文字リテラルの型は<code>char</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> a = <span class="st">&#39;a&#39;</span> ;
<span class="dt">char</span> b = <span class="st">&#39;b&#39;</span> ;
<span class="dt">char</span> c = <span class="st">&#39;c&#39;</span> ;</code></pre></div>
<p>文字リテラルには以下のようなエスケープシーケンスがある。これは一部の印字不可能な文字や、文法上の理由で直接リテラルの中に書くことができない文字を書けるようにするための代替手段だ。</p>
<table>
<thead>
<tr class="header">
<th align="left">意味</th>
<th align="left">リテラル</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">改行</td>
<td align="left"><code>\n</code></td>
</tr>
<tr class="even">
<td align="left">水平タブ</td>
<td align="left"><code>\t</code></td>
</tr>
<tr class="odd">
<td align="left">垂直タブ</td>
<td align="left"><code>\v</code></td>
</tr>
<tr class="even">
<td align="left">バックスペース</td>
<td align="left"><code>\b</code></td>
</tr>
<tr class="odd">
<td align="left">キャリッジリターン</td>
<td align="left"><code>\r</code></td>
</tr>
<tr class="even">
<td align="left">フォームフィード</td>
<td align="left"><code>\f</code></td>
</tr>
<tr class="odd">
<td align="left">アラート</td>
<td align="left"><code>\a</code></td>
</tr>
<tr class="even">
<td align="left">バックスラッシュ</td>
<td align="left"><code>\\</code></td>
</tr>
<tr class="odd">
<td align="left">疑問符</td>
<td align="left"><code>\?</code></td>
</tr>
<tr class="even">
<td align="left">単一引用符</td>
<td align="left"><code>\'</code></td>
</tr>
<tr class="odd">
<td align="left">二重引用符</td>
<td align="left"><code>\&quot;</code></td>
</tr>
</tbody>
</table>
<p>これを使えば、単一引用符の文字リテラルは</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> c = <span class="st">&#39;</span><span class="ch">\&#39;</span><span class="st">&#39;</span> ;</code></pre></div>
<p>と書ける。エスケープシーケンスにはバックスラッシュを使うため、文字リテラルのなかでバックスラッシュを使うには、エスケープシーケンスが必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> c = <span class="st">&#39;</span><span class="ch">\\</span><span class="st">&#39;</span> ;</code></pre></div>
<p>通常の文字がどのような文字エンコードを使っているかは実装定義だ。</p>
<p>そのほかにも文字の数値を直接指定するエスケープシーケンスとして、8進数エスケープシーケンスと16進数エスケープシーケンスがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> oct = <span class="st">&#39;</span><span class="ch">\101</span><span class="st">&#39;</span> ;
<span class="dt">char</span> hex = <span class="st">&#39;</span><span class="ch">\x41</span><span class="st">&#39;</span> ;</code></pre></div>
<p>このコードは、8進数で<code>101</code>、16進数で<code>41</code>になる何らかの文字を表現している。もし通常の文字リテラルがASCIIかUTF-8でエンコードされている場合、この文字は<code>A</code>になる。</p>
<h3 id="ユニバーサルキャラクター名">ユニバーサルキャラクター名</h3>
<p>文字リテラルには特殊なエスケープシーケンスであるユニバーサルキャラクター名(Universal Character name)を使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">\uNNNN
\UNNNNNNNNN</code></pre></div>
<p>文法は<code>\u</code>に続いて16進数を4文字書くとこれはUnicodeコードポイントにおける<code>U+0000NNNN</code>になる。<code>\U</code>に続いて16進数を8文字書くと、これはUnicodeコードポイントにおける<code>U+NNNNNNNN</code>になる。</p>
<h3 id="通常の文字列リテラル">通常の文字列リテラル</h3>
<p>通常の文字列リテラルは二重引用符で文字列を囲む。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;abc&quot;</span> ;
<span class="st">&quot;hello&quot;</span> ;
<span class="st">&quot;This is a pen.&quot;</span> ;</code></pre></div>
<p>通常の文字列リテラルの型は<code>const</code>な文字型の配列になる。具体的な型としては<code>const char [n]</code>になる。<code>n</code>は文字列のサイズだ。通常の文字列リテラルの中の文字が基本実行文字だけであれば、書かれている文字数+1になる。しかし、この文字数というのも難しい。</p>
<p>文字列リテラルが連続している場合、1つにまとめられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> s = <span class="st">&quot;abc&quot;</span> <span class="st">&quot;def&quot;</span> ;</code></pre></div>
<p>というコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> s = <span class="st">&quot;abcdef&quot;</span> ;</code></pre></div>
<p>と書くのと同じだ。</p>
<p>文字列リテラルの中のエスケープシーケンスは対応する文字になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span> ;</code></pre></div>
<p>という通常の文字列リテラルは、バックスラッシュとラテンアルファベットnではなく、改行文字1文字になる。</p>
<p>通常の文字列リテラルは末尾にnull文字(<code>\0</code>)が付与される。このために、配列のサイズは文字数+1になる。</p>
<p>具体的な例では、<code>&quot;abc&quot;</code>という通常の文字列リテラルの型は<code>const char [4]</code>になる。これは以下のような配列に等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> s[<span class="dv">4</span>] = {<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>} ;</code></pre></div>
<p><code>&quot;hello&quot;</code>の型は<code>const char [6]</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> s[<span class="dv">6</span>] = {<span class="st">&#39;h&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> } ;</code></pre></div>
<p><code>char</code>型の配列の初期化に通常の文字列リテラルを使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> s[<span class="dv">6</span>] = <span class="st">&quot;hello&quot;</span> ;</code></pre></div>
<p>配列の添字を書かない場合、文字列リテラルのサイズになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// char [6]</span>
<span class="dt">char</span> s[] = <span class="st">&quot;hello&quot;</span> ;</code></pre></div>
<p>また、文字列リテラルは配列であるので、先頭要素へのポインターに暗黙に型変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> * p = <span class="st">&quot;hello&quot;</span> ;</code></pre></div>
<p>文字列リテラルを<code>auto</code>で変数の初期化子に書くと、型はポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// const char *</span>
<span class="kw">auto</span> pointer = <span class="st">&quot;hello&quot;</span> ;</code></pre></div>
<p><code>decltype(auto)</code>という<code>auto</code>と似ているがあまり暗黙の型変換を行わない別のキーワードを使うと、配列へのリファレンス型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// const char (&amp;) [6]</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) reference = <span class="st">&quot;hello&quot;</span> ;</code></pre></div>
<h2 id="ワイド文字">ワイド文字</h2>
<p>ワイド文字リテラルとワイド文字列リテラルはリテラルにエンコードプレフィクス<code>L</code>を付ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ワイド文字リテラル</span>
<span class="st">L&#39;A&#39;</span> ;
<span class="co">// ワイド文字列リテラル</span>
<span class="st">L&quot;hello&quot;</span> ;</code></pre></div>
<p>ワイド文字リテラルの型は<code>wchar_t</code>、ワイド文字列リテラルの型は<code>const wchar_t [n]</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">wchar_t</span> c = <span class="st">L&#39;A&#39;</span> ;
<span class="dt">const</span> <span class="dt">wchar_t</span> (&amp;ref)[<span class="dv">6</span>] = <span class="st">L&quot;hello&quot;</span> ;</code></pre></div>
<p>ワイド文字は失敗した機能だ。まだUnicodeが16bitで世界中の文字を表現できるという妄想にとらわれていたころに提案された時代遅れの実装不可能な機能だ。</p>
<p>C++の規格では、「ワイド文字は<code>wchar_t</code>型のオブジェクト1つがシステムがサポートする任意の1文字を表現可能である」と規定している。そのような文字エンコード方式はいまだかつて存在していない。Unicodeの1コードポイントは1文字を意味しないので、UTF-32を使ってもワイド文字の規定を満たすことはできない。そのため、現在規格準拠の方法でワイド文字を実装しているC++コンパイラーは存在しない。</p>
<p>Microsoft Windowsはワイド文字をUTF-16で表現している。それ以外の主要なOSはUTF-32を使っている。</p>
<h2 id="utf-8utf-16utf-32">UTF-8/UTF-16/UTF-32</h2>
<p>UTF-8の文字型は<code>char8_t</code>でエンコードプレフィクスは<code>u8</code>。</p>
<p>UTF-16の文字型は<code>char16_t</code>でエンコードプレフィクスは<code>u</code>。</p>
<p>UTF-32の文字型は<code>char32_t</code>でエンコードプレフィクスは<code>U</code>。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">char8_t  utf8   = u8<span class="st">&#39;a&#39;</span> ;
<span class="dt">char16_t</span> utf16  = <span class="st">u&#39;あ&#39;</span> ;
<span class="dt">char32_t</span> utf32  = <span class="st">U&#39;あ&#39;</span> ;</code></pre></div>
<p>UTF-8文字型である<code>char8_t</code>はUTF-8の1単位なので、UTF-8の1単位で表現できる文字しか表現できない。</p>
<p>UTF-8/UTF-16/UTF-32の文字列リテラルは、それぞれの<code>const</code>な文字型の配列になる。エンコードプレフィクスは文字リテラルと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// char8_t [6]</span>
char8_t s1[] = <span class="st">u8&quot;hello&quot;</span> ;
<span class="co">// char16_t [6]</span>
<span class="dt">char16_t</span> s2[] = <span class="st">u&quot;hello&quot;</span> ;
<span class="co">// char32_t [6]</span>
<span class="dt">char32_t</span> s3[] = <span class="st">U&quot;hello&quot;</span> ;</code></pre></div>
<p><code>&quot;いろは&quot;</code>をそれぞれの文字列リテラルで表現すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// char8_t [10]</span>
char8_t s1[] = <span class="st">u8&quot;いろは&quot;</span> ;
<span class="co">// char16_t [4]</span>
<span class="dt">char16_t</span> s2[] = <span class="st">u&quot;いろは&quot;</span> ;
<span class="co">// char32_t [4]</span>
<span class="dt">char32_t</span> s3[] = <span class="st">U&quot;いろは&quot;</span> ;</code></pre></div>
<p>これは以下のように書くのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">char8_t s1[<span class="dv">10</span>] = { <span class="bn">0xe3</span>, <span class="bn">0x81</span>, <span class="bn">0x84</span>, <span class="bn">0xe3</span>, <span class="bn">0x82</span>, <span class="bn">0x8d</span>, <span class="bn">0xe3</span>, <span class="bn">0x81</span>, <span class="bn">0xaf</span>, <span class="bn">0x0</span> } ;
<span class="dt">char16_t</span> s2[<span class="dv">4</span>] = { <span class="bn">0x3044</span>, <span class="bn">0x308d</span>, <span class="bn">0x306f</span>, <span class="bn">0x0</span> } ;
<span class="dt">char32_t</span> s3[<span class="dv">4</span>] = { <span class="bn">0x3044</span>, <span class="bn">0x308d</span>, <span class="bn">0x306f</span>, <span class="bn">0x0</span> } ;</code></pre></div>
<p>文字<code>'い'</code>のUnicodeコードポイントは<code>U+3044</code>で、これはUTF-16/UTF-32では1単位で表現できるが、UTF-8では3単位で<code>0xe3, 0x81, 0x84</code>のように表現する。</p>
<p>臼(うす U+81FC)の別字である𦥑(うす U+26951)のコードポイントは16bit符号なし整数で表現できないので、UTF-16ではサロゲートペアを使って2単位表現される。UTF-8では4単位を使って表現される。</p>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">char8_t  s1[] = <span class="st">u8&quot;𦥑&quot;</span> ;
<span class="dt">char16_t</span> s2[] = <span class="st">u&quot;𦥑&quot;</span> ;
<span class="dt">char32_t</span> s3[] = <span class="st">U&quot;𦥑&quot;</span> ;</code></pre></div>
<p>以下のように解釈される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">char8_t s1[<span class="dv">5</span>] = { <span class="bn">0xf0</span>, <span class="bn">0xa6</span>, <span class="bn">0xa5</span>, <span class="bn">0x91</span>, <span class="bn">0x0</span> } ;
<span class="dt">char16_t</span> s2[<span class="dv">2</span>] = { <span class="bn">0xd85a</span>, <span class="bn">0xdd51</span>, <span class="bn">0x0</span> } ;
<span class="dt">char32_t</span> s3[<span class="dv">2</span>] = { <span class="bn">0x26951</span>, <span class="bn">0x0</span> } ;</code></pre></div>
<p>文字<code>'が'</code>はUnicodeコードポイントでは結合済みコードポイントの<code>U+304C</code>で表現できるが、コードポイントU+304B(HIRAGANA LETTER KA)のあとに直ちに続いて、コードポイントU+3099(COMBINING KATAKANA-HIRAGANA VOICED SOUND MARK)を使って表現してもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// u8&quot;\u304C&quot;</span>
char8_t ga1[] = <span class="st">u8&quot;が&quot;</span> ;
<span class="co">// u8&quot;\u304B\u3099&quot;</span>
char8_t ga2[] = <span class="st">u8&quot;か</span><span class="ch">\u3099</span><span class="st">&quot;</span> ;</code></pre></div>
<p>これは以下のコードと等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">char8_t ga1[<span class="dv">4</span>] = { <span class="bn">0xe3</span>, <span class="bn">0x81</span>, <span class="bn">0x8c</span>, <span class="bn">0x0</span> } ;
char8_t ga2[<span class="dv">7</span>] = { <span class="bn">0xe3</span>, <span class="bn">0x81</span>, <span class="bn">0x8b</span>, <span class="bn">0xe3</span>, <span class="bn">0x82</span>, <span class="bn">0x99</span>, <span class="bn">0x0</span> } ;</code></pre></div>
<p>変数<code>ga1, ga2</code>はどちらもUnicodeとして正しい「が」という1文字の表現だ。Unicodeでは複数のコードポイントで1文字を表現することもあるし、意味的に表示的に同じ文字に対して複数の表現方法がある。</p>
<p>Apple macOSはUnicodeの正規化として一般的なNFC(Canonical Composition)ではなくNormalization Form D(NFD)を使っているので、濁点や半濁点は必ず分解される。Apple macOSでは<code>u8&quot;\u304B\u3099&quot;</code>が一般的な表現で、それ以外の環境では<code>u8&quot;\u304C&quot;</code>が一般的な表現だ。しかし、どちらも意味上は同じ表現だ。</p>
<p>Unicodeの奇妙で面白い例は枚挙に暇がない。ここでは日本語を扱う際によくある注意点を説明したが、ほかにも絵文字、デーヴァナーガリー（ヒンディー語、マラーティー語、ネパール語）、モンゴル文字、アラビア文字、ヘブライ文字など扱いの難しい文字がたくさんある。</p>
<p>重要な点をまとめると、</p>
<ul>
<li>文字型の1つのオブジェクトは1文字ではない</li>
<li>1コードポイントは1文字ではない</li>
</ul>
<h2 id="生文字列リテラル">生文字列リテラル</h2>
<p>エスケープシーケンスは文法上の理由で直接ソースコード上に記述することができない文字を文字リテラルと文字列リテラルに記述できる機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">u8&quot;</span><span class="ch">\n</span><span class="st">は改行文字&quot;</span> ;</code></pre></div>
<p>しかしエスケープシーケンスがあるために、バックスラッシュを普通に使うには、<code>\\</code>と書かなければならない。例えば上の文字列リテラルを改行文字に続いて「は改行文字」ではなく、本当に「<code>\n</code>は改行文字」という文字列にしたい場合、以下のように書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">u8&quot;</span><span class="ch">\\</span><span class="st">nは改行文字&quot;</span> ;</code></pre></div>
<p>また、単一引用符<code>'</code>や二重引用符<code>&quot;</code>もエスケープシーケンスが必要だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">u8&quot;</span><span class="ch">\&#39;</span><span class="st">は単一引用符&quot;</span> ;
<span class="st">u8&quot;</span><span class="ch">\&quot;</span><span class="st">は二重引用符&quot;</span> ;</code></pre></div>
<p>また、以下のような内容の文字列をリテラルとして書きたい場合、</p>
<pre><code>foo
bar
baz</code></pre>
<p>以下のように書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;foo</span><span class="ch">\n</span><span class="st">bar</span><span class="ch">\n</span><span class="st">baz&quot;</span> ;</code></pre></div>
<p>このようなわかりにくい記述ではなく、ソースコードに書いたままの文字列を文字列として扱いたい。そのための機能が生文字列リテラル(Raw String Literal)だ。</p>
<p>生文字列リテラルは以下のような文法で書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">R&quot;(...)&quot;</span></code></pre></div>
<p>例えば以下のように書くと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">R&quot;(foo</span>
<span class="st">bar</span>
<span class="st">baz)&quot; ;</span></code></pre></div>
<p>以下のような文字列リテラルと同じ意味になる。</p>
<pre><code>&quot;foo\nbar\nbaz&quot; ;</code></pre>
<p>エスケープシーケンスも書いたままに文字列となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">R&quot;(</span>
<span class="st">&#39;は単一引用符</span>
<span class="st">&quot;は二重引用符</span>
<span class="st">\nは改行文字</span>
<span class="st">)&quot; ;</span></code></pre></div>
<p>これは以下の文字列リテラルと同じ意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;</span><span class="ch">\n\&#39;</span><span class="st">は単一引用符</span><span class="ch">\n\&quot;</span><span class="st">は二重引用符</span><span class="ch">\n\\</span><span class="st">nは改行文字</span><span class="ch">\n</span><span class="st">&quot;</span></code></pre></div>
<h2 id="文字列の表現方法">文字列の表現方法</h2>
<p>文字列というのは文字型の配列で表現される。文字列を表現するには、配列の先頭へのポインターと配列のサイズが必要になる。</p>
<h3 id="null終端文字列">null終端文字列</h3>
<p>C++の文字列リテラルは、末尾にnull文字が付与された<code>const</code>な文字型への配列だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;abc&quot;</span> ;</code></pre></div>
<p>という文字列リテラルは型とその値としては</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> st[<span class="dv">4</span>] = { <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> } ;</code></pre></div>
<p>になる。</p>
<p>null終端文字列とはC言語から使われている文字列の表現方法だ。文字型の配列の末尾にnull文字を番兵として配置することで文字列の終端を表現している。C言語では文字列は文字型へのポインターとして表現される。ポインターが指す配列のサイズはわからないが、妥当な文字列はnull終端されているので、ポインターをインクリメントしていけばいずれnull文字が現れる。そこが文字列の終わりだ。これによって文字列のサイズもわかる。</p>
<p>例えば、以下はC言語でよく書かれる典型的文字列を処理する関数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> process_string( <span class="dt">const</span> <span class="dt">char</span> * str )
{
    <span class="co">// strが指す配列のサイズを取得</span>
    <span class="kw">auto</span> str_size = std:strlen( str ) ;
    <span class="co">// 残りの処理</span>
}</code></pre></div>
<p><code>std::strlen</code>はポインターが指し示すnull終端された配列のnull文字を除くサイズを返す。以下のような実装だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::size_t strlen( <span class="dt">const</span> <span class="dt">char</span> * s )
{
    <span class="kw">auto</span> i = s ;
    <span class="kw">while</span> ( *i != <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> )
    { ++i ; }
    <span class="kw">return</span> i - s ;
} </code></pre></div>
<p>ここで言う「文字列のサイズ」とは、ポインターが指し示す文字型の配列の要素数であって、文字数ではない。</p>
<p>null終端文字列は文字型へのポインター1つだけなので取り回しがよい。ただし、文字列のサイズは実行時に文字列の先頭から末尾までイテレートして計算しなければならない。これは文字列の長さに比例したオーダー<span class="math inline">\(O(N)\)</span>の処理量がかかる。</p>
<h3 id="stdbasic_string">std::basic_string<CharT></h3>
<p>いままで文字列の型として使ってきた<code>std::string</code>は、実はクラステンプレートで実装されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">template</span>&lt;
        <span class="kw">typename</span> charT,
        <span class="kw">typename</span> traits = char_traits&lt;charT&gt;,
        <span class="kw">typename</span> Allocator = allocator&lt;charT&gt;
    &gt;
    <span class="kw">class</span> basic_string ;
}</code></pre></div>
<p>テンプレートパラメーターのうち、<code>charT</code>が文字型、<code>traits</code>は文字を処理するための補助的なライブラリ、<code>Allocator</code>がアロケーターだ。</p>
<p>これに対し、以下のようなエイリアスが存在する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">using</span> string    = basic_string&lt;<span class="dt">char</span>&gt; ;
    <span class="kw">using</span> u8string  = basic_string&lt;char8_t&gt; ;
    <span class="kw">using</span> u16string = basic_string&lt;<span class="dt">char16_t</span>&gt; ;
    <span class="kw">using</span> u32string = basic_string&lt;<span class="dt">char32_t</span>&gt; ;  
    <span class="kw">using</span> wstring   = basic_string&lt;<span class="dt">wchar_t</span>&gt; ;
}</code></pre></div>
<p>それぞれの文字型に対応した<code>basic_string</code>のクラスだ。</p>
<p>これに対して、ユーザー定義リテラルという機能を使い、文字列リテラルのサフィックスに<code>s</code>を付けることで、文字列リテラルを対応する<code>basic_string</code>のクラス型に変換できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// string</span>
<span class="kw">auto</span> str    = <span class="st">&quot;hello&quot;</span>s ;
<span class="co">// u8string</span>
<span class="kw">auto</span> u8str  = <span class="st">u8&quot;hello&quot;</span>s ;
<span class="co">// u16string</span>
<span class="kw">auto</span> u16str = <span class="st">u&quot;hello&quot;</span>s ;
<span class="co">// u32string</span>
<span class="kw">auto</span> u32str = <span class="st">U&quot;hello&quot;</span>s ;
<span class="co">// wstring</span>
<span class="kw">auto</span> wstr   = <span class="st">L&quot;hello&quot;</span>s ;</code></pre></div>
<p>ユーザー定義リテラルの詳細については本書では詳しく説明しないが、演算子のオーバーロードと同じだ。演算子をオーバーロードするようにリテラル演算子をオーバーロードする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::string <span class="kw">operator</span> <span class="st">&quot;&quot;</span>s( <span class="dt">const</span> <span class="dt">char</span> * ptr, std::size_t n )
{ <span class="kw">return</span> std::string( ptr, n ) ; }
std::u8string <span class="kw">operator</span> <span class="st">&quot;&quot;</span>s( <span class="dt">const</span> char8_t * ptr, std::size_t n )
{ <span class="kw">return</span> std::u8string( ptr, n ) ; }
std::u16string <span class="kw">operator</span> <span class="st">&quot;&quot;</span>s( <span class="dt">const</span> <span class="dt">char16_t</span> * ptr, std::size_t n )
{ <span class="kw">return</span> std::u16string( ptr, n ) ; }
std::u32string <span class="kw">operator</span> <span class="st">&quot;&quot;</span>s( <span class="dt">const</span> <span class="dt">char32_t</span> * ptr, std::size_t n )
{ <span class="kw">return</span> std::u32string( ptr, n ) ; }
std::wstring <span class="kw">operator</span> <span class="st">&quot;&quot;</span>s( <span class="dt">const</span> <span class="dt">wchar_t</span> * ptr, std::size_t n )
{ <span class="kw">return</span> std::wstring( ptr, n ) ; }</code></pre></div>
<p>ユーザー定義リテラルを正しく実装するには複雑なルールがある。例えばユーザー定義のサフィックス名はアンダースコア1つから始まっていなければならないなどだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK</span>
<span class="dt">int</span> <span class="kw">operator</span> <span class="st">&quot;&quot;</span> _abc( <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> ) ;
<span class="co">// エラー、アンダースコア1つから始まっていない</span>
<span class="dt">int</span> <span class="kw">operator</span> <span class="st">&quot;&quot;</span>abc( <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> ) ;</code></pre></div>
<p>これは将来の拡張のためにアンダースコアから始まらないサフィックス名をC++規格が予約しているためだ。</p>
<p><code>basic_string</code>による文字列の表現方法は、文字型配列の先頭要素へのポインター、文字型配列のサイズ、アロケーターだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;
    <span class="kw">typename</span> charT,
    <span class="kw">typename</span> traits = char_traits&lt;charT&gt;,
    <span class="kw">typename</span> Allocator = allocator&lt;charT&gt;
&gt;
<span class="kw">class</span> basic_string
{
    charT * ptr ;
    std::size_t size ;
    Allocator alloc ;
} ;</code></pre></div>
<p>あるいは、配列のサイズを表現するために、配列の最後の要素の1つ次のポインターを使っているかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    charT * ptr ;
    charT * last ;
    Allocator alloc ;</code></pre></div>
<p><code>std::vector</code>と同じで、どちらの方が効率がいいかはアーキテクチャにより異なる。</p>
<p><code>basic_string</code>は文字列を表現するためのストレージを所有するクラスだ。コンストラクターでストレージを動的確保し、デストラクターで解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 少なくともchar [5]を格納できるだけのストレージを動的確保する</span>
    std::string hello(<span class="st">&quot;hello&quot;</span>) ;
    <span class="co">// helloが破棄される</span>
    <span class="co">// デストラクターはストレージを解放する</span>
}</code></pre></div>
<p>コピーはストレージの動的確保、ムーブはストレージの所有権の移動になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::string s1 = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// コピー、動的確保</span>
    std::string s2 = s1 ;
    <span class="co">// ムーブ、所有権の移動</span>
    std::string s3 = std::move(s1) ;
}</code></pre></div>
<h3 id="stdbasic_string_view">std::basic_string_view<CharT></h3>
<p><code>basic_string_view</code>はストレージを所有しないクラスだ。以下のような宣言になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">template</span> &lt;
        <span class="kw">typename</span> charT,
        <span class="kw">typename</span> traits = char_traits&lt;charT&gt;
    &gt;
    <span class="kw">class</span> basic_string_view ;
}</code></pre></div>
<p>その実装は文字型へのポインター2つか、文字型へのポインター1つと配列のサイズを保持する整数型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    charT * first ;
    charT * last ;</code></pre></div>
<p>もしくは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">    charT * first ;
    std::size_t size ;</code></pre></div>
<p><code>basic_string_view</code>には<code>basic_string</code>と対になる各文字型に対する特殊化がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">using</span> string_view    = basic_string_view&lt;<span class="dt">char</span>&gt; ;
    <span class="kw">using</span> u8string_view  = basic_string_view&lt;char8_t&gt; ;
    <span class="kw">using</span> u16string_view = basic_string_view&lt;<span class="dt">char16_t</span>&gt; ;
    <span class="kw">using</span> u32string_view = basic_string_view&lt;<span class="dt">char32_t</span>&gt; ;  
    <span class="kw">using</span> wstring_view   = basic_string_view&lt;<span class="dt">wchar_t</span>&gt; ;
}</code></pre></div>
<p>さらに、各<code>basic_string</code>に対するユーザー定義リテラルサフィックス<code>sv</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// string_view</span>
<span class="kw">auto</span> str    = <span class="st">&quot;hello&quot;</span>sv ;
<span class="co">// u8string_view</span>
<span class="kw">auto</span> u8str  = <span class="st">u8&quot;hello&quot;</span>sv ;
<span class="co">// u16string_view</span>
<span class="kw">auto</span> u16str = <span class="st">u&quot;hello&quot;</span>sv ;
<span class="co">// u32string_view</span>
<span class="kw">auto</span> u32str = <span class="st">U&quot;hello&quot;</span>sv ;
<span class="co">// wstring_view</span>
<span class="kw">auto</span> wstr   = <span class="st">L&quot;hello&quot;</span>sv ;</code></pre></div>
<p><code>basic_string_view</code>は文字列がnull終端文字列と<code>basic_string</code>のどちらで表現されていても問題なく受け取るためのクラスだ。この2つの文字列の表現を別々に使う場合、文字列を受け取る関数は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> process_string( <span class="dt">const</span> <span class="dt">char</span> * s )
{
    <span class="co">// 文字列に対する処理</span>
}

<span class="dt">void</span> process_string( <span class="dt">const</span> std::string &amp; s )
{
    <span class="co">// 文字列に対する上と同じ処理</span>
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> null_terminated_string = <span class="st">&quot;hello&quot;</span> ;
    <span class="kw">auto</span> basic_string = <span class="st">&quot;hello&quot;</span>s ;

    <span class="co">// const char *</span>
    process_string( null_terminated_string ) ;
    <span class="co">// const std::string &amp;</span>
    process_string( basic_string ) ;
}</code></pre></div>
<p>のようにほとんど同じ関数を2つ書かなければならない。<code>basic_string_view</code>を使えば、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> process_string( std::string_view s )
{
    <span class="co">// 文字列に対する処理</span>
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> null_terminated_string = <span class="st">&quot;hello&quot;</span> ;
    <span class="kw">auto</span> basic_string = <span class="st">&quot;hello&quot;</span>s ;

    <span class="co">// どちらも同じ関数を呼ぶ</span>
    process_string( null_terminated_string ) ;
    process_string( basic_string ) ;
}</code></pre></div>
<p>のように、どちらの文字列表現を使っても1つの関数を書くだけで済む。</p>
<p><code>basic_string_view</code>はストレージを所有しないので関数の引数として使うときはリファレンスで取る必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// リファレンスで取る必要はない</span>
<span class="dt">void</span> f( <span class="dt">const</span> std::string_view &amp; ref ) 
<span class="co">// これでいい</span>
<span class="dt">void</span> g( std::string_view obj ) ;</code></pre></div>
<h2 id="文字列の操作">文字列の操作</h2>
<h3 id="null終端文字列の操作">null終端文字列の操作</h3>
<p>null終端文字列は文字列の先頭となる文字型へのポインター型のオブジェクト1つで表現されるので、文字型の配列のサイズを取得するにも、いちいちnull文字が見つかるまでポインターをインクリメントしていく必要がある。この処理をやってくれるのが<code>std::strlen</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">const</span> <span class="dt">char</span> * ptr )
{
    <span class="kw">auto</span> size = std::strlen( ptr ) ;
}</code></pre></div>
<p>文字列リテラルの型は<code>const</code>な文字型の配列なので、文字列を変更することができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> * ptr = <span class="st">&quot;abc&quot;</span> ;
<span class="co">// エラー</span>
ptr[<span class="dv">0</span>] = <span class="st">&#39;x&#39;</span> ;</code></pre></div>
<p>文字型への配列ならば変更できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">char</span> s[] = <span class="st">&quot;abc&quot;</span> ;
    s[<span class="dv">0</span>] = <span class="st">&#39;x&#39;</span> ;
    <span class="co">// sは{&#39;x&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;}</span>
}</code></pre></div>
<p>文字の長さを短くしたい場合は、終端をnull文字にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">char</span> s[] = <span class="st">&quot;abc&quot;</span> ;
    s[<span class="dv">1</span>] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> ;
    <span class="co">// sは{&#39;a&#39;,&#39;\0&#39;, &#39;c&#39;,&#39;\0&#39;}</span>
}</code></pre></div>
<p>この変数<code>s</code>の型は<code>char [4]</code>だが、null終端文字列としてのサイズは1だ。</p>
<p>文字列のサイズを長くするには、当然大きな配列が必要になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">char</span> s[<span class="dv">10</span>] = <span class="st">&quot;abc&quot;</span> ;
    s[<span class="dv">3</span>] = <span class="st">&#39;d&#39;</span> ;
    s[<span class="dv">4</span>] = <span class="st">&#39;e&#39;</span> ;
    s[<span class="dv">5</span>] = <span class="st">&#39;f&#39;</span> ;
    s[<span class="dv">6</span>] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> ;
}</code></pre></div>
<p>このコードで、変数<code>s</code>は最終的に<code>&quot;abcdef&quot;</code>という文字列になる。最後のnull文字による終端を忘れてはならない。</p>
<p>ここで、配列<code>s</code>の要素数は7以上でなければならない。最終的なnull終端文字列を表現するには最低でも<code>char [7]</code>が必要だからだ。</p>
<p>例えば2つのnull終端文字列を結合する場合で、どちらも<code>const</code>であったり、十分なサイズがなかった場合、2つの文字列を保持できるサイズのメモリーを確保して、コピーしなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// s1, s2を結合して使う関数</span>
<span class="dt">void</span> concat_str( <span class="dt">const</span> <span class="dt">char</span> *  s1, <span class="dt">const</span> <span class="dt">char</span> * s2 )
{
    <span class="co">// 2つの文字列のサイズの合計 + null文字</span>
    <span class="kw">auto</span> size = std::strlen( s1 ) + std::strlen( s2 ) + <span class="dv">1</span> ;
    <span class="co">// 文字列を保持するメモリーを確保する</span>
    <span class="dt">char</span> * ptr = <span class="kw">new</span> <span class="dt">char</span>[size] ;

    <span class="dt">char</span> * i = ptr ;
    <span class="co">// s1をコピー</span>
    <span class="kw">while</span> ( *s1 != <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> )
    {
        *i = *s1 ;
        ++i ; ++s1 ;
    }
    <span class="co">// s2をコピー</span>
    <span class="kw">while</span> ( *s2 != <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> )
    {
        *i = *s2 ;
        ++i ; ++s2 ;
    }
    <span class="co">// null終端する</span>
    *i = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span> ;

    <span class="co">// 結合した文字列を使う</span>

    <span class="co">// 使い終わったのでメモリーを解放する</span>
    <span class="kw">delete</span>[] ptr ;
}</code></pre></div>
<p>C言語の標準ライブラリにはnull終端文字列を扱うためのライブラリが多数ある。C言語の標準ライブラリを使えば、上のコードは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> concat_str( <span class="dt">const</span> <span class="dt">char</span> *  s1, <span class="dt">const</span> <span class="dt">char</span> * s2 )
{
    <span class="kw">auto</span> size = std::strlen( s1 ) + std::strlen( s2 ) + <span class="dv">1</span> ;
    <span class="dt">char</span> * ptr = <span class="kw">new</span> <span class="dt">char</span>[size] ;

    <span class="co">// s1をptrにコピー</span>
    std::strcpy( ptr, s1 ) ;
    <span class="co">// ptrとs2を結合</span>
    std::strcat( ptr, s2 ) ;

    <span class="kw">delete</span>[] ptr ;
}</code></pre></div>
<h3 id="basic_stringの操作">basic_stringの操作</h3>
<p><code>basic_string</code>はストレージを所有するクラスだ。ストレージの解放と確保を自動でやってくれる上に、便利な操作がたくさんある。</p>
<p>例えば上の<code>concat_str</code>を<code>basic_string</code>で実装すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> concat_str( <span class="dt">const</span> <span class="dt">char</span> *  s1, <span class="dt">const</span> <span class="dt">char</span> * s2 )
{
    std::string s = s1 ;
    s += s2 ;

    <span class="co">// sを使う</span>
    <span class="co">// sは自動的に破棄される</span>
}</code></pre></div>
<p>C++の作法に従って、引数<code>s1, s2</code>をnull終端文字列文字型ではなく、<code>basic_string_view</code>にすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> concat_str( std::string_view s1, std::string_view s2 )
{
    std::string s = s1 ;
    s += s2 ;

    <span class="co">// sを使う</span>
    <span class="co">// sは自動的に破棄される</span>
}</code></pre></div>
<h4 id="初期化">初期化</h4>
<p><code>basic_string</code>はnull終端文字列、<code>basic_string_view</code>、<code>basic_string</code>で初期化、代入できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// null終端文字列</span>
std::string s1(<span class="st">&quot;hello&quot;</span>) ;
<span class="co">// basic_string_view</span>
std::string s2(<span class="st">&quot;hello&quot;</span>sv) ;
<span class="co">// basic_string</span>
std::string s3(<span class="st">&quot;hello&quot;</span>s) ;</code></pre></div>
<h4 id="結合">結合</h4>
<p><code>basic_string</code>は<code>operator +</code>で文字列を結合できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &quot;foobar&quot;</span>
<span class="kw">auto</span> s = <span class="st">&quot;foo&quot;</span>s + <span class="st">&quot;bar&quot;</span>s ;</code></pre></div>
<p><code>operator +=</code>は第一オペランドを書き換える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> s = <span class="st">&quot;foo&quot;</span>s ;
s += <span class="st">&quot;bar&quot;</span>s ;
<span class="co">// sは&quot;foobar&quot;</span></code></pre></div>
<p><code>basic_string::append(s)</code>というメンバー関数もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> s = <span class="st">&quot;foo&quot;</span>s ;
s.append(<span class="st">&quot;bar&quot;</span>sv) ;
<span class="co">// sは&quot;foobar&quot; </span></code></pre></div>
<h4 id="イテレーター-1">イテレーター</h4>
<p><code>basic_string</code>にはイテレーターがある。イテレーターの取得方法は<code>std::vector</code>と同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> s = <span class="st">&quot;hello&quot;</span>s ;
    <span class="kw">for</span> ( <span class="kw">auto</span> i = s.begin() ; i != s.end() ; ++i )
    {
        std::cout &lt;&lt; *i ;
    }
}</code></pre></div>
<p>これは以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span> ( <span class="kw">auto</span> i = std::begin(s) ; i != std::end(s) ; ++i )
{
    std::cout &lt;&lt; *i ;
}</code></pre></div>
<h4 id="部分文字列の検索">部分文字列の検索</h4>
<p>イテレーターがあるので、<code>basic_string</code>は汎用的なアルゴリズムに渡すことができる。例えばある文字列がその一部の別の文字列を含むかどうかを調べる場合、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s ;
    <span class="kw">auto</span> word = <span class="st">&quot;fox&quot;</span>s ;

    <span class="kw">auto</span> i = std::search( std::begin(text), std::end(text), std::begin(word), std::end(word) ) ;

    <span class="kw">if</span> ( i != std::end(text) )
        std::cout &lt;&lt; <span class="st">&quot;fox found!</span><span class="ch">\n</span><span class="st">&quot;</span>sv ;
    <span class="kw">else</span>
        std::cout &lt;&lt; <span class="st">&quot;no fox...</span><span class="ch">\n</span><span class="st">&quot;</span>sv ;
}</code></pre></div>
<p>イテレーターを使うのは煩わしいが、C++20では<code>Range</code>ライブラリが追加され、以下のように書ける予定だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> r = std::ranges::search( text, word ) ;
<span class="kw">if</span> ( !std::ranges::empty(r) )
    <span class="co">// ...</span></code></pre></div>
<p>名前空間を省くと、<code>!empty( search( text, word) )</code> になるが、これでもまだわかりづらい。そこで<code>basic_string::find</code>がある。これは<code>&lt;algorithm&gt;</code>の<code>std::find</code>とは別物で、文字列から部分文字列を探し、その部分文字列に一致する文字へのインデックスを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s ;

    <span class="co">// 12</span>
    <span class="kw">auto</span> fox = text.find(<span class="st">&quot;fox&quot;</span>sv) ;
    <span class="co">// 32</span>
    <span class="kw">auto</span> dog = text.find(<span class="st">&quot;dog&quot;</span>sv) ;
}</code></pre></div>
<p>文字列<code>&quot;fox&quot;</code>に一致する部分文字列の先頭<code>'f'</code>の文字型の値へのインデックスは<code>12</code>で、<code>&quot;dog&quot;</code>の<code>'d'</code>は<code>36</code>だ。この結果は、上のソースコードに使っている文字が1文字につき1文字型の値を使うためだ。通常は文字数と連続した文字型の要素へのインデックスは等しくならない。</p>
<p>例えば以下のコードを実行すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">u8&quot;すばしっこい茶色の狐がノロマな犬を飛び越した。&quot;</span>s ;

    <span class="kw">auto</span> fox = text.find(<span class="st">u8&quot;狐&quot;</span>sv) ;
    <span class="kw">auto</span> dog = text.find(<span class="st">u8&quot;犬&quot;</span>sv) ;

    std::cout &lt;&lt; <span class="st">&quot;fox: &quot;</span>sv &lt;&lt; fox &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>sv
            &lt;&lt; <span class="st">&quot;dog: &quot;</span>sv &lt;&lt; dog ;
}</code></pre></div>
<p>以下のように出力される。</p>
<pre><code>fox: 27
dog: 45</code></pre>
<p>もし部分文字列が見つからない場合、<code>basic_string::npos</code>が返る。<code>npos</code>は&quot;no position&quot;という意味で、<code>-1</code>と等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s ;

    <span class="co">// 見つからない場合はnposが返る。   </span>
    <span class="kw">auto</span> index = text.find(<span class="st">&quot;abc&quot;</span>sv) ;

    <span class="co">// 見つからなかった判定</span>
    <span class="kw">if</span> ( index != std::string::npos )
        <span class="co">// 見つかった</span>
        std::cout &lt;&lt; <span class="st">&quot;found.&quot;</span> ;
    <span class="kw">else</span>
        <span class="co">// 見つからなかった</span>
        std::cout &lt;&lt; <span class="st">&quot;not found.&quot;</span> ;
}</code></pre></div>
<p>この場合、変数<code>text</code>に文字列<code>&quot;abc&quot;</code>はないので、<code>npos</code>が返る。<code>npos</code>が返ったかどうかは<code>npos</code>と比較すればわかる。<code>npos</code>は<code>-1</code>と等しいので、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">if</span> ( index != <span class="dv">-1</span> )
    <span class="co">// ...</span></code></pre></div>
<p><code>find</code>の亜種として、<code>rfind</code>がある。</p>
<p><code>find</code>は最初の部分文字列を見つけるが、<code>rfind</code>は最後の部分文字列を見つける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;word word word&quot;</span>s ;

    <span class="co">// 0</span>
    <span class="kw">auto</span> first = text.find(<span class="st">&quot;word&quot;</span>sv) ;
    <span class="co">// 10</span>
    <span class="kw">auto</span> last = text.rfind(<span class="st">&quot;word&quot;</span>sv) ;
}</code></pre></div>
<p><code>find</code>は最初に一致した部分文字列の先頭へのインデックスを返すので、この場合<code>0</code>が返る。<code>rfind</code>は最後に見つかった部分文字列の先頭へのインデックスを返すので、この場合<code>10</code>になる。</p>
<p>C++20では、<code>starts_with/ends_with</code>という2つの便利なメンバー関数が追加される。</p>
<p><code>starts_with(str)</code>は文字列が部分文字列<code>str</code>で始まっている場合に<code>true</code>を返す。そうでない場合は<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;aa bb cc&quot;</span>s ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = text.starts_with(<span class="st">&quot;a&quot;</span>sv) ;
    <span class="dt">bool</span> b2 = text.starts_with(<span class="st">&quot;aa&quot;</span>sv) ;
    <span class="dt">bool</span> b3 = text.starts_with(<span class="st">&quot;aa &quot;</span>sv) ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b4 = text.starts_with(<span class="st">&quot;b&quot;</span>sv) ;
    <span class="dt">bool</span> b5 = text.starts_with(<span class="st">&quot;aaa&quot;</span>sv) ;
}</code></pre></div>
<p><code>ends_with(str)</code>は文字列が部分文字列<code>str</code>で終わっている場合に<code>true</code>を返す。そうでない場合は<code>false</code>を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;aa bb cc&quot;</span>s ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = text.ends_with(<span class="st">&quot;c&quot;</span>sv) ;
    <span class="dt">bool</span> b2 = text.ends_with(<span class="st">&quot;cc&quot;</span>sv) ;
    <span class="dt">bool</span> b3 = text.ends_with(<span class="st">&quot; cc &quot;</span>sv) ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b4 = text.ends_with(<span class="st">&quot;b&quot;</span>sv) ;
    <span class="dt">bool</span> b5 = text.ends_with(<span class="st">&quot;ccc&quot;</span>sv) ;
}</code></pre></div>
<h4 id="その他のメンバー関数">その他のメンバー関数</h4>
<p><code>size</code>, <code>empty</code>, <code>resize</code>, <code>capacity</code>, <code>reserve</code>, <code>shrink_to_fit</code>, <code>clear</code>といったおなじみのメンバー関数もある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::string s ;
    s.size() ;
    s.resize(<span class="dv">10</span>) ;
    s.clear() ;
}</code></pre></div>
<h4 id="文字列の挿入">文字列の挿入</h4>
<p>文字列の挿入は<code>insert( pos, str )</code> で行える。</p>
<p><code>pos</code>は挿入場所へのインデックスで、<code>str</code>は挿入する文字列だ。</p>
<p>文字列の先頭や末尾への挿入は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;cat&quot;</span>s ;
    text.insert( <span class="dv">0</span>, <span class="st">&quot;long &quot;</span>sv ) ;
    <span class="co">// textは&quot;long cat&quot;</span>
    text.insert( text.size(), <span class="st">&quot; is loong.&quot;</span>sv ) ;
    <span class="co">// textは&quot;long cat is loong.&quot;</span>
}</code></pre></div>
<p>末尾への挿入は文字列の結合と同じ効果だ。</p>
<p>インデックスで中間に挿入するのは以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;big cat&quot;</span>s ;
    text.insert( text.find(<span class="st">&quot;cat&quot;</span>sv), <span class="st">&quot;fat &quot;</span>sv ) ;
    <span class="co">// textは&quot;big fat cat&quot;</span>
}</code></pre></div>
<p>これは<code>text.find(&quot;cat&quot;sv)</code>でまず部分文字列<code>&quot;cat&quot;</code>の先頭へのインデックスを探し、そこに文字列<code>&quot;fat &quot;</code>を挿入している。結果として変数<code>text</code>は<code>&quot;big fat cat&quot;</code>となる。</p>
<h4 id="部分文字列の削除">部分文字列の削除</h4>
<p>文字列から部分文字列を削除するには<code>erase( pos, n )</code>を使う。<code>pos</code>は削除すべき先頭のインデックスで、<code>n</code>は削除すべきインデックス数だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;dirty cat&quot;</span>s ;
    <span class="kw">auto</span> dirty = <span class="st">&quot;dirty &quot;</span>sv ;
    text.erase( <span class="dv">0</span>, dirty.size() ) ;
    <span class="co">// textは&quot;cat&quot;</span>
}</code></pre></div>
<p>このプログラムは文字列<code>&quot;dirty cat&quot;</code>から<code>&quot;dirty &quot;</code>を削除し、<code>&quot;cat&quot;</code>にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;big fat cat&quot;</span>s ;
    <span class="kw">auto</span> fat = <span class="st">&quot;fat &quot;</span>sv ;
    text.erase( text.find(fat), fat.size() ) ;
    <span class="co">// textは&quot;big cat&quot;</span>
}</code></pre></div>
<p>このプログラムは文字列<code>&quot;big fat cat&quot;</code>から部分文字列<code>&quot;fat&quot;</code>を検索し、その先頭から変数<code>fat</code>のサイズ文の部分文字列を削除する。結果として変数<code>text</code>は<code>&quot;big cat&quot;</code>になる。</p>
<p>先頭から末尾までを削除すると、<code>clear()</code>と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;abc&quot;</span>s ;
    text.erase( <span class="dv">0</span>, text.size() ) ;
    <span class="co">// text.empty() == true</span>
}</code></pre></div>
<h4 id="部分文字列の置換">部分文字列の置換</h4>
<p><code>replace( pos, n1, str )</code>を使うと、文字列のインデックス<code>pos</code>から<code>n1</code>個までの文字型の値を、文字列<code>str</code>で置き換える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;ugly cat&quot;</span>s ;
    <span class="kw">auto</span> ugly = <span class="st">&quot;ugly&quot;</span>sv ;
    <span class="kw">auto</span> pretty = <span class="st">&quot;pretty&quot;</span>sv ;
    text.replace( text.find(ugly), ugly.size(), pretty ) ;
    <span class="co">// textは&quot;pretty cat&quot;</span>
}</code></pre></div>
<p>このコードは、文字列<code>text</code>から部分文字列<code>&quot;ugly&quot;</code>を探し、その先頭へのインデックスと文字列<code>&quot;ugly&quot;</code>のサイズを指定することで、部分文字列<code>&quot;ugly&quot;</code>を、文字列<code>pretty</code>の値である<code>&quot;pretty&quot;</code>に置換する。結果として<code>text</code>は<code>&quot;pretty cat&quot;</code>になる。</p>
<h4 id="その他の推奨できない操作">その他の推奨できない操作</h4>
<p><code>basic_string</code>にはこのほかにさまざまな、現代では推奨できない操作がある。</p>
<p>例えば<code>operator []</code>で文字列をインデックスでアクセスできる。これは基本実行文字セットに対しては動く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;abc&quot;</span>s ;
    <span class="co">// &#39;a&#39;</span>
    std::cout &lt;&lt; text[<span class="dv">0</span>] ;
    <span class="co">// &#39;b&#39;</span>
    std::cout &lt;&lt; text[<span class="dv">1</span>] ;

    text[<span class="dv">0</span>] = <span class="st">&#39;x&#39;</span> ;
    <span class="co">// textは&quot;xbc&quot;</span>
}</code></pre></div>
<p>これは、<code>basic_string</code>が設計された時代は、1文字型は1文字を表現できるという前提があったからだ。</p>
<p>現代の文字列の表現方法であるUnicodeとUTFによるエンコードではこの前提が成り立たない。例えば、最もよく使われているUTF-8の場合、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">u8&quot;いろは&quot;</span>s ;
    <span class="co">// 0xe3</span>
    <span class="kw">auto</span> c = text[<span class="dv">0</span>] ;
}</code></pre></div>
<p><code>text</code>のインデックス<code>0</code>にあたる文字型の値は<code>u8'い'</code>ではない。UTF-8は文字「い」を文字型1つで表現できないからだ。<code>u8&quot;いろは&quot;</code>というUTF-8文字列リテラルはすでに学んだように、以下のように表現される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// u8&quot;いろは&quot;</span>
char8_t iroha[<span class="dv">10</span>] = { <span class="bn">0xe3</span>, <span class="bn">0x81</span>, <span class="bn">0x84</span>, <span class="bn">0xe3</span>, <span class="bn">0x82</span>, <span class="bn">0x8d</span>, <span class="bn">0xe3</span>, <span class="bn">0x81</span>, <span class="bn">0xaf</span>, <span class="bn">0x0</span> } ;</code></pre></div>
<p>文字「い」をUTF-8で表現するためには、<code>char8_t</code>型の値が3つ必要で、<code>0xe3, 0x81, 0x84</code>というシーケンスでなければならない。そのため、個々の文字型の値をインデックスでアクセスしても意味がない。また、<code>size()</code>は文字数を返すのではなく、インデックス数を返す。</p>
<p><code>basic_string</code>にはリバースイテレーターを返す<code>rbegin/rend</code>もあるが、Unicodeでエンコードされた文字列では、複数の値のシーケンスで1文字を表現しているため、単に値単位で逆順のイテレートすることは、技術的には可能だが、意味的には壊れてしまう。</p>
<p><code>basic_string</code>には最初に発見したいずれかの文字へのインデックスを返す<code>find_first_of</code>がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span>s ;
    <span class="co">// 3</span>
    <span class="kw">auto</span> i = text.find_first_of(<span class="st">&quot;abc&quot;</span>sv) ;
}</code></pre></div>
<p><code>i</code>は<code>3</code>になる。なぜならば、<code>find_first_of(&quot;abc&quot;sv)</code>は<code>a</code>, <code>b</code>, <code>c</code>のうちいずれかの文字である最初のインデックスを返すからだ。</p>
<p>この機能はUnicodeでは使えない。というのも1文字型で1文字を表現できないからだ。</p>
<h3 id="basic_string_viewの操作">basic_string_viewの操作</h3>
<p><code>basic_string_view</code>は<code>basic_string</code>とほぼ同じ操作が行える。ただし、<code>basic_string_view</code>は書き換えることができないので、一部の操作が使えない。<code>append, insert, erase, replace</code>は使えない。<code>basic_string_view</code>同士の<code>operator +</code>もない。</p>
<p>C++20では、文字列の先頭と末尾を指定したインデックス数分削ることはできる。</p>
<p>先頭を削るには<code>remove_prefix(i)</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span> ;
    text.remove_prefix( <span class="st">&quot;quick &quot;</span>sv.size() ) ;
    <span class="co">// textは&quot;brown fox jumps over the lazy dog.&quot;</span>
    text.remove_prefix( <span class="st">&quot;brown&quot;</span>sv.size() ) ;
    <span class="co">// textは&quot;fox jumps over the lazy dog.&quot;</span>
}</code></pre></div>
<p>末尾を削るには<code>remove_suffix(i)</code>を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> text = <span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span> ;
    text.remove_suffix( <span class="st">&quot; dog.&quot;</span>sv.size() ) ;
    <span class="co">// textは&quot;quick brown fox jumps over the lazy&quot;</span>
    text.remove_suffix( <span class="st">&quot; lazy&quot;</span>.sv.size() ) ;
    <span class="co">// textは&quot;quick brown fox jumps over the&quot;</span>
}</code></pre></div>
<h1 id="乱数">乱数</h1>
<p>乱数はプログラミングにおいてよく使う。例えば6面ダイスをプログラムで実装するには、1, 2, 3, 4, 5, 6までのいずれかの目を出す。</p>
<pre><code>$ ./dice
1
5
$ ./dice
3
5 1 6
$ ./dice
10
5 1 6 6 1 6 6 2 4 2</code></pre>
<p>このプログラム<code>dice</code>は標準入力から整数型の値<code>n</code>を取り、1, 2, 3, 4, 5, 6のいずれかをそれぞれ<span class="math inline">\(\frac{1}{6}\)</span>の確率で<code>n</code>個出力する。</p>
<p>まずこの<code>dice</code>プログラムを作ることを目標にC++の乱数アルゴリズムである<code>&lt;random&gt;</code>の使い方を学んでいく。</p>
<h2 id="疑似乱数">疑似乱数</h2>
<p>コンピューターで使われる乱数のほとんどは疑似乱数と呼ばれる方法で生成されている。さまざまなアルゴリズムがあるが、とても簡単に理解できる疑似乱数のアルゴリズムに、線形合同法(Linear congruential generator)がある。</p>
<p>線形合同法ではいまの乱数を<span class="math inline">\(X_n\)</span>、次の乱数を<span class="math inline">\(X_{n+1}\)</span>とすると、<span class="math inline">\(X_{n+1}\)</span>は以下のように求められる。</p>
<p><span class="math display">\[
X_{n+1} = (a \times X_{n} + c) \bmod m
\]</span></p>
<p>たとえば<span class="math inline">\(a = 3, c = 5, m = 2^{sizeof(std::uint32_t) \times 8}\)</span>の場合で、<span class="math inline">\(X_0 = 0\)</span>のとき、</p>
<p><span class="math display">\[X_0 = 0\]</span></p>
<p><span class="math display">\[X_1 = 3 \times 0 + 5 \bmod 2^{32}-1 = 5\]</span></p>
<p><span class="math display">\[X_2 = 3 \times X_1 + 5 \bmod 2^{32}-1 = 20\]</span></p>
<p><span class="math display">\[X_3 = 3 \times X_2 + 5 \bmod 2^{32}-1 = 65\]</span></p>
<p>「これはぜんぜん乱数ではない。予測可能じゃないか」と考えるかもしれない。しかし中でどのように乱数が生成されているかわからなければ、外部からは乱数のように見える。これが擬似乱数の考え方だ。</p>
<h2 id="乱数エンジン">乱数エンジン</h2>
<p><code>乱数エンジン</code>は生の乱数を生成するライブラリだ。クラスで実装されている。</p>
<p>乱数エンジンはメンバー関数<code>min()</code>で最小値を、メンバー関数<code>max()</code>で最大値を、<code>operator()</code>で最小値から最大値の間の乱数を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">void</span> f( Engine &amp; e )
{
    <span class="co">// 最小値</span>
    <span class="kw">auto</span> a = e.min() ;
    <span class="co">// 最大値</span>
    <span class="kw">auto</span> b = e.max() ;
    <span class="co">// 乱数</span>
    <span class="kw">auto</span> r1 = e() ;
    <span class="co">// 次の乱数</span>
    <span class="kw">auto</span> r2 = e() ;
}</code></pre></div>
<p>乱数エンジンのオブジェクト<code>e</code>は<code>operator ()</code>を呼び出すたび、つまり<code>e()</code>をするたびに変更される。これは疑似乱数のための内部状態を更新するためだ。そのため、乱数エンジンは<code>const</code>では新しい乱数を作るのに使えない。</p>
<p>標準ライブラリはデフォルトの乱数エンジンとして<code>std::default_random_engine</code>を提供している。</p>
<p>以下のプログラムはデフォルトの乱数エンジンから乱数を10個出力する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 乱数エンジン</span>
    std::default_random_engine e ;
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        <span class="co">// 乱数を出力</span>
        std::cout &lt;&lt; e() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>sv ;
    }
}</code></pre></div>
<p>標準ライブラリの提供する乱数エンジンにはさまざまなものがあるが、本書ではもう1つ、メルセンヌツイスターというアルゴリズムを実装した乱数エンジンを紹介する。<code>std::mt19937</code>だ。</p>
<p><code>std::mt19937</code>を使うには、<code>st::default_random_engine</code>を置き換えるだけでいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e ;
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        std::cout &lt;&lt; e() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>sv ;
    }
}</code></pre></div>
<p>メルセンヌツイスターはとても優秀な乱数エンジンだ。乱数が必要な多くの場面では、メルセンヌツイスターを使っておけばまず問題はない。</p>
<p>では乱数エンジンを使って、生の乱数を標準入力で得た個数だけ出力するプログラムを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 乱数エンジン</span>
    std::mt19937 e ;

    <span class="co">// 標準入力からnを得る</span>
    <span class="dt">unsigned</span> n {} ;
    std::cin &gt;&gt; n ;
    <span class="co">// n個出力</span>
    <span class="kw">for</span> ( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i != n ; ++i )
    {
        std::cout &lt;&lt; e() &lt;&lt; <span class="st">&quot; &quot;</span>sv ;
    }
}</code></pre></div>
<p>実行結果は以下のようになる。</p>
<pre><code>$ dice
10
3499211612 581869302 3890346734 3586334585 545404204 4161255391 3922919429 949333985 2715962298 1323567403 </code></pre>
<p>乱数エンジンで生成されるのは生の乱数だ。これは通常、32bit符号なし整数とか64bit符号なし整数で表現できる全範囲の値として生成される。これは実際に必要な乱数とは値の範囲が違う。実際に必要な乱数とは、例えば6面ダイスの場合は、<code>int</code>型で1, 2, 3, 4, 5, 6のいずれかの値がそれぞれ<span class="math inline">\(\frac{1}{6}\)</span>の確率で出てほしい。</p>
<h2 id="乱数分布">乱数分布</h2>
<p><code>乱数分布</code>とは生の乱数を望みの範囲の乱数に加工するためのライブラリだ。クラスで実装されている。</p>
<p>乱数分布ライブラリにもさまざまなものがあるが、6面ダイスのプログラムを実装するのに使うのは<code>std::uniform_int_distribution&lt;T&gt;</code>だ。</p>
<p>この乱数分布ライブラリは、<code>T</code>にほしい乱数の整数型を指定する。コンストラクター引数を2つ取るので、1つ目の引数に最小値、2つ目の引数に最大値を指定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uniform_int_distribution&lt;<span class="dt">int</span>&gt; d(a, b) ;</code></pre></div>
<p>この乱数分布クラスの変数<code>d</code>は、<span class="math inline">\(a \leq r \leq b\)</span>までの範囲の<code>int</code>型の乱数<code>r</code>を作り出す。</p>
<p>6面ダイスを作るには、<code>d(a, b)</code>を<code>d(1, 6)</code>にすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uniform_int_distribution&lt;<span class="dt">int</span>&gt; d(<span class="dv">1</span>, <span class="dv">6</span>) ;</code></pre></div>
<p>乱数分布クラスのオブジェクト<code>d</code>を作ったならば、<code>operator()</code>に乱数エンジンのオブジェクトを引数に渡すことで乱数が作れる。乱数エンジンのオブジェクトを<code>e</code>とすると、<code>d(e)</code>だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine, <span class="kw">typename</span> Distribution &gt;
<span class="dt">void</span> f( Engine &amp; e, Distribution d)
{
    <span class="co">// 乱数</span>
    <span class="kw">auto</span> r1 = d(e) ;
    <span class="co">// 次の乱数   </span>
    <span class="kw">auto</span> r2 = d(e) ;
    <span class="co">// 次の乱数</span>
    <span class="kw">auto</span> r3 = d(e) ; 
}</code></pre></div>
<p>以上の知識を利用して、プログラム<code>dice</code>を作ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 乱数エンジン</span>
    std::mt19937 e ;
    <span class="co">// 乱数分布</span>
    std::uniform_int_distribution&lt;<span class="dt">int</span>&gt; d(<span class="dv">1</span>, <span class="dv">6</span>) ;

    <span class="co">// 入力を処理</span>
    <span class="dt">unsigned</span> n {} ;
    std::cin &gt;&gt; n ;
    <span class="kw">for</span> ( <span class="dt">unsigned</span> <span class="dt">int</span> i = <span class="dv">0</span> ; i != n ; ++i )
    {
        <span class="co">// 乱数出力</span>
        std::cout &lt;&lt; d(e) &lt;&lt; <span class="st">&quot; &quot;</span>sv ;
    }
}</code></pre></div>
<p>さっそく実行してみよう。</p>
<pre><code>$ ./dice
5
5 1 6 6 1
$ ./dice
10
5 1 6 6 1 6 6 2 4 2
$ ./dice
20
5 1 6 6 1 6 6 2 4 2 1 4 2 2 4 6 6 6 6 6</code></pre>
<p>この場合、乱数値は正の整数しか生成しないので、型を<code>int</code>ではなく<code>unsigned int</code>にすることもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uniform_int_distribution&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt; d( <span class="dv">1</span>, <span class="dv">6</span> ) ;</code></pre></div>
<p>ただし、乱数の結果の型を<code>unsigned int</code>にすると、生成した乱数を使うときに負数が出てくるような計算で問題になる。例えば6面ダイスを2回振り、1回目の出目から2回目の出目を引き算するコードを書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e ;
    std::uniform_int_distribution&lt;<span class="dt">unsigned</span> <span class="dt">int</span>&gt; d( <span class="dv">1</span>, <span class="dv">6</span> ) ;
    <span class="kw">auto</span> a = d(e) ; <span class="co">// 1回目</span>
    <span class="kw">auto</span> b = d(e) ; <span class="co">// 2回目</span>

    <span class="kw">auto</span> result = a - b ; <span class="co">// 結果</span>
    std::cout &lt;&lt; result ;
}</code></pre></div>
<p>もし2回目の出目の方が1回目の出目より大きかった場合、結果は負数になってしまうが、<code>unsigned int</code>型は負数を表現できない。</p>
<p>そのため、通常は符号付きの整数型を使った方が安全だ。</p>
<p>また、分布クラスのテンプレートパラメーターにはデフォルトテンプレート実引数が指定されているので、デフォルトでよければ省略することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// std::uniform_int_distribution&lt;int&gt;と同じ</span>
std:uniform_int_distribution d( <span class="dv">1</span>, <span class="dv">6</span> ) ;</code></pre></div>
<p>ところで、上のコードは動くのだが、別のプログラムを実行しても毎回同じ出力になる。これでは実用的な6面ダイスプログラムとは言えない。プログラムの実行ごとに結果を買えたい場合、シードを設定する。</p>
<h2 id="シード">シード</h2>
<p>線形合同法を思い出してみよう。線形合同法で次の乱数<span class="math inline">\(X_{n+1}\)</span>を計算するには、いまの乱数<span class="math inline">\(X_{n}\)</span>に対して<span class="math inline">\(X_{n+1} = (a \times X_{n} + c) \bmod m\)</span>という計算をする。</p>
<p>線形合同法とは現在の乱数値を内部状態として持ち、そこに計算を加えることで次の乱数を作り出すのだ。</p>
<p>一般化すると、疑似乱数は内部状態<span class="math inline">\(S_n\)</span>を持ち、計算を加える関数<span class="math inline">\(f(x)\)</span>を適用することで、次の内部状態<span class="math inline">\(S_{n+1}=f(S_n)\)</span>を作り出すのだ。単純な線形合同法の場合、内部状態がそのまま乱数の値になるが、複雑な疑似乱数アルゴリズムでは、内部状態から乱数を求めるのにさらに計算を加えるものもある。</p>
<p>乱数エンジンをデフォルト初期化すると、この内部状態もデフォルト初期化される。そのため、いままで使っていた乱数は、プログラムの実行ごとに同じ乱数列を作り出すのだ。</p>
<p>疑似乱数の内部状態の初期状態を設定するための値をシード(seed)という。シードを設定するには、<code>std::seed_seq</code>というクラスのオブジェクトを乱数エンジンのコンストラクターに渡す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::seed_seq s{<span class="dv">124</span>} ;
    std::mt19937 e(s) ;
    std::cout &lt;&lt; e() ;
}</code></pre></div>
<p><code>std::seed_seq s({n})</code>の<code>n</code>の値を変更し、異なるシード値が異なる生の乱数を生成しているのを確かめよう。</p>
<p>シード値は乱数エンジンのメンバー関数<code>seed(s)</code>でも渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::seed_seq s{<span class="dv">123</span>} ;
    <span class="co">// シード値を設定</span>
    std::mt19937 e(s) ;
    <span class="co">// 乱数を生成</span>
    <span class="co">// 内部状態が変わる</span>
    <span class="kw">auto</span> r1 = e() ;
    <span class="co">// シード値を設定</span>
    e.seed(s) ;
    <span class="co">// 乱数を生成</span>
    <span class="kw">auto</span> r2 = e() ;
    <span class="co">// 同じシード値による乱数は同じ値になる</span>
    <span class="co">// r1 == r2</span>
}</code></pre></div>
<p><code>r1 == r2</code>になるのは、同じシード値を渡して内部状態を設定しているからだ。</p>
<p><code>std::seed_seq</code>には複数の符号なし32bit整数を渡すことができる。<code>= {n1, n2, n3,...}</code>のように初期化することもできるし、イテレーターを使って<code>(first, last)</code>のように設定することもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::seed_seq s1 = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ;

    std::vector&lt;std::uint32_t&gt; v = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>} ; 
    std::seed_seq s2( std::begin(v), std::end(v) ) ;
}</code></pre></div>
<p>乱数エンジンをコピーすると、その内部状態もコピーされる。これを利用して、乱数を保存しておくこともできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e1 ;
    <span class="co">// 2回乱数を生成</span>
    e1() ; e1() ;
    <span class="co">// コピー、内部状態もコピーされる</span>
    std::mt19937 e2 = e1 ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = e1() == e2() ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b2 = e1() == e2() ;
}</code></pre></div>
<p>乱数エンジン<code>e1</code>, <code>e2</code>は同じ状態を持っているので、同じ回数乱数生成をすると、同じ乱数列が生成される。</p>
<h2 id="予測不可能な乱数">予測不可能な乱数</h2>
<p>シード値を設定すれば乱数エンジンに異なった乱数列を生成させることができる。しかし、シード値はどうやって生成すればいいのだろうか。シード値をデフォルト初期化した乱数エンジンで生成しても意味がない。なぜならば初期状態はプログラムの実行ごとに同じだからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e1 ;
    std::seed_seq s = { e1(), e1(), e1() } ;
    <span class="co">// 意味がない</span>
    std::mt19937 e2(s) ;
}</code></pre></div>
<p>内部状態を更新するのではない、本当に予測不可能な乱数を生成するには、ハードウェアの支援が必要だ。例えば放射性同位体がいつ放射性崩壊を起こすかは予測不可能だ。したがって放射線量を計測するガイガーカウンターの値は予測不可能だ。コンピューターにガイガーカウンターが取り付けられていれば、その値を読むことによって予測不可能な値を得ることができる。ほかにもコンピューターにはさまざまな予測不可能な値を得る方法がある。<code>std::random_device</code>はそのような実装依存のコンピューターの支援を受け、予測不可能な乱数を生成する乱数エンジンだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::random_device rd ;
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
        std::cout &lt;&lt; rd() &lt;&lt; <span class="st">&quot; &quot;</span>sv ;
}</code></pre></div>
<p><code>std::random_device</code>を使えば、<code>std::seed_seq</code>を予測不可能な値で初期化できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 予測不可能な乱数エンジン</span>
std::random_device rd ;
<span class="co">// シード値</span>
std::seed_seq s = { rd(), rd(), rd() } ;
<span class="co">// シード値を指定して初期化</span>
std::mt19937 e(s) ;</code></pre></div>
<h2 id="十分なシード値の量">十分なシード値の量</h2>
<p><code>std::seed_seq</code>の初期化では32bit符号なし整数をいくつでも指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::random_device rd ;
std::seed_seq s = { rd(), rd(), rd(), ...} ;</code></pre></div>
<p>ではいくつの値を渡せばいいのだろうかということは、初期化する乱数エンジンの内部状態のサイズによって異なってくる。現在、C++標準規格には乱数エンジンを適切に初期化する簡単な方法がない。</p>
<p>1つの目安としては、乱数エンジンのオブジェクトサイズがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::cout &lt;&lt; <span class="kw">sizeof</span>(std::mt19937) ;   
}</code></pre></div>
<p>これを筆者の環境で実行すると、<code>5000</code>と出力された。つまり筆者の使っているC++実装の<code>std::mt19937</code>のオブジェクトサイズは5000バイトだということだ。</p>
<p><code>std::random_device</code>は<code>unsigned int</code>型の乱数を返す。筆者の環境では<code>sizeof(unsigned int) == 4</code>になる。すると<span class="math inline">\(5000 \div 4 = 1250\)</span> となる。とすると安全のためには、<code>std::seed_seq</code>には<code>std::random_device</code>の乱数を1250個渡すべきだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::random_device rd ;
std::seed_seq s = { rd(), rd(), rd(), ... <span class="co">/*残り1247個のrd()*/</span> } ;
std::mt19937 e( s ) ;</code></pre></div>
<p>筆者の環境では<code>sizeof(std::default_random_engine) == 8</code>であった。すると2個でよいことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::random_device rd ;
std::seed_seq s = { rd(), rd() } ;
std::default_random_engine e(s) ;</code></pre></div>
<p>C++標準規格にはいずれ、乱数エンジンを予測不可能なシード値で適切に初期化する簡単な方法が追加されるはずだ。</p>
<h2 id="乱数分布ライブラリ">乱数分布ライブラリ</h2>
<p>生の乱数は使いづらい。生の乱数というのは<span class="math inline">\(n\)</span>ビットの整数値だ。それに対して、我々が使いたい実用的な乱数というのは以下のようなものだ。</p>
<ul>
<li>コイントスの結果</li>
<li>6面ダイスを振った結果</li>
<li>当選確率1%のくじ引きの結果</li>
<li>浮動小数点数0.0から1.0の範囲の値</li>
</ul>
<p>コイントスの結果は表か裏かの2値になる。いま、<span class="math inline">\(n\)</span>ビットの整数値<code>r</code>のすべてのビットが等しく乱数ビットであるならば、2値の乱数は単に<code>r &amp; 0b1</code>で得られる。</p>
<p>では6面ダイスはどうか。6面ダイスは<span class="math inline">\(1 \leq r \leq 6\)</span>までの6通りの状態を持つ乱数が必要だ。6通りの状態を表現するには、少なくとも3ビットの乱数が必要になる計算だ。しかし、3ビットの乱数は実際には多すぎる。3ビットの乱数で表現できるのは<span class="math inline">\(2^3=8\)</span>通りの状態だ。したがって、<code>r &amp; 0x111</code>というわけにはいかない。</p>
<p>巷には間違った乱数の分布方法として、<span class="math inline">\(a \leq n \leq b\)</span>の範囲の乱数<code>n</code>を生の乱数<code>r</code>から得るために、以下のような計算式を用いる方法が蔓延している。</p>
<p><span class="math display">\[
n = r \bmod |b-a| + a
\]</span></p>
<p>この間違った計算式を使うと、6面ダイスの乱数値<code>n</code>は生の乱数<code>r</code>(<span class="math inline">\(0 \leq r\)</span>)から以下のようにC++で計算できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">int</span> dice( Engine &amp; e )
{
    <span class="kw">auto</span> r = e() ;
    <span class="kw">auto</span> n = r % <span class="dv">6</span> + <span class="dv">1</span> ;
    <span class="kw">return</span> n ;
}</code></pre></div>
<p>剰余を使って値を<span class="math inline">\(0 \leq n \leq 5\)</span>までの範囲にし、そこに1を加えることで<span class="math inline">\(1 \leq n \leq 6\)</span>にしようというものだ。残念ながら、この方法は偏った6面ダイスを作ってしまう。なぜか。</p>
<p>生の乱数<code>r</code>には3ビット以上の情報が必要だ。コンピューターは整数をビット列で表現するのですべてのビットが等しく乱数の場合、<span class="math inline">\(n\)</span>ビットの乱数値は<span class="math inline">\(2^n\)</span>個の状態を持つ。これを<span class="math inline">\(0 \leq r \leq 2^n-1\)</span>に割り振った符号なし整数にしたとする。<code>r</code>が3ビットの場合、その値の範囲は<span class="math inline">\(0 \leq r \leq 7\)</span>だ。</p>
<p>上のコードでは、0から5まではそのまま1から6になる。剰余のため、6と7はそれぞれ1と2になる。すべての取り得る乱数を書き出してみよう。</p>
<table>
<thead>
<tr class="header">
<th align="left">生の乱数</th>
<th align="left">ダイス目</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">3</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">5</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<p>するとこの6面ダイスは1,2の出目の確率が<span class="math inline">\(\frac{2}{8}\)</span>で、3,4,5,6の出目の確率が<span class="math inline">\(\frac{1}{8}\)</span>になる。</p>
<p>よりビット数の大きな生の乱数を使ってもこの問題は解決しない。ビット数を増やせば増やすほど、偏りを減らすことはできるが、偏りは絶対になくならない。理由は、6の素因数3は2で割り切れないためだ。</p>
<p>では<span class="math inline">\(1 \leq n \leq 6\)</span>までの乱数を得るにはどうするのかというと以下のようなアルゴリズムで分布を行う。</p>
<ol style="list-style-type: decimal">
<li>3bitの生の乱数rを得る</li>
<li><code>r</code>が<span class="math inline">\(0 \leq r \leq 5\)</span>なら`<code>r</code>+1'が分布された乱数</li>
<li>それ以外の場合、1.に戻る</li>
</ol>
<p>これを実装すると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> dice( Engine &amp; e )
{
    <span class="co">// ループを実行する</span>
    <span class="kw">while</span> (<span class="kw">true</span>)
    {
        <span class="co">// 3bitの生の乱数を得る</span>
        <span class="kw">auto</span> r = e() &amp; <span class="bn">0b111</span> ;
        <span class="co">// 0-5なら乱数分布終わり</span>
        <span class="kw">if</span> ( r &lt;= <span class="dv">5</span> )
            <span class="kw">return</span> r + <span class="dv">1</span> ;
        <span class="co">// それ以外ならば振り直し</span>
    }
}</code></pre></div>
<p>この関数の実行時間は確率的に決まる。この実装はとても非効率的に見えるが、これ以外に公平に2で割り切れない素因数を含む状態数の乱数を生成する方法はない。</p>
<p>このコードは1回の乱数生成をキャッシュして複数回の3bitの乱数を切り出すなどの処理をすれば、乱数生成にコストがかかる場合、その分高速化できる。</p>
<h2 id="分布クラス">分布クラス</h2>
<p>分布クラスには共通の機能がある。本書ではすべてを解説しないが、重要な機能を解説する。</p>
<p>まず標準ライブラリの分布クラスに共通する機能を説明する。</p>
<p>分布クラスはオブジェクトを作り、そのオブジェクトを乱数エンジンと組み合わせて使う。その際、コンストラクターの引数で細かい設定を指定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">distribution_type d( <span class="co">/*設定*/</span> ) ;</code></pre></div>
<p>分布クラスは<code>operator ()</code>を呼び出して乱数を分布させる。その際、引数には乱数エンジンへの非<code>const</code>なリファレンスを指定する</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine, <span class="kw">typename</span> Distribution &gt;
<span class="dt">void</span> f( Engine &amp; e, Distribution &amp; d )
{
    <span class="kw">auto</span> r = d(e) ;
}</code></pre></div>
<p><code>r</code>が分布された乱数。乱数エンジン<code>e</code>と乱数分布<code>d</code>は乱数を生成したので内部状態が変更される。</p>
<p>分布クラスはメンバー関数<code>min</code>と<code>max</code>で分布する乱数の最小値、最大値が得られる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Distribution &gt;
<span class="dt">void</span> f( Distribution &amp; d )
{
    <span class="kw">auto</span> a = d.min() ;
    <span class="kw">auto</span> b = d.max() ;
}</code></pre></div>
<p>分布クラスは構築時の実引数を同名のメンバー関数で取得することができる。</p>
<p>例えば、<code>std::uniform_int_distribution( a, b )</code>の場合、構築時に渡した<code>a</code>, <code>b</code>を引数の名前でメンバー関数として取得できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uniform_int_distribution d( <span class="dv">1</span>, <span class="dv">6</span> ) ;
d.a() ; <span class="co">// 1</span>
d.b() ; <span class="co">// 6</span></code></pre></div>
<p>分布クラスは内部状態のリセットができる。</p>
<p>分布クラスは内部的に乱数値をキャッシュしている可能性がある。例えば乱数値が0か1である場合、1 bitの乱数しか必要ない。ここで渡した乱数エンジンが2 bit以上の乱数を生成できるのであれば、乱数値をキャッシュしておいて、1 bitずつ切り出して使うという最適化が考えられる。</p>
<p>しかしこの場合、同じ乱数エンジンを渡したのに、結果が違うということが起こり得る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::uniform_int_distribution a( <span class="dv">1</span>, <span class="dv">6</span> ) ;
    std::uniform_int_distribution b( <span class="dv">1</span>, <span class="dv">6</span> ) ;

    std::mt19937 x ;

    <span class="co">// 乱数を生成</span>
    <span class="co">// aは内部に乱数をキャッシュするかもしれない。</span>
    a( x ) ;

    <span class="co">// yはxと同じ内部状態を持つ</span>
    <span class="co">// つまり生成する生の乱数は同じ</span>
    std::mt19937 y = x ;

    <span class="kw">auto</span> r1 = a( x ) ;
    <span class="kw">auto</span> r2 = b( y ) ;

    <span class="co">// r1 == r2 である保証はない</span>
    
}</code></pre></div>
<p>このような場合に、内部状態をリセットするメンバー関数<code>reset</code>を呼び出せば、同じ内部状態になることが保証される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 内部状態をリセット</span>
a.reset() ;
<span class="co">// true</span>
<span class="kw">auto</span> <span class="dt">bool</span> = ( a(x) == b(y) ) ;</code></pre></div>
<p>また、この内部状態を取り出すこともできる。内部状態はネストされた型名<code>param_type</code>で保持できる。内部状態を取り出すにはメンバー関数<code>param()</code>を呼び出す。分布クラスのコンストラクターにこの<code>param_type</code>の値を渡すと、同じ内部状態の分布クラスを作り出すことができる。またメンバー関数<code>param(parm)</code>で<code>param_type</code>の値を渡して内部状態を設定することも可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Distribution &gt;
<span class="dt">void</span> f( Distribution &amp; d )
{
    <span class="co">// 内部状態の取り出し</span>
    <span class="co">// Distribution::param_type型</span>
    <span class="kw">auto</span> p = d.param() ;

    <span class="co">// dと同じ内部状態を持つ変数</span>
    Distribution same_d( p ) ;

    Distribution other ;
    <span class="co">// 既存の変数の内部状態を変更</span>
    other.param( p ) ;
} </code></pre></div>
<h2 id="一様分布uniform-distribution">一様分布(Uniform Distribution)</h2>
<p>一様分布とは乱数の取り得る状態がすべて等しい確率で出現する乱数のことだ。</p>
<h3 id="整数の一様分布stduniform_int_distributioninttype">整数の一様分布(<code>std::uniform_int_distribution&lt;IntType&gt;</code>)</h3>
<p><code>uniform_int_distribution&lt;IntType&gt;</code>は整数型の乱数<span class="math inline">\(i\)</span>, <span class="math inline">\(a \leq i \leq b\)</span>を以下の定数離散確率関数に従って分布させる。</p>
<p><span class="math display">\[
P(i\,|\,a,b) = 1 / (b - a + 1) \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uniform_int_distribution&lt;IntType&gt; d( a, b ) ;</code></pre></div>
<p><code>IntType</code>は整数型でデフォルトは<code>int</code>、<code>a</code>は最小値、<code>b</code>は最大値。ただし<span class="math inline">\(a \leq b\)</span>。</p>
<p>エンジンも含めた使い方は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">void</span> f( Engine &amp; e )
{
    std::uniform_int_distribution d(<span class="dv">1</span>, <span class="dv">10</span>) ;
    d.a() ; <span class="co">// 1</span>
    d.b() ; <span class="co">// 10</span>

    <span class="co">// 1から10までの範囲の乱数</span>
    <span class="kw">auto</span> r = d(e) ;
}</code></pre></div>
<p>値の範囲には負数も使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uniform_int_distribution d( <span class="dv">-3</span>, <span class="dv">3</span> ) ;</code></pre></div>
<p>この分布は、<span class="math inline">\(-3\)</span>, <span class="math inline">\(-2\)</span>, <span class="math inline">\(-1\)</span>, 0, 1, 2, 3のいずれかをそれぞれ<span class="math inline">\(\frac{1}{7}\)</span>の等しい確率で返す。</p>
<h3 id="浮動小数点数の一様分布uniform_real_distributionrealtype">浮動小数点数の一様分布(<code>uniform_real_distribution&lt;RealType&gt;</code>)</h3>
<p><code>uniform_real_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x\)</span>, <span class="math inline">\(a \leq x &lt; b\)</span>を以下の定数確率密度関数に従って分布させる。</p>
<p><span class="math display">\[
p(x\,|\,a,b) = 1 / (b - a) \text{ .}
\]</span></p>
<p><code>a == b</code>のときは未定義となる。</p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::uniform_real_distribution&lt;RealType&gt; d( a, b ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>、<code>a</code>は最小値、<code>b</code>は最大値。値の範囲は<span class="math inline">\(a \leq b\)</span> かつ <span class="math inline">\(b - a \leq \text{`RealType`型の最大値}\)</span>。</p>
<p>エンジンも含めた使い方は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">void</span> f( Engine &amp; e )
{
    std::uniform_real_distribution d(<span class="fl">0.0</span>, <span class="fl">1.0</span> ) ;
    d.a() ; <span class="co">// 0.0</span>
    d.b() ; <span class="co">// 1.0</span>

    <span class="co">// 0.0から1.0までの範囲の乱数</span>
    <span class="kw">auto</span> r = d(e) ;
}</code></pre></div>
<p>浮動小数点数の難しいところは、整数と違って値の範囲の状態が多いことだ。例えば<code>0.0</code>と<code>1.0</code>の間には<code>0.5</code>もあるし、<code>0.01</code>もあるし<code>0.001</code>もある。浮動小数点数の実装が表現できる状態はとても多い。<code>uniform_real_distribution</code>は指定された値の範囲で浮動小数点数が表現できるすべての値のうちから乱数を生成してくれる。そのため読者は難しいことを考える必要はない。</p>
<h2 id="ベルヌーイ分布bernoulli-distributions">ベルヌーイ分布(Bernoulli distributions)</h2>
<p>ベルヌーイ分布(bernoulli distribution)とは、ベルヌーイ試行(bernoulli trial)に関する分布だ。</p>
<p>ベルヌーイとは数学者ヤコブ・ベルヌーイ(Jacob Bernoulli, 1655-1705)に由来する。ヤコブ・ベルヌーイは西洋数学史上、ジェロラモ・カルダーノ(Gerolamo Cardano, 1501-1576)に続く二人目の、数学的に乱数をまともに文章に書き残した数学者で、現在の統計の基礎を切り開いた人物だ。西洋数学史において乱数と統計の研究は遅れた。この理由は主に宗教的なもので、運命とは神の決定したもうことであり、人の子の及ぶところではないとする考え方が一般的だった。そのため、まともな数学者は乱数を研究しなかった。ヤコブ・ベルヌーイの乱数に関する論文も、けっきょく本人は完成させることができず、論文完成に息子が着手しようとするも、これまた乱数はまともな数学者の取り組むべきところではないという周囲の圧力のために断念するなどの興味深い歴史がある。</p>
<h3 id="ベルヌーイ試行">ベルヌーイ試行</h3>
<p>ベルヌーイ試行とは、独立した試行で結果が2種類のものだ。</p>
<p>「独立した試行」というのは、試行結果が前回の試行に影響されないことをいう。例えばコイントスの結果は表と裏だが、前回のコイントスの結果は今回のコイントスに影響しない。</p>
<p>結果が2種類というのは、試行をした結果、2種類の結果のうちのどちらか一方が出ることを言う。成功/失敗、表/裏、勝ち/負け、<code>true</code>/<code>false</code>など、なんでもいい。数学的には成功/失敗を使うが、C++では<code>true</code>/<code>false</code>で表現する。</p>
<p>ベルヌーイ試行において、確率<span class="math inline">\(p\)</span>が成功する確率である場合、確率<span class="math inline">\(q=1-p\)</span>が失敗の確率だ。</p>
<ul>
<li><span class="math inline">\(p=1\)</span>の場合、必ず成功する。失敗しない</li>
<li><span class="math inline">\(p=0\)</span>の場合、必ず失敗する。成功しない</li>
<li><span class="math inline">\(p=0.5\)</span>の場合、成功と失敗は同じ確率になる</li>
<li><span class="math inline">\(p=0.4\)</span>の場合、<span class="math inline">\(\frac{2}{5}\)</span>の確率で成功し、<span class="math inline">\(\frac{3}{5}\)</span>の確率で失敗する</li>
</ul>
<p>具体的なベルヌーイ試行の例を挙げると、</p>
<ul>
<li>コイントスの結果、表か、裏か</li>
<li>6面ダイスを振って6が出るか、6以外が出るか</li>
<li>6面ダイスを振って5,6が出るか、1,2,3,4が出るか</li>
<li>確率1%で当たるくじ引きの結果がアタリか、ハズレか</li>
<li>赤玉と白玉が多数入ったツボの中身をよくかき混ぜ、玉を1つだけ取り出し、戻す。引いた玉の色が赤か、白か</li>
</ul>
<p>このような結果を2種類に分けることができ、そのうちのどちらか一方だけが結果として出る、かつ1回1回が独立した試行をベルヌーイ試行と呼ぶ。</p>
<p>ベルヌーイ分布を使うと、一様分布ではない2値(<code>true</code>/<code>false</code>)の確率的な結果について乱数で得ることができる。例えば、ビデオゲームで宝箱を開けると32%の確率でアイテムが入っており、68%の確率で空っぽであるとする。これを一様分布で実装すると、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宝箱にアイテムが入っている場合trueを返す</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">bool</span> open_chest( Engine &amp; e )
{
    <span class="co">// 1から100までの整数の乱数を生成する</span>
    std::uniform_int_distribution d(<span class="dv">1</span>, <span class="dv">100</span>) ;
    <span class="co">// 32以下ならアイテムが入っている</span>
    <span class="co">// 33以上ならば空っぽ</span>
    <span class="kw">return</span> d(e) &lt;= <span class="dv">32</span> ;
}</code></pre></div>
<p>このようなコードを書くのは間違いの元だ。確率32%というのは<code>32.0/100.0</code>という<code>double</code>型の値で表現できる。この値だけ指定して、残りはライブラリに任せたい。そのようなときに使うのがベルヌーイ分布だ。</p>
<h3 id="ベルヌーイ分布stdbernoulli_distribution">ベルヌーイ分布(std::bernoulli_distribution)</h3>
<p>ベルヌーイ分布(bernoulli distribution)は1回のベルヌーイ試行の結果を乱数として返す。</p>
<p><code>std::bernoulli_distribution</code>は<code>bool</code>型の乱数<span class="math inline">\(b\)</span>を以下の離散確率関数に従って分布する。</p>
<p><span class="math display">\[
  P(b\,|\,p) = \left\{ \begin{array}{ll}
                          p     &amp; \text{ if $b = true$, or} \\
                          1 - p &amp; \text{ if $b = false$.}
                          \end{array}\right.
\]</span></p>
<p>確率<span class="math inline">\(p\)</span>で<code>true</code>が、確率<span class="math inline">\(1-p\)</span>で<code>false</code>が返る。</p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::bernoulli_distribution d( p ) ;</code></pre></div>
<p><code>p</code>は<code>double</code>型で、値の範囲は<span class="math inline">\(0 \leq p \leq 1\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::bernoulli_distribution d( <span class="fl">0.5</span> ) ;
    d.p() ; <span class="co">// 0.5 ;</span>

    std::mt19937 e ;
    <span class="co">// 乱数生成</span>
    d(e) ;
}</code></pre></div>
<p><code>bernoulli_distribution</code>はテンプレートクラスではない。生成する乱数の型は<code>bool</code>だ。<code>p</code>は<code>double</code>型で確率<span class="math inline">\(p\)</span>のことだ。値の範囲は<span class="math inline">\(0 \leq p \leq 1\)</span>。</p>
<p>例えば前述の32%の確率でアイテムが入っている宝箱を実装するには以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">bool</span> open_chest( Engine &amp; e )
{
    std::bernoulli_distribution d( <span class="fl">32.0</span> / <span class="fl">100.0</span> )
    <span class="kw">return</span> d(e) ;
} </code></pre></div>
<p>この関数<code>open_chest</code>は確率32%で<code>true</code>を、確率68%で<code>false</code>を返す。</p>
<p>本当にそうだろうか。確かめてみよう。</p>
<p>32%の確率で<code>true</code>になり、68%の確率で<code>false</code>になっているかどうかを確かめるには、大量の乱数を生成して<code>true</code>/<code>false</code>をカウントし、それぞれ乱数を生成した数で割って割合を見ればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 試行回数</span>
    <span class="dt">const</span> <span class="dt">int</span> trial_count = <span class="dv">100</span> ;

    std::mt19937 e ;
    std::bernoulli_distribution d( <span class="fl">32.0</span> / <span class="fl">100.0</span> ) ;

    std::array&lt;<span class="dt">int</span>, <span class="dv">2</span>&gt; result{} ;
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != trial_count ; ++i )
        <span class="co">// boolからintへの変換は</span>
        <span class="co">// falseが0, trueが1</span>
        ++result[ d(e) ] ;

    std::cout &lt;&lt; <span class="st">&quot;false: &quot;</span>sv &lt;&lt; <span class="dt">double</span>(result[<span class="dv">0</span>]) / <span class="dt">double</span>(trial_count) * <span class="fl">100.0</span> &lt;&lt; <span class="st">&quot;%</span><span class="ch">\n</span><span class="st">&quot;</span>sv
        &lt;&lt; <span class="st">&quot;true : &quot;</span>sv &lt;&lt; <span class="dt">double</span>(result[<span class="dv">1</span>]) / <span class="dt">double</span>(trial_count) * <span class="fl">100.0</span> &lt;&lt; <span class="st">&quot;%</span><span class="ch">\n</span><span class="st">&quot;</span>sv ;
}</code></pre></div>
<p>これを実行してみると、筆者の環境では、</p>
<pre><code>false: 72%
true : 28%</code></pre>
<p>と出力された。少し違う。乱数なので試行回数が少なすぎる場合は、大きく偏ることもある。では試行回数を増やしてみよう。変数<code>trial_count</code>が試行回数だ。</p>
<p>200回試行すると、</p>
<pre><code>false: 72.5%
true : 27.5%</code></pre>
<p>まだダメだ。1000回試行してみよう。</p>
<pre><code>false: 68.5%
true : 31.5%</code></pre>
<p>だいぶ近くなった。</p>
<p>ちなみに、このままどんどん1万回、10万回と試行回数を増やしていっても、精度はそれほど上がらない。このことはヤコブ・ベルヌーイの研究と関わってくる。</p>
<p><code>std::bernoulli_distribution</code>のコンストラクターに与える<code>double</code>型の確率<code>p</code>の範囲は<span class="math inline">\(0.0 \leq p \leq 1.0\)</span>だ。</p>
<p><span class="math inline">\(p=1.0\)</span>ならば常に<code>true</code>, <span class="math inline">\(p=0.0\)</span>なら常に<code>false</code>、<span class="math inline">\(p=0.5\)</span>ならば<code>true/false</code>が一様分布する。</p>
<h3 id="二項分布stdbinomial_distributioninttype">二項分布(<code>std::binomial_distribution&lt;IntType&gt;</code>)</h3>
<p>二項分布(binomial distribution)は確率<span class="math inline">\(p\)</span>で成功するベルヌーイ試行を<span class="math inline">\(t\)</span>回行ったときに成功した回数<span class="math inline">\(i\)</span>を乱数として返す。</p>
<p>具体的に例えると、100回コイントスをした結果出た表の数だ。コイントスは表と裏とそれぞれ 50%ずつの確率で出す。表を成功(<code>true</code>)とすると、つまり、<span class="math inline">\(p=0.5\)</span>のベルヌーイ試行だ。100回コイントスをするというのは<span class="math inline">\(t=100\)</span>だ。つまり、100回コイントスをした結果出た表の数というのは、100回ベルヌーイ試行した結果の成功数になる。この結果は、期待値としては50だが、ここで生成するのは乱数なので、50回出るわけではない。運が悪ければ1回も表が出ないこともあり得る。</p>
<p>6面ダイスを60回振った結果出た1の目の回数もそうだ。この場合、<span class="math inline">\(p=\frac{1}{6}\)</span>のベルヌーイ試行を<span class="math inline">\(t=60\)</span>回行うことになる。期待値は<span class="math inline">\(10\)</span>だ。成功を2,3の目が出た回数と考えることもできる。この場合期待値は<span class="math inline">\(20\)</span>だ。</p>
<p>確率1%で当たるくじを100回引いた場合もそうだ。この場合、<span class="math inline">\(p=0.01\)</span>で<span class="math inline">\(t=100\)</span>になる。期待値は<span class="math inline">\(1\)</span>なので、1回当たることが平均的に期待できる。ちなみに、実際に100回くじ引きをして1回でも当たる確率は約63%だ。</p>
<p><code>std::binomial_distribution&lt;IntType&gt;</code>は<code>IntType</code>型の乱数<span class="math inline">\(i \geq 0\)</span>を以下の離散確率関数に従って分布する。</p>
<p><span class="math display">\[
P(i\,|\,t,p) = \binom{t}{i} \cdot p^i \cdot (1-p)^{t-i} \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::binomial_distribution&lt;IntType&gt; d( t, p ) ;</code></pre></div>
<p><code>IntType</code>は整数型でデフォルトは<code>int</code>だ。<code>t</code>は<code>IntType</code>型の整数値で、値の範囲は<span class="math inline">\(0 \leq t\)</span>だ。<code>p</code>は<code>double</code>型の値で確率を指定する。<code>p</code>の値の範囲は<span class="math inline">\(0 \leq p \leq 1\)</span>だ。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::binomial_distribution d( <span class="dv">1</span>, <span class="fl">0.5</span> ) ;
    d.t() ; <span class="co">// 1</span>
    d.p() ; <span class="co">// 0.5</span>

    std::mt19937 e ;
    <span class="co">// 乱数生成</span>
    d(e) ;
}</code></pre></div>
<p>100回コイントスをした結果、表が出た回数を乱数で得る関数<code>coinflips100</code>は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> coinflips100( Engine &amp; e )
{
    <span class="co">// t == 100, p == 0.5</span>
    std::binomial_distribution d( <span class="dv">100</span>, <span class="fl">0.5</span> ) ;
    <span class="kw">return</span> d(e) ;
}</code></pre></div>
<p>100回のベルヌーイ試行をするので<span class="math inline">\(t=100\)</span>で、ベルヌーイ試行の成功確率は<span class="math inline">\(p=\frac{1}{2}=0.5\)</span>になる。</p>
<p>これを10回ぐらい呼んでみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e ;
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
        std::cout &lt;&lt; coinflips100( e ) &lt;&lt; <span class="st">&quot;, &quot;</span>sv ;
}</code></pre></div>
<p>筆者の環境では結果は以下のようになった。</p>
<pre><code>53, 54, 43, 56, 51, 50, 45, 48, 49, 47, </code></pre>
<p>期待値は50なので、50前後の乱数が出やすい。</p>
<p>6面ダイスを60回振った結果出た1の目の合計を乱数で返す関数<code>roll_for_one</code>は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> roll_for_one( Engine &amp; e )
{
    <span class="co">// t == 60, p == 1.0/ 6.0</span>
    std::binomial_distribution d( <span class="dv">60</span>, <span class="fl">1.0</span> / <span class="fl">6.0</span> ) ;
    <span class="kw">return</span> d(e) ;
}</code></pre></div>
<p>60回のベルヌーイ試行をするので<span class="math inline">\(t=60\)</span>で、ベルヌーイ試行の確率は6面ダイスの1の目が出る確率なので、<span class="math inline">\(p=\frac{1}{6}\)</span>になる。</p>
<p>確率1%で当たるくじを100回引いた結果アタリの回数を返す関数<code>lootbox</code>は以下のように実装できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> lootbox( Engine &amp; e )
{
    <span class="co">// t == 100, p = 0.01</span>
    std::binomial_distribution d( <span class="dv">100</span>, <span class="fl">1.0</span> / <span class="fl">100.0</span> ) ;
    <span class="kw">return</span> d(e) ;
}</code></pre></div>
<p>この関数を10回呼び出してみると結果は以下のようになる。</p>
<pre><code>1, 0, 2, 1, 0, 0, 0, 0, 1, 3,</code></pre>
<p>確率1%で当たるくじを100回引くと、複数回当たることもあれば、1回も当たらないこともある。期待値は1だが、期待値というのは平均的に期待できる結果でしかない。読者諸君もくじ引きをするときは確率に気を付けよう。たとえくじが毎回公平であったとしても、確率は無記憶性なのだ。「もう90回くじを引いたからあと10回引けば当たるはず」という考え方は通用しない。</p>
<h3 id="幾何分布stdgeometric_distribution">幾何分布(std::geometric_distribution<IntType>)</h3>
<p>幾何分布(geometric distribution)とは、確率<span class="math inline">\(p\)</span>で成功するベルヌーイ試行を初めて成功するまで行った回数を乱数として分布する。</p>
<p>具体的な例で例えると、</p>
<ul>
<li>コイントスを表が出るまで行った回数</li>
<li>6面ダイスを1の目が出るまで振った回数</li>
<li>確率1%で当たるくじ引きをアタリが出るまで引いた回数</li>
</ul>
<p>コイントスの例で考えよう。コイントス1回をベルヌーイ試行とし、成功を表とする。表が出るまでコイントスをしてみよう。コイントスを何回する必要があるだろうか。運がよければ1回で表が出るので1回だ。運が悪ければ、5回コイントスをしても全部裏なこともあるだろう。100回コイントスをして表が一度も出ないことは、確率的にはあり得る。ただしその確率は<span class="math inline">\(\frac{1}{2^{100}}\)</span>なので、およそあり得ない確率ではある。</p>
<p><code>std::geometric_distribution&lt;IntType&gt;</code>は<code>IntType</code>型の乱数<span class="math inline">\(i\)</span>, <span class="math inline">\(i \geq 0\)</span>を以下の離散確率関数に従って分布する。</p>
<p><span class="math display">\[
P(i\,|\,p) = p \cdot (1-p)^{i} \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::geometric_distribution&lt;IntType&gt; d( p ) ;</code></pre></div>
<p><code>IntType</code>は整数型でデフォルトは<code>int</code>、<code>p</code>は確率で値の範囲は<span class="math inline">\(0 &lt; p &lt; 1\)</span>だ。<code>p</code>の値の範囲に注意すること。0と1であってはならない。幾何分布は成功するまでベルヌーイ試行した回数を返すので、<span class="math inline">\(p=0\)</span>の場合、必ず失敗するベルヌーイ試行になり意味がない。<span class="math inline">\(p=1\)</span>のときは必ず成功するベルヌーイ試行であり、やはり意味がない。</p>
<p><code>geometric_distribution</code>の生成する乱数の範囲にも注意が必要だ。生成される乱数<span class="math inline">\(i\)</span>の範囲は<span class="math inline">\(i \geq 0\)</span>だ。0もあり得る。0ということは、最初のベルヌーイ試行が成功したということだ。1は2回目のベルヌーイ試行が成功したということだ。幾何分布はベルヌーイ試行が初めて成功するまでのベルヌーイ試行の回数を返すので、成功したベルヌーイ試行は回数に含めない。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// p == 0.5</span>
    std::geometric_distribution d( <span class="fl">0.5</span> ) ;
    d.p() ; <span class="co">// 0.5 ;</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<p>コイントスを表が出るまで繰り返し、その合計回数を乱数で返す関数<code>try_coinflips</code>を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> try_coinflips( Engine &amp; e )
{
    std::geometric_distribution d( <span class="fl">0.5</span> ) ;
    <span class="kw">return</span> d(e) + <span class="dv">1</span>;
}</code></pre></div>
<p>最後に<code>+1</code>しているのは、この文脈では表を出したときのコイントスも数えるからだ。つまり成功したベルヌーイ試行も回数に数えるので、幾何分布の生成する乱数より1多い数になる。</p>
<p>10回呼び出してみたところ、以下のような戻り値を返した。</p>
<pre><code>1, 3, 6, 1, 1, 2, 1, 8, 9, 5, </code></pre>
<p>運がよければ1回で表が出るが、運が悪ければ9回かかる。もちろんもっとかかる可能性もある。</p>
<p>6面ダイスを1の目が出るまで振り、その合計回数を返す関数<code>try_rolls</code>を書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> try_rolls( Engine &amp; e )
{
    std::geometric_distribution d( <span class="fl">1.0</span> / <span class="fl">6.0</span> ) ;
    <span class="kw">return</span> d(e) + <span class="dv">1</span>;
}</code></pre></div>
<p>これも10回呼び出してみると筆者の環境では以下のようになった。</p>
<pre><code>1, 10, 20, 2, 3, 5, 2, 28, 31, 19, </code></pre>
<p>6面ダイスを振ると、運がよければ1回で1の目が出るが、運が悪いと何十回も振る必要がある。</p>
<p>確率1%のくじを初めて当たるまで引き続け、くじを引いた回数を返す関数<code>try_lootboxes</code>も書いてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">unsigned</span> <span class="dt">int</span> try_lootboxes( Engine &amp; e )
{
    std::geometric_distribution d( <span class="fl">1.0</span> / <span class="fl">100.0</span> ) ;
    <span class="kw">return</span> d(e) + <span class="dv">1</span>;
}</code></pre></div>
<p>10回呼び出してみよう。</p>
<pre><code>15, 180, 346, 25, 37, 79, 21, 493, 562, 342,</code></pre>
<p>確率1%のくじを当てるには、運が悪いと何百回も引かなければならない。</p>
<h3 id="負の二項分布stdnegative_binomial_distribution">負の二項分布(std::negative_binomial_distribution<IntType>)</h3>
<p>負の二項分布(negative binomial distribution)は幾何分布に似ている。幾何分布がベルヌーイ試行が1回成功するまでに行ったベルヌーイ試行の回数を乱数として分布するのに対し、負の二項分布はベルヌーイ試行が<span class="math inline">\(k\)</span>回成功するまでに行ったベルヌーイ試行の回数を乱数として分布する。</p>
<p>負の二項分布を具体的な例で考えよう。</p>
<ul>
<li>コイントスを、10回、表が出るまで行った回数</li>
<li>6面ダイスを、10回、1の目が出るまで振った回数</li>
<li>確率1%で当たるくじ引きを、10回、アタリが出るまで引いた回数</li>
</ul>
<p>幾何分布は負の二項分布で表現することもできる。</p>
<ul>
<li>コイントスを、1回、表が出るまで行った回数</li>
<li>6面ダイスを、1回、1の目が出るまで振った回数</li>
<li>確率1%で当たるくじ引きを、1回、アタリが出るまで引いた回数</li>
</ul>
<p><code>std::negative_binomial_distribution&lt;IntType&gt;</code>は<code>IntType</code>型の乱数<span class="math inline">\(i\)</span>, <span class="math inline">\(i \geq 0\)</span>を以下の離散確率関数に従って分布する。</p>
<p><span class="math display">\[
P(i\,|\,k,p) = \binom{k+i-1}{i} \cdot p^k \cdot (1-p)^i \text{ .} 
\]</span></p>
<p><span class="math inline">\(p = 1\)</span>のときの<span class="math inline">\(P(i\,|\,k,p)\)</span>は未定義だ。</p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::negative_binomial_distribution&lt;IntType&gt; d( k, p ) ;</code></pre></div>
<p><code>IntType</code>は整数型でデフォルトは<code>int</code>、<code>k</code>は<code>IntType</code>型の値<span class="math inline">\(0 &lt; k\)</span>で成功させるベルヌーイ試行の回数、<code>p</code>は<code>double</code>型の確率<span class="math inline">\(- &lt; p \leq 1\)</span>だ。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// k == 1, p == 0.5</span>
    std::negative_binomial_distribution d( <span class="dv">1</span>, <span class="fl">0.5</span> ) ;
    d.k() ; <span class="co">// 1</span>
    d.p() ; <span class="co">// 0.5</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<p>幾何分布と同じく、負の二項分布が生成する乱数<code>i</code>は<code>k</code>回のベルヌーイ試行を成功させるまでに失敗したベルヌーイ試行の数を返す。</p>
<p>例えば、コイントスで10回表が出るまでに失敗したコイントスの数を返す。コイントスがベルヌーイ試行で、表が成功だ。成功したベルヌーイ試行の数は返さない。そのため、結果の乱数は10以下、時には0であることもあり得る。0というのは10回コイントスをしたらすべて表になったので1回もベルヌーイ試行が失敗しなかった場合だ。</p>
<p>コイントスを10回表が出るまでに行ったコイントスの回数を返す関数<code>count_10_coinflips</code>は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10回表が出るまでに行ったコイントスの数</span>
<span class="co">// 表が出たコイントスも含める</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> count_10_coinflips( Engine &amp; e )
{
    std::negative_binomial_distribution d( <span class="dv">10</span>, <span class="fl">0.5</span> ) ;
    <span class="kw">return</span> d(e) + <span class="dv">10</span> ;
}</code></pre></div>
<p>最後に<code>+10</code>しているのは、この関数は成功も含めたコイントスの回数を返すからだ。10回表が出るまでに失敗した、つまり裏になったコイントス回数がほしければ、そのままの値を使えばいい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 10回表が出るまでに行った失敗したコイントスの数</span>
<span class="co">// 表が出たコイントスは含めない</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> count_failed_coinflips_until_10_heads( Engine &amp; e )
{
    std::negative_binomial_distribution d( <span class="dv">10</span>, <span class="fl">0.5</span> ) ;
    <span class="kw">return</span> d(e) ;
}</code></pre></div>
<p>参考までに、<code>n</code>回表が出るまでに行ったコイントスの回数を乱数で返す関数<code>count_n_coinflips</code>は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> count_n_coinflips( <span class="dt">unsigned</span> <span class="dt">int</span> n, Engine &amp; e )
{
    std::negative_binomial_distribution d( n, <span class="fl">0.5</span> ) ;
    <span class="kw">return</span> d(e) + n ;
}</code></pre></div>
<p>6面ダイスを10回、1の目が出るまで振った回数を乱数で返す関数<code>count_10_rolls</code>は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> count_10_rolls( Engine &amp; e )
{
    std::negative_binomial_distribution d( <span class="dv">10</span>, <span class="fl">1.0</span>/<span class="fl">6.0</span> ) ;
    <span class="kw">return</span> d(e) + <span class="dv">10</span> ;
}</code></pre></div>
<p>確率1%のくじを10回当てるまでくじを引いた回数を返す関数<code>count_10_lootboxes</code>は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> count_10_lootboxes( Engine &amp; e )
{
    std::negative_binomial_distribution d( <span class="dv">10</span>, <span class="fl">0.01</span> ) ;
    <span class="kw">return</span> d(e) + <span class="dv">10</span> ;
}</code></pre></div>
<h2 id="ポアソン分布">ポアソン分布</h2>
<p>ポアソン分布(Poisson distribution)とは、シメオン・ドニ・ポアソン（Siméon Denis Poisson 1781-1840）が1837年に発表した論文、「刑事民事の判決における確率の調査」で初めて公開されたものだ。この論文でポアソンは、ある国における冤罪の数について、ある時間間隔における冤罪の発生数を乱数とし、そのような乱数の分布について考察した。その結果がポアソン分布だ。</p>
<p>ある時間間隔に発生する離散的な事象の多くがポアソン分布に従う。例えば以下は具体的な例だ。</p>
<ul>
<li>1年間に発生する冤罪の数</li>
<li>1ヶ月に発生する交通事故の数</li>
<li>1年間で地球に飛来する隕石の数</li>
<li>1時間である放射性同位体が放射性崩壊する回数</li>
</ul>
<p>冤罪や交通事故の発生件数は乱数ではないように考えるかもしれない。しかし、結果的にみれば乱数のように振る舞っている。1ヶ月に発生する交通事故が10件であったとする。これは平均すると約3日に1回交通事故が起こっていることになるが、実際に3日に1回交通事故が起こったわけではない。交通事故の発生は離散的で、1日に複数件起こることもあれば、1週間無事故のときもある。なので3日に1回交通規制を敷いても交通事故を防ぐことはできない。</p>
<p>ポアソン分布に従う乱数の特徴としてもう1つ、無記憶性というものがある。3日間に1件の割合で交通事故が起こっているとしよう。その場合、常にいまから3日以内に1件の交通事故が起きることが期待できるだけであって、3日以内に必ず起こるわけではない。そして、2日待ったから明日交通事故が起こるというわけでもない。交通事故が起こる確率は常にいまから3日間につき1件だ。ポアソン分布は無記憶性なので、すでに2日間待っているという過去は未来に影響しない。</p>
<p>具体的なC++ライブラリのポアソン分布の使い方としては、ある所定の時間に平均して起こる事象の回数<code>mean</code>を指定すると、その所定の時間に起こった事象が乱数で返される。</p>
<h3 id="ポアソン分布poisson_distribution">ポアソン分布(poisson_distribution<T>)</h3>
<p>ポアソン分布の<code>std::poisson_distribution&lt;T&gt;</code>は整数型<code>T</code>の乱数<span class="math inline">\(i\)</span>, <span class="math inline">\(i \geq 0\)</span>を以下の離散確率関数に従って分布する。</p>
<p><span class="math display">\[
P(i\,|\,\mu) = \frac{e^{-\mu} \mu^{i}}{i\,!} \text{ .}
\]</span></p>
<p>ここで<span class="math inline">\(\mu\)</span>を<code>mean</code>とする。<span class="math inline">\(\mu &gt; 0\)</span>ではない場合未定義だ。</p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::poisson_distribution&lt;T&gt; d( mean ) ;</code></pre></div>
<p><code>T</code>は整数型でデフォルトは<code>int</code>、<code>mean</code>は<code>RealType</code>型。<span class="math inline">\(\mu\)</span>と同じで浮動小数点数型の値で所定の時間に平均して発生する事象の回数だ。値の範囲は<span class="math inline">\(0 &lt; \text{mean}\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::poisson_distribution d( <span class="fl">1.0</span> ) ;
    d.mean() ; <span class="co">// 1.0</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<p>ポアソン分布が生成する乱数は0以上の事象が発生した回数となる。</p>
<p>例えば、1ヶ月に交通事故が平均して10件発生するとする。1ヶ月に発生した交通事故の件数は平均が10件になるように増減するはずだ。1ヶ月の交通事故の発生件数を乱数で返す関数<code>traffic_accidents</code>は以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> traffic_accidents( Engine &amp; e )
{
    std::poisson_distribution d(<span class="fl">10.0</span>) ;
    <span class="kw">return</span> d(e) ;
}</code></pre></div>
<p>これを10回呼び出すと以下のような乱数列が生成された。</p>
<pre><code>14, 6, 11, 8, 8, 14, 7, 16, 12, 17, </code></pre>
<p>だいぶばらつきがある。ポアソン分布とはこういうものだ。離散的に起こる事象を乱数として取ると、このようにばらつく。現実でも、1ヶ月に交通事故が平均して10件起きている場合、20件起きる月や無事故の月が存在する可能性があるのだ。</p>
<p>これを合計すると113となり、10で割って平均を取ると、10.0に近い値になる。もっと多くの乱数を生成して平均を取るとより近くなる。</p>
<h3 id="指数分布stdexponential_distributionrealtype">指数分布(<code>std::exponential_distribution&lt;RealType&gt;</code>)</h3>
<p>指数分布(exponential distribution)とは、ポアソン分布に従う事象が起こる時間間隔の分布だ。</p>
<p>ポアソン分布がある時間間隔における事象の発生回数の分布であることを思い出そう。</p>
<p>ポアソン分布による乱数は例えば、</p>
<ul>
<li>1ヶ月に平均して10件発生する交通事故がある1ヶ月に発生した件数</li>
</ul>
<p>が乱数だった。1ヶ月が時間間隔で、交通事故が事象だ。10件が平均だ。</p>
<p>抽象的に書くと、</p>
<ul>
<li>時間間隔に平均して<span class="math inline">\(N\)</span>回発生する事象があるとき、ある時間間隔における事象発生の回数</li>
</ul>
<p>の分布だ。</p>
<p>指数分布では具体的には以下のようになる。</p>
<ul>
<li>1ヶ月に平均して10件発生する交通事故が発生してから、次の交通事故が発生するまでの時間間隔</li>
</ul>
<p>ポアソン分布に従う離散的な事象のある時間間隔における平均の発生回数が与えられているとする。例えば上の場合、交通事故が事象で、「1ヶ月」が時間間隔で、「平均して10件」が平均の発生回数だ。平均して約3日に1件ほど発生していることになる。ところでいままさに交通事故が発生したとする。このとき、次の交通事故が発生するまでの時間間隔はどのくらいだろうか。平均すると約3日に1件だが、交通事故は離散的な事象なので、1時間後にまた起きるかもしれないし、1週間交通事故が起こらないかもしれない。長期的に統計を取ると月に平均して10件発生している場合、次の交通事故が発生するまでの時間間隔を集計して平均すると約3日に1件発生する確率になる。</p>
<p>指数分布が扱うのはこの次の交通事故が発生するまでの時間間隔だ。抽象的にもう一度書くと、ポアソン分布に従う離散的な事象の平均回数が与えられている場合に、ある事象から次の事象が発生するまでの時間間隔を分布する。</p>
<p><code>std::exponential_distribution&lt;RealType&gt;</code>は浮動小数点型<code>RealType</code>の乱数<span class="math inline">\(x \geq 0\)</span>を以下の確率密度関数に従って分布させる。</p>
<p><span class="math display">\[
p(x\,|\,\lambda) = \lambda e^{-\lambda x} \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::exponential_distribution&lt;RealType&gt; d( lambda ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>、<code>lambda</code>は<code>RealType</code>型。ポアソン分布の<code>mean</code>と同じで、ある時間間隔における事象の発生回数だ。値の範囲は<span class="math inline">\(0 &lt; \text{lambda}\)</span>。</p>
<p><code>std::exponential_distribution</code>の生成する乱数は<code>1.0</code>のとき、ある時間間隔に等しくなる。<code>0.5</code>なら半分の時間間隔、<code>2.0</code>なら2倍の時間間隔だ。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::exponential_distribution d( <span class="fl">1.0</span> ) ;
    d.lambda() ; <span class="co">// 1.0 ;</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<p>1ヶ月に10件の交通事故がポアソン分布に従って発生する場合に、ある交通事故から次の交通事故までの時間間隔の乱数を日数で得る関数<code>until_next_traffic_accident</code>は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="kw">auto</span> until_next_traffic_accident( Engine &amp; e )
{
    std::exponential_distribution d(<span class="fl">10.0</span>) ;
    <span class="kw">return</span> d(e) * <span class="fl">30.0</span> ;
}</code></pre></div>
<p>ある時間間隔に10回起こるので、<code>lambda</code>には<code>10.0</code>を指定する。ここでは簡単のために1ヶ月を30日とする。結果の乱数は1.0がある時間間隔に等しいので、つまり1.0は30日に等しい。結果に<code>30.0</code>を掛けることで日数を計算する。</p>
<p>この関数を10回呼び出すと以下のようになった。</p>
<pre><code>0.436732, 5.40559, 10.4085, 0.749364, 1.10523, 2.37705, 0.626176, 14.8351, 16.932, 10.2976,</code></pre>
<p>早いときは1日も立たずして次の交通事故が起きるが、遅いときは10日を超えてもなかなか交通事故が起きない。平均すると3日に1件交通事故が起きる確率の乱数が生成される。</p>
<h3 id="ガンマ分布stdgamma_distributionrealtype">ガンマ分布(<code>std::gamma_distribution&lt;RealType&gt;</code>)</h3>
<p><code>std::gamma_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x &gt; 0\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
 p(x\,|\,\alpha,\beta) =
     \frac{e^{-x/\beta}}{\beta^{\alpha} \cdot \Gamma(\alpha)} \, \cdot \, x^{\, \alpha-1}
     \text{ .} 
\]</span></p>
<p><span class="math inline">\(\alpha\)</span>を<code>alpha</code>、<span class="math inline">\(\beta\)</span>を<code>beta</code>とする。</p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::gamma_distribution&lt;RealType&gt; d( alpha, beta ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>alpha</code>, <code>beta</code>は<code>RealType</code>型。値の範囲は<span class="math inline">\(0 &lt; alpha\)</span>, <span class="math inline">\(0 &lt; beta\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::gamma_distribution d( <span class="fl">1.0</span>, <span class="fl">1.0</span> ) ;
    d.alpha() ; <span class="co">// 1.0</span>
    d.beta() ; <span class="co">// 1.0</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<h3 id="ウェイブル分布stdweibull_distributionrealtype">ウェイブル分布(<code>std::weibull_distribution&lt;RealType&gt;</code>)</h3>
<p><code>std::weibull_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x &gt; 0\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x\,|\,a,b) = \frac{a}{b}
     \cdot \left(\frac{x}{b}\right)^{a-1}
     \cdot \, \exp\left( -\left(\frac{x}{b}\right)^a\right)
     \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::weibull_distribution&lt;RealType&gt; d( a, b ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>a</code>, <code>b</code>は<code>RealType</code>型。値の範囲は<span class="math inline">\(0 &lt; a\)</span>, <span class="math inline">\(0 &lt; b\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::weibull_distribution d( <span class="fl">1.0</span>, <span class="fl">1.0</span> ) ;
    d.a() ; <span class="co">// 1.0</span>
    d.b() ; <span class="co">// 1.0</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<h2 id="極値分布stdextreme_value_distributionrealtype">極値分布(<code>std::extreme_value_distribution&lt;RealType&gt;</code>)</h2>
<p><code>std::extreme_value_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x\,|\,a,b) = \frac{1}{b}
     \cdot \exp\left(\frac{a-x}{b} - \exp\left(\frac{a-x}{b}\right)\right)
     \text{ .}
\]</span></p>
<p>極値分布(extreme value distribution)は、ガンベルI型(Gumbel Type I)、対数ウェイブル(log-Weibull)、フィッシャー＝ティペットI型(Fisher-Tippett Type I)という名前の分布と呼ばれることもある。</p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::extreme_value_distribution&lt;RealType&gt; d( a, b ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>a</code>, <code>b</code>は<code>RealType</code>型。値の範囲は<span class="math inline">\(0 &lt; b\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::extreme_value_distribution d( <span class="fl">1.0</span>, <span class="fl">1.0</span> ) ;
    d.a() ; <span class="co">// 1.0</span>
    d.b() ; <span class="co">// 1.0</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<h2 id="正規分布">正規分布</h2>
<h3 id="正規分布stdnormal_distributionrealtype">正規分布(<code>std::normal_distribution&lt;RealType&gt;</code>)</h3>
<p><code>std::normal_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
 (x\,|\,\mu,\sigma)
      = \frac{1}{\sigma \sqrt{2\pi}}
        \cdot
        % e^{-(x-\mu)^2 / (2\sigma^2)}
        \exp{\left(- \, \frac{(x - \mu)^2}
                             {2 \sigma^2}
             \right)
            }
 \text{ .}
\]</span></p>
<p>分布パラメーターのうちの<span class="math inline">\(\mu\)</span>と<span class="math inline">\(\sigma\)</span>は、それぞれ分布の平均(mean)、標準偏差(standard deviation)とも呼ばれている。</p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::normal_distribution&lt;RealType&gt; d( mean, stddev ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>mean</code>, <code>stddev</code>は浮動小数点数型。<code>mean</code>は平均。<code>stddev</code>は標準偏差で値の範囲は<span class="math inline">\(0 &lt; \text{stddev}\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e ;
    std::normal_distribution d( <span class="fl">0.0</span>, <span class="fl">1.0</span> ) ;
    d.mean() ; <span class="co">// 0.0</span>
    d.stddev() ; <span class="co">// 1.0</span>

    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        std::cout &lt;&lt; d(e) &lt;&lt; <span class="st">&quot;, &quot;</span>sv ;
    }  
}</code></pre></div>
<h3 id="対数正規分布stdlognormal_distributionrealtype">対数正規分布(<code>std::lognormal_distribution&lt;RealType&gt;</code>)</h3>
<p><code>std::lognormal_distribution&lt;RealType&gt;</code>は浮動小数点数の乱数<span class="math inline">\(x &gt; 0\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x\,|\,m,s) = \frac{1}{s x \sqrt{2 \pi}}
     \cdot \exp{\left(-\frac{(\ln{x} - m)^2}{2 s^2}\right)}
     \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::lognormal_distribution&lt;RealType&gt; d( m, s ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>m</code>, <code>s</code>は<code>RealType</code>型。値の範囲は<span class="math inline">\(0 &lt; s\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e ;
    std::lognormal_distribution d( <span class="fl">0.0</span>, <span class="fl">1.0</span> ) ;
    d.m() ; <span class="co">// 0.0</span>
    d.s() ; <span class="co">// 1.0</span>

    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        std::cout &lt;&lt; d(e) &lt;&lt; <span class="st">&quot;, &quot;</span>sv ;
    }  
}</code></pre></div>
<h3 id="カイ二乗分布stdchi_squared_distributionrealtype">カイ二乗分布(<code>std::chi_squared_distribution&lt;RealType&gt;</code>)</h3>
<p><code>std::chi_squared_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x &gt; 0\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x\,|\,n) = \frac{x^{(n/2)-1} \cdot e^{-x/2}}{\Gamma(n/2) \cdot 2^{n/2}} \text{ .} 
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::chi_squared_distribution&lt;RealType&gt; d( n ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>n</code>は<code>RealType</code>型。値の範囲は<span class="math inline">\(0 &lt; n\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e ;
    std::chi_squared_distribution d( <span class="fl">1.0</span> ) ;
    d.n() ; <span class="co">// 1.0</span>

    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        std::cout &lt;&lt; d(e) &lt;&lt; <span class="st">&quot;, &quot;</span>sv ;
    }  
}</code></pre></div>
<h3 id="コーシー分布stdcauchy_distributionrealtype">コーシー分布(<code>std::cauchy_distribution&lt;RealType&gt;</code>)</h3>
<p><code>std::cauchy_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x\,|\,a,b) = \left(\pi b \left(1 + \left(\frac{x-a}{b} \right)^2 \, \right)\right)^{-1} \text{ .} 
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::cauchy_distribution&lt;RealType&gt; d( a, b ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>a</code>, <code>b</code>は<code>RealType</code>型。値の範囲は<span class="math inline">\(0 &lt; b\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::mt19937 e ;
    std::chi_squared_distribution d( <span class="fl">0.0</span>, <span class="fl">1.0</span> ) ;
    d.a() ; <span class="co">// 0.0</span>
    d.b() ; <span class="co">// 1.0</span>

    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span> ; i != <span class="dv">10</span> ; ++i )
    {
        std::cout &lt;&lt; d(e) &lt;&lt; <span class="st">&quot;, &quot;</span>sv ;
    }  
}</code></pre></div>
<h3 id="フィッシャーのf分布stdfisher_f_distributionrealtype">フィッシャーの<span class="math inline">\(F\)</span>分布(<code>std::fisher_f_distribution&lt;RealType&gt;</code>)</h3>
<p>フィッシャーの<span class="math inline">\(F\)</span>分布(Fisher's <span class="math inline">\(F\)</span>-distribution)の名前は数学者サー・ロナルド・エイルマー・フィッシャー(Sir Ronald Aylmer Fisher)に由来する。</p>
<p><code>std::fisher_f_distribution&lt;RealType&gt;</code>は浮動小数点数の乱数<span class="math inline">\(x &gt; 0\)</span>を以下の関数密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x\,|\,m,n) = \frac{\Gamma\big((m+n)/2\big)}{\Gamma(m/2) \; \Gamma(n/2)}
     \cdot \left(\frac{m}{n}\right)^{m/2}
     \cdot x^{(m/2)-1}
     \cdot \left(1 + \frac{m x}{n}\right)^{-(m + n)/2}
     \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::fisher_f_distribution&lt;RealType&gt; d( m, n ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>dobule</code>。<code>m</code>, <code>n</code>は<code>RealType</code>型。値の範囲は<span class="math inline">\(0 &lt; m\)</span> かつ <span class="math inline">\(0 &lt; n\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::fisher_f_distribution d( <span class="fl">1.0</span> ) ;
    d.n() ; <span class="co">// 1.0</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<h3 id="スチューデントのt分布stdstudent_t_distributionrealtype">スチューデントの<span class="math inline">\(t\)</span>分布(<code>std::student_t_distribution&lt;RealType&gt;</code>)</h3>
<p>スチューデントの<span class="math inline">\(t\)</span>分布(Student's <span class="math inline">\(t\)</span>-distribution)はウィリアム・シーリー・ゴセット(William Sealy Gosset)によって考案された。当時、ウィリアムはギネス醸造所で働いていたが、ギネスは従業員に科学論文を発表することを禁じていたために、ウィリアムはスチューデントという偽名で発表した。</p>
<p><code>std::student_t_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x\,|\,n) = \frac{1}{\sqrt{n \pi}}
     \cdot \frac{\Gamma\big((n+1)/2\big)}{\Gamma(n/2)}
     \cdot \left(1 + \frac{x^2}{n} \right)^{-(n+1)/2}
     \text{ .}
\]</span></p>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::student_t_distribution&lt;RealType&gt; d( n ) ;</code></pre></div>
<p><code>RealType</code>は浮動小数点数型でデフォルトは<code>double</code>。<code>n</code>は<code>RealType</code>型で、値の範囲は<span class="math inline">\(0 &lt; n\)</span>。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::student_t_distribution d( <span class="fl">1.0</span> ) ;
    d.n() ; <span class="co">// 1.0</span>

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<h2 id="サンプリング分布sampling-distributions">サンプリング分布(sampling distributions)</h2>
<p>サンプリング分布(sampling distributions)とは、標本から分布の特徴がわかっている場合に、その特徴を指定することにより、望みの分布を作り出す分布のことだ。</p>
<h3 id="離散分布stddiscrete_distributioninttype">離散分布(<code>std::discrete_distribution&lt;IntType&gt;</code>)</h3>
<h4 id="簡単な説明">簡単な説明</h4>
<p>離散分布(discrete distribution)は整数型の乱数<span class="math inline">\(i\)</span>, <span class="math inline">\(0 \leq i &lt; n\)</span>を返す分布だ。例えば<span class="math inline">\(n = 10\)</span>ならば、<span class="math inline">\(0,1,2,3,4,5,6,7,8,9\)</span>の10個のうちのいずれかの整数値を乱数として返す。この際、乱数値として取りうる整数値1つ1つに、確率を設定できる。確率は<span class="math inline">\(p_0, \dotsc, p_{n-1}\)</span>で設定し、<span class="math inline">\(p_0\)</span>が<span class="math inline">\(0\)</span>の確率, <span class="math inline">\(p_1\)</span>が<span class="math inline">\(1\)</span>の確率...<span class="math inline">\(p_{n-1}\)</span>が<span class="math inline">\(n\)</span>の確率となる。それぞれの乱数<span class="math inline">\(i\)</span>は確率<span class="math inline">\(\frac{p_i}{S}\)</span>で出現する。このとき<span class="math inline">\(S\)</span>とはすべての確率の合計、つまり<span class="math inline">\(S = p_0 + \dotsc + p_{n-1}\)</span>となる。確率<span class="math inline">\(p_i\)</span>は<code>double</code>型で与える。</p>
<p>たとえば、<code>{1.0, 1.0, 1.0}</code>という確率群を渡した場合、離散分布は<span class="math inline">\(0, 1, 2\)</span>のいずれかの乱数をそれぞれ<span class="math inline">\(\frac{1.0}{3.0}\)</span>の確率で返す。</p>
<p>もし、<code>{1.0, 2.0, 3.0}</code>という確率群を渡した場合、離散分布は<span class="math inline">\(0, 1, 2\)</span>のいずれかの乱数を返す。その時の確率は、<span class="math inline">\(1\)</span>が<span class="math inline">\(\frac{1}{6}\)</span>、<span class="math inline">\(2\)</span>が<span class="math inline">\(\frac{1}{3}\)</span>、<span class="math inline">\(3\)</span>が<span class="math inline">\(\frac{1}{2}\)</span>だ。</p>
<p>例えば公平な6面ダイスを作りたい場合、<code>{1.0, 1.0, 1.0, 1.0, 1.0, 1.0}</code>を指定すると<span class="math inline">\(0 \leq i \leq 5\)</span>までの6個の乱数<span class="math inline">\(i\)</span>がそれぞれ<span class="math inline">\(\frac{1}{6}\)</span>の確率で生成される。この結果に<code>+1</code>すると<span class="math inline">\(1 \leq i \leq 6\)</span>の乱数を得ることができる。</p>
<p>6の目だけ2倍高い確率で出るイカサマ6面ダイスを作りたい場合、<code>{1.0, 1.0, 1.0, 1.0, 1.0, 2.0}</code>を指定すると、0から4までの5つの目は<span class="math inline">\(\frac{1}{7}\)</span>の確率で出現し、5だけは<span class="math inline">\(\frac{2}{7}\)</span>の確率で出る乱数を作ることができる。</p>
<p><span class="math inline">\(S\)</span>はすべての確率の合計で、それぞれの値は<span class="math inline">\(\frac{p_i}{S}\)</span>の確率で出る。なので、以下はすべて分布だ。</p>
<pre><code>{1.0, 1.0, 1.0, 1.0, 1.0, 2.0}
{0.1, 0.1, 0.1, 0.1, 0.1, 0.2}
{2.0, 2.0, 2.0, 2.0, 2.0, 4.0}</code></pre>
<h4 id="数学的な説明">数学的な説明</h4>
<p><code>std::discrete_distribution&lt;IntType&gt;</code>は整数型の乱数<span class="math inline">\(i\)</span>, <span class="math inline">\(0 \leq i &lt; n\)</span>を以下の離散確率関数に従って分布する。</p>
<p><span class="math display">\[
P(i \,|\, p_0, \dotsc, p_{n-1}) = p_i \text{ .}
\]</span></p>
<p>別に指定のない場合、分布パラメーターは<span class="math inline">\(p_k = {w_k / S}\)</span> for <span class="math inline">\(k = 0, \dotsc, n - 1\)</span>として計算され、このとき値<span class="math inline">\(w_k\)</span>は、一般に<em>ウエイト（weight）</em>と呼ばれていて、値は非負数、非NaN、非無限でなければならない。さらに、以下の関係が成り立たねばならない。<span class="math inline">\(0 &lt; S = w_0 + \dotsb + w_{n - 1}\)</span>。</p>
<h4 id="変数の宣言">変数の宣言</h4>
<p><code>std::discrete_distribution</code>の変数を宣言するには3つの方法がある。いずれも<code>double</code>型の値を<code>n</code>個渡すための方法だ。</p>
<h5 id="イテレーターのペア-1">イテレーターのペア</h5>
<p>変数の宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::discrete_distribution&lt;IntType&gt; d( firstW, lastW ) ;</code></pre></div>
<p><code>IntType</code>は整数型でデフォルトは<code>int</code>、<code>[firstW, lastW)</code>はイテレーターのペアで、<code>double</code>型に変換可能な値を参照している。</p>
<p>利用例:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array ps = {<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>} ;
    std::discrete_distribution d( std::begin(ps), std::end(ps) );

    std::mt19937 e ;
    d(e)
}</code></pre></div>
<h5 id="初期化リスト-1">初期化リスト</h5>
<p>利用例:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::discrete_distribution&lt;IntType&gt; d( {...} ) ;
std::discrete_distribution&lt;IntType&gt; d = {...} ;</code></pre></div>
<p><code>...</code>には<code>double</code>型の浮動小数点数を指定する</p>
<p>利用例:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::discrete_distribution d( { <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span> } );
    <span class="co">// もしくは</span>
    <span class="co">// ... d = { 1.0, 2.0, 3.0 } ;</span>

    std::mt19937 e ;
    d(e)
}</code></pre></div>
<h5 id="個数デルタ関数">個数、デルタ、関数</h5>
<p>このコンストラクターは以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> UnaryOperation&gt;
    discrete_distribution(
        size_t nw,
        <span class="dt">double</span> xmin, <span class="dt">double</span> xmax,
        UnaryOperation fw
);</code></pre></div>
<p><code>UnaryOperation</code>は1つの実引数を取る関数オブジェクトで戻り値の型は<code>double</code>型に変換できること。さらに、<code>double</code>型は<code>UnaryOperation</code>の引数に変換可能なこと。もし<span class="math inline">\(nw = 0\)</span>の場合は、<span class="math inline">\(n = 1\)</span>とする。それ以外の場合、<span class="math inline">\(n = \tcode{nw}\)</span>とする。このとき、<span class="math inline">\(0 &lt; \delta = (\tcode{xmax} - \tcode{xmin}) / n\)</span>となる関係が満たされなければならない。</p>
<p>もし<span class="math inline">\(nw = 0\)</span>ならば<span class="math inline">\(w_0 = 1\)</span>。それ以外の場合、<span class="math inline">\(k = 0, \dotsc, n - 1\)</span>に対して、<span class="math inline">\(w_k = \tcode{fw}(\tcode{xmin} + k \cdot \delta + \delta / 2)\)</span>とする。<code>fw</code>は<code>n</code>回を超えて呼ばれることはない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::discrete_distribution d( <span class="dv">5</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>, [](<span class="kw">auto</span> x){
        std::cout &lt;&lt; x &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span> ;
        <span class="kw">if</span> ( x &lt; <span class="fl">0.3</span> )
            x = <span class="fl">0.3</span> ;
        <span class="kw">if</span> ( x &gt; <span class="fl">0.8</span> )
            x = <span class="fl">0.8</span> ;
        <span class="kw">return</span> x ;
    } );
}</code></pre></div>
<p>この<code>d</code>は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">std::discrete_distribution d = {<span class="fl">0.3</span>, <span class="fl">0.3</span>, <span class="fl">0.5</span>, <span class="fl">0.7</span>, <span class="fl">0.8</span> } ;</code></pre></div>
<p>と初期化されたものと同じように初期化される。</p>
<h4 id="初期化パラメーターの確認">初期化パラメーターの確認</h4>
<p><code>std::discrete_distribution</code>の内部状態はメンバー関数<code>probabilities</code>で取得できる。戻り値の型は<code>std::vector&lt;double&gt;</code>で、指定した確率群が要素になっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::discrete_distribution d = { <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span> } ;
    <span class="kw">auto</span> v = d.probabilities() ;
    <span class="co">// vは{1.0, 2.0, 3.0}</span>
}</code></pre></div>
<h4 id="応用例">応用例</h4>
<p>以下は6の目が2倍の確率で出るイカサマ6面ダイスの実装だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Engine &gt;
<span class="dt">int</span> roll_dice( Engine &amp; e )
{
    std::discrete_distribution d = { <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span> } ;
    <span class="kw">return</span> d(e) + <span class="dv">1</span> ;
}</code></pre></div>
<h3 id="区分定数分布stdpiecewise_constant_distributionrealtype">区分定数分布(<code>std::piecewise_constant_distribution&lt;RealType&gt;</code>)</h3>
<h4 id="簡単な説明-1">簡単な説明</h4>
<p>区分定数分布(piecewise constant distribution)とは、区分と、区分ごとの確率を指定し、いずれかの区分の範囲の値に一様分布させる分布だ。ここでいう確率は、密度、あるいはウエイトともいう。</p>
<p>1つの区分は<code>double</code>型の値2つ<span class="math inline">\(b_i, b_{i+1}\)</span>で与える。このとき区分の乱数<span class="math inline">\(x\)</span>の範囲は<span class="math inline">\([b_i, b_{i+1})\)</span>、もしくは<span class="math inline">\(b_i \leq x &lt; b_{i+1}\)</span>だ。<span class="math inline">\(n\)</span>個の値を指定すると、<span class="math inline">\(n-1\)</span>個の区分を指定したことになる。</p>
<p>例えば<code>{0.0, 1.0}</code>という2つの<code>double</code>型の値を使って1つの区分を与えた場合、これは<span class="math inline">\(0.0 \leq x &lt; 1.0\)</span>という値の範囲の区分である。<code>{0.0, 1.0, 2.0}</code>という3つの<code>double</code>型の値は2つの区分になり、それぞれ<span class="math inline">\(0.0 \leq x &lt; 1.0\)</span>, <span class="math inline">\(1.0 \leq x &lt; 2.0\)</span>になる。</p>
<p>一般に、<span class="math inline">\(n\)</span>個の<code>double</code>型の値<span class="math inline">\(b_0, \dotsc, b_n\)</span>で<span class="math inline">\(n-1\)</span>個の区分を表現する。このとき、<span class="math inline">\(b_i &lt; b_{i+1}\)</span>が<span class="math inline">\(i = 0, \dotsc, n-1\)</span>までの<span class="math inline">\(i\)</span>について成り立たなければならない。つまり区分を指定する<code>double</code>型の値は、後続の値より小さくなければならないということだ。</p>
<p>以下は正しい区分の指定だ。</p>
<pre><code>{1.0, 2.0, 100.0, 999.999}
{-1.0, 1.0, 2.0}
{-5.0, -4.0, -3.1}</code></pre>
<p>以下は正しくない区分の指定だ。</p>
<pre><code>{1.0, 0.0}</code></pre>
<p>これは<span class="math inline">\(b_0 &gt; b_1\)</span>なので正しくない。</p>
<p>それぞれの区分<span class="math inline">\([b_i, b_{i+1})\)</span>に対して確率<span class="math inline">\(p_i\)</span>を<code>double</code>型で指定する。<span class="math inline">\(n\)</span>個の<span class="math inline">\(b_i\)</span>によって<span class="math inline">\(n-1\)</span>個の区分を指定し、それぞれに対して1つずつ確率を設定するので、確率の数は<span class="math inline">\(n-1\)</span>個だ。</p>
<p>例えば<code>{0.0, 1.0}</code>という1つの区分と<code>{1.0}</code>という1つの確率を与えた場合、<span class="math inline">\(0.0 \leq x &lt; 1.0\)</span>の範囲の乱数<span class="math inline">\(x\)</span>が生成される。</p>
<p><code>{0.0, 1.0, 10.0}</code>という2つの区分と、<code>{1.0, 2.0}</code>という2つの確率を与えた場合、<span class="math inline">\(\frac{1}{3}\)</span>の確率で<span class="math inline">\(0.0 \leq x &lt; 1.0\)</span>の範囲に一様分布した乱数になり、<span class="math inline">\(\frac{2}{3}\)</span>の確率で<span class="math inline">\(1.0 \leq x &lt; 10.0\)</span>の範囲に一様分布した乱数になる。</p>
<h4 id="数学的な説明-1">数学的な説明</h4>
<p><code>std::piecewise_constant_distribution&lt;RealType&gt;</code>は浮動小数点数型の乱数<span class="math inline">\(x\)</span>, <span class="math inline">\(b_0 \leq x &lt; b_n\)</span>を以下の確率密度関数に従って、それぞれの部分区間(subinterval)<span class="math inline">\([b_i, b_{i+1})\)</span>の間で一様に分布させる。</p>
<p><span class="math display">\[
p(x \,|\, b_0, \dotsc, b_n, \; \rho_0, \dotsc, \rho_{n-1}) = \rho_i
   \text{ , for $b_i \le x &lt; b_{i+1}$.} 
\]</span></p>
<p>この分布の区間境界(interval boundaries)ともいう<span class="math inline">\(n+1\)</span>分布パラメーター<span class="math inline">\(b_i\)</span>はすべての<span class="math inline">\(i = 0, \dotsc, n - 1\)</span>に対して関係<span class="math inline">\(b_i &lt; b_{i + 1}\)</span>を満たさねばならない。別途指定なき場合、残りの<span class="math inline">\(n\)</span>分布パラメーターは以下のように計算される。</p>
<p><span class="math display">\[
\rho_k = \frac{w_k}{S \cdot (b_{k+1}-b_k)} \text{ for } k = 0, \dotsc, n - 1 \text{ ,} 
\]</span></p>
<p>一般にウエイト(weight)と呼ばれている値<span class="math inline">\(w_k\)</span>は、非負数、非NaN、非無限でなければならない。さらに、以下の関係を満たさなければならない。</p>
<p><span class="math inline">\(0 &lt; S = w_0 + \dotsb + w_{n-1}\)</span></p>
<h4 id="変数の宣言-1">変数の宣言</h4>
<p><code>std::piecewise_constant_distribution</code>では、<code>double</code>型の値の集合を2つ渡す必要がある。1つは区間を指定するための<span class="math inline">\(N\)</span>個の<code>double</code>型に変換可能な値で、もう1つは区間ごとの確率を指定するための<span class="math inline">\(N-1\)</span>個の<code>double</code>型に変換可能な値だ。</p>
<h5 id="イテレーターによる指定">イテレーターによる指定</h5>
<p>イテレーターで区間と確率を指定するコンストラクターは以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> InputIteratorB, <span class="kw">class</span> InputIteratorW&gt;
piecewise_constant_distribution(
    InputIteratorB firstB, InputIteratorB lastB,
    InputIteratorW firstW
);</code></pre></div>
<p><code>[firstB, lastB)</code>は区間を指定するための<span class="math inline">\(N\)</span>個の値を参照する入力イテレーターのペアだ。<code>firstW</code>はそれぞれの区間の確率を指定する<span class="math inline">\(N-1\)</span>個の値を参照する入力イテレーターの先頭だ。<code>lastW</code>がないのは、確率の個数は<span class="math inline">\(N-1\)</span>個であるとわかっているからだ。</p>
<p>もし<code>[firstB, lastB)</code>のサイズが1以下の場合、区間は<code>[0.0, 1.0)</code>になり、確率は<span class="math inline">\(\frac{1}{1}\)</span>になる。</p>
<p>利用例:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::array bs = {<span class="fl">-1.0</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span> } ;
    std::array ps = { <span class="fl">1.0</span>, <span class="fl">5.0</span> } ;
    std::piecewise_constant_distribution d( std::begin(bs), std::end(bs), std::begin(ps) ) ;

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<p><code>bs</code>は区間を指定する値の集合、<code>ps</code>は区間ごとの確率だ。</p>
<p>区間は<code>[-1.0, 1.0)</code>と<code>[1.0, 2.0)</code>の2つ。確率はそれぞれ<span class="math inline">\(\frac{1}{6}\)</span>、<span class="math inline">\(\frac{5}{6}\)</span>だ。</p>
<p>区間を表現する値が足りない場合は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 区間を指定すべき値が足りない</span>
    std::array bs = { <span class="fl">1.0</span> } ;
    std::array ps = { <span class="fl">1.0</span>, <span class="fl">5.0</span> } ;
    <span class="co">// 引数は無視される。</span>
    <span class="co">// 区間は[0.0, 1.0), 確率は100%</span>
    std::piecewise_constant_distribution d( std::begin(bs), std::end(bs), std::begin(ps) ) ;
}</code></pre></div>
<h5 id="初期化リストと関数オブジェクトによる指定">初期化リストと関数オブジェクトによる指定</h5>
<p>初期化リストと関数を指定するコンストラクターは以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> UnaryOperation&gt;
piecewise_constant_distribution(
    initializer_list&lt;RealType&gt; bl,
    UnaryOperation fw
);</code></pre></div>
<p>イテレーターのペアと同じく、区間は<code>[bl.begin(), bl.end())</code>で指定する。</p>
<p>確率は<span class="math inline">\(k = 0, \dotsc, n - 1\)</span>について、<span class="math inline">\(w_k = \tcode{fw}\bigl(\bigl(b_{k+1} + b_k\bigr) / 2\bigr)\)</span>とする。</p>
<p><code>bl.size()</code>が1以下の場合、区間は<code>[0.0, 1.0)</code>になり、確率は<span class="math inline">\(\frac{1}{1}\)</span>になる。</p>
<p>利用例:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::piecewise_constant_distribution d(
        {<span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>, <span class="fl">4.0</span>, <span class="fl">5.0</span>},
        []( <span class="kw">auto</span> x )
        { <span class="kw">return</span> x ; }
    ) ;
}</code></pre></div>
<p>この場合、区間は<code>[1.0, 2.0)</code>, <code>[2.0, 3.0)</code>, <code>[3.0, 4.0)</code>, <code>[4.0, 5.0)</code>の4個になり、確率は<code>{1.5, 2.5, 3.5, 4.5}</code>となる。</p>
<h5 id="区間数最小最大関数オブジェクトによる指定">区間数、最小、最大、関数オブジェクトによる指定</h5>
<p>コンストラクターの宣言:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> UnaryOperation&gt;
piecewise_constant_distribution(
    size_t nw,
    RealType xmin, RealType xmax,
    UnaryOperation fw
);</code></pre></div>
<p><code>nw</code>は区間数、<code>xmin</code>は最小値、<code>xmax</code>は最大値、<code>fw</code>は関数オブジェクトで、<code>double</code>型から変換できる型の実引数を取り、<code>double</code>型に変換可能な戻り値を返す。</p>
<p><span class="math inline">\(nw = 0\)</span>の場合、区間の個数<span class="math inline">\(n\)</span>は<span class="math inline">\(1\)</span>になる。それ以外の場合、<span class="math inline">\(n = nw\)</span>となる。このとき関係、<span class="math inline">\(0 &lt; \delta = (\tcode{xmax} - \tcode{xmin}) / n\)</span>が成り立たなければならない。 Let $b_k =  + k $ for $ k = 0, , n$, and $w_k = (b_k + / 2) $ for .</p>
<p>$ k = 0, , n - 1<span class="math inline">\(において、区間は\)</span>b_k =  + k $ for $ k = 0, , n<span class="math inline">\(とし、確率は\)</span>w_k = (b_k + / 2) $とする。</p>
<p>利用例:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::piecewise_constant_distribution d( <span class="dv">5</span>, <span class="fl">1.0</span>, <span class="fl">5.0</span>,
        []( <span class="kw">auto</span> x ) { <span class="kw">return</span> x ; } ) ;
}</code></pre></div>
<p>この場合、区間の集合は<code>{1.0, 1.8, 2.6, 3.4, 4.2, 5.0}</code>となり、確率は<code>{1.4, 2.2, 3.0, 3.8, 4.6}</code>となる。</p>
<h4 id="内部状態の取得">内部状態の取得</h4>
<p><code>std::piecewise_constant_distribution</code>の内部状態は、メンバー関数<code>intervals</code>と<code>densities</code>で得ることができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> RealType = <span class="dt">double</span>&gt;
<span class="kw">class</span> piecewise_constant_distribution {
<span class="kw">public</span> :
    vector&lt;result_type&gt; intervals() <span class="dt">const</span>;
    vector&lt;result_type&gt; densities() <span class="dt">const</span>;
} ;</code></pre></div>
<p><code>intervals</code>は区間、<code>densities</code>は確率を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> bs = { <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span> } ;
    <span class="kw">auto</span> ps = { <span class="fl">1.0</span>, <span class="fl">2.0</span> } ;
    std::piecewise_constant_distribution d( std::begin(bs), std::end(bs), std::begin(ps) ) ;

    <span class="co">// {1.0, 2.0, 3.0}</span>
    <span class="kw">auto</span> intervals = d.intervals() ;
    <span class="co">// {0.333333, 0.666667}</span>
    <span class="kw">auto</span> densities = d.densities() ;
}</code></pre></div>
<p><code>densities()</code>の結果が正規化されているのは、ユーザーが指定した確率は<span class="math inline">\(w_k\)</span>だが、ここで返すのは<span class="math inline">\(p_k\)</span>だからだ。</p>
<h3 id="区分線形分布stdpiecewise_linear_distributionrealtype">区分線形分布(<code>std::piecewise_linear_distribution&lt;RealType&gt;</code>)</h3>
<h4 id="簡単な説明-2">簡単な説明</h4>
<p>区分線形分布(piecewise linear distribution)は区分定数分布と同じく、区間と確率（またの名を密度、ウエイト）を指定する。</p>
<p>区間の指定は区分定数分布と同じだ。内部境界の集合で指定する。例えば<code>{1.0, 2.0, 3.0}</code>は2つの区間<code>[1.0, 2.0)</code>と<code>[2.0, 3.0)</code>を指定する。</p>
<p>区分線形分布における確率は、区間に対してではなく、内部境界に対して指定する。指定した全区間における値の出現確率は、内部境界から内部境界に向かって指定した確率の差の方向に線形に増加、もしくは減少する。</p>
<p>例えば区分<code>{0.0, 1.0}</code>と確率<code>{1.0, 2.0}</code>を指定した場合、これは1つの区間<code>[0.0, 1.0)</code>について、内部境界<code>0.0</code>の確率は<span class="math inline">\(\frac{1}{3}\)</span>、内部境界<code>1.0</code>の確率は<code>\frac{2}{3}</code>とし、<span class="math inline">\(0.0 \leq x &lt; 1.0\)</span>の範囲の乱数<code>x</code>を生成する。内部境界区間の範囲に注意。<code>1.0</code>未満なので、<code>1.0</code>は出ない。</p>
<p>そして、区間の間の値は、区間を区切る2つの内部境界の確率の差によって、線形に増加、もしくは減少する。例えば値<code>0.25</code>が出る確率は<span class="math inline">\(\frac{1.25}{3}\)</span>、<code>0.5</code>が出る確率は<span class="math inline">\(\frac{1.5}{3}\)</span>、値<code>1.75</code>が出る確率は<span class="math inline">\(\frac{1.75}{3}\)</span>だ。</p>
<p>区分<code>{0.0, 1.0, 2.0}</code>と確率<code>{1.0, 2.0, 1.0}</code>の場合、2つの区間<code>[0.0, 1.0)</code>と<code>[1.0, 2.0)</code>の範囲について、<code>0.0</code>から<code>1.0</code>に向かう区間についての確率は<span class="math inline">\(\frac{1}{4}\)</span>から<span class="math inline">\(\frac{1}{2}\)</span>に増加し、<code>1.0</code>から<code>2.0</code>に向かう区間についての確率は<span class="math inline">\(\frac{1}{2}\)</span>から<span class="math inline">\(\frac{1}{4}\)</span>に減少する。</p>
<p>結果として、乱数値の分布をグラフに描画すると、<code>1.0</code>が最も出やすく、その前後±1.0の範囲で徐々に減少していく山のようなグラフになる。</p>
<div class="figure">
<img src="fig-kurema/fig39-01.svg" />

</div>
<h4 id="数学的な説明-2">数学的な説明</h4>
<p><code>std::piecewise_linear_distribution&lt;RealType&gt;</code>は乱数<span class="math inline">\(x\)</span>, <span class="math inline">\(b_0 \leq x &lt; b_n\)</span>を以下の確率密度関数に従って分布する。</p>
<p><span class="math display">\[
p(x \,|\, b_0, \dotsc, b_n, \; \rho_0, \dotsc, \rho_n)
     = \rho_{i}   \cdot {\frac{b_{i+1} - x}{b_{i+1} - b_i}}
     + \rho_{i+1} \cdot {\frac{x - b_i}{b_{i+1} - b_i}}
     \text{ , for $b_i \le x &lt; b_{i+1}$.} 
\]</span></p>
<p>一般に<em>内部境界</em>とも呼ばれる<span class="math inline">\(n + 1\)</span>分布パラメーター<span class="math inline">\(b_i\)</span>は<span class="math inline">\(i = 0, \dotsc, n - 1\)</span>において関係<span class="math inline">\(b_i &lt; b_{i+1}\)</span> for <span class="math inline">\(i = 0, \dotsc, n - 1\)</span>を満たさねばならない。別記する場合を除いて、残りの<span class="math inline">\(n + 1\)</span>パラメーターは<span class="math inline">\(k = 0, \dotsc, n\)</span>において<span class="math inline">\(\rho_k = {w_k / S}\)</span>と計算される。このとき<span class="math inline">\(w_k\)</span>は一般に境界におけるウエイト(weight at boundaries)と呼ばれ、非負数、非NaN、非無限でなければならない。さらに、以下の関係が成り立たねばならない。</p>
<p><span class="math display">\[
0 &lt; S = \frac{1}{2} \cdot \sum_{k=0}^{n-1} (w_k + w_{k+1}) \cdot (b_{k+1} - b_k) \text{ .}
\]</span></p>
<h4 id="変数の宣言-2">変数の宣言</h4>
<p><code>piecewise_linear_distribution</code>は区間と確率を指定するために<code>n</code>個の<code>double</code>型に変換可能な値を指定する必要がある。</p>
<h5 id="イテレーターによる指定-1">イテレーターによる指定</h5>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> InputIteratorB, <span class="kw">class</span> InputIteratorW&gt;
piecewise_linear_distribution(
    InputIteratorB firstB, InputIteratorB lastB,
    InputIteratorW firstW );</code></pre></div>
<p><code>[firstB, lastB)</code>は区間、<code>firstW</code>から区間数までのイテレーターが確率。</p>
<p><code>firstB == lastB</code>もしくは<code>++firstB == lastB</code>の場合、つまり内部境界が1個以下で、空の場合、区間数は1つで<code>[0.0, 1.0)</code>の範囲、確率は<code>{0.0, 1.0}</code>となる。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> bs = { <span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span> } ;
    <span class="kw">auto</span> ps = { <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">1.0</span> } ;
    std::piecewise_linear_distribution d( std::begin(bs), std::end(bs), std::begin(ps) ) ;

    std::mt19937 e ;
    d(e) ;
}</code></pre></div>
<p>空の場合。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> bs = { <span class="fl">0.0</span> } ;
    <span class="kw">auto</span> ps = { <span class="fl">0.0</span> } ;
    std::piecewise_linear_distribution d( std::begin(bs), std::end(bs), std::begin(ps) ) ;
}</code></pre></div>
<p>これは以下のコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> bs = { <span class="fl">0.0</span>, <span class="fl">1.0</span> } ;
    <span class="kw">auto</span> ps = { <span class="fl">0.0</span>, <span class="fl">1.0</span> } ;
    std::piecewise_linear_distribution d( std::begin(bs), std::end(bs), std::begin(ps) ) ;
}</code></pre></div>
<h5 id="初期化リストと関数オブジェクトによる指定-1">初期化リストと関数オブジェクトによる指定</h5>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> UnaryOperation&gt;
piecewise_linear_distribution(
    initializer_list&lt;RealType&gt; bl,
    UnaryOperation fw
);</code></pre></div>
<p>区間を指定する内部境界は<code>[bl.begin(), bl.end())</code>、内部境界<span class="math inline">\(b_k\)</span>に対する確率<span class="math inline">\(w_k\)</span>は<span class="math inline">\(k = 0, \dotsc, n\)</span>について、<span class="math inline">\(w_k = \tcode{fw}(b_k)\)</span>とする。</p>
<p>内部境界が1個以下の場合はイテレーターの場合と同じ。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::piecewise_linear_distribution d(
        {<span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>},
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> x ; }
    ) ;
}</code></pre></div>
<p>これは以下のコード同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> bs = { <span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span> } ;
    <span class="kw">auto</span> ps = { <span class="fl">0.0</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span> } ;
    std::piecewise_linear_distribution d( std::begin(bs), std::end(bs), std::begin(ps) ) ;
}</code></pre></div>
<h5 id="個数最小値最大値関数オブジェクトによる指定">個数、最小値、最大値、関数オブジェクトによる指定</h5>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> UnaryOperation&gt;
piecewise_linear_distribution(
    size_t nw,
    RealType xmin, RealType xmax,
    UnaryOperation fw
);</code></pre></div>
<p><code>nw</code>が個数、<code>xmin</code>が最小値、<code>xmax</code>が最大値、<code>fw</code>が関数オブジェクト。</p>
<p>関数オブジェクト<code>fw</code>は<code>double</code>型から変換できる実引数を1つだけ取り、戻り値の型は<code>double</code>型に変換できること。</p>
<p><span class="math inline">\(\tcode{nw} = 0\)</span>ならば空であり、イテレーターの場合と同じ。</p>
<p>関係<span class="math inline">\(0 &lt; \delta = (\tcode{xmax} - \tcode{xmin}) / n\)</span>が成り立つこと。</p>
<p>内部境界<span class="math inline">\(b_k\)</span>は<span class="math inline">\(k = 0, \dotsc, n\)</span>について<span class="math inline">\(b_k = \tcode{xmin} + k \cdot \delta\)</span>とする。確率<span class="math inline">\(w_k\)</span>は<span class="math inline">\(k = 0, \dotsc, n\)</span>について<span class="math inline">\(w_k = \tcode{fw}(b_k)\)</span>とする。</p>
<p>使い方:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    std::piecewise_linear_distribution d(
        <span class="dv">5</span>,
        <span class="fl">1.0</span>, <span class="fl">5.0</span>,
        [](<span class="kw">auto</span> x){ <span class="kw">return</span> x ;}
    ) ;
}</code></pre></div>
<p>上のコードは以下のコードと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> params = { <span class="fl">1.8</span>, <span class="fl">2.6</span>, <span class="fl">3.4</span>, <span class="fl">4.2</span>, <span class="fl">5.0</span>, <span class="fl">5.8</span> } ;
    std::piecewise_linear_distribution d( std::begin(params), std::end(params), std::begin(params) ) ;
}</code></pre></div>
<h1 id="cプリプロセッサー">Cプリプロセッサー</h1>
<p>CプリプロセッサーはC++がC言語から受け継いだ機能だ。CプリプロセッサーはソースコードをC++としてパースする前に、テキストをトークン単位で変形する処理のことだ。この処理はソースファイルをC++としてパースする前処理として行われる。CプリプロセッサーはC++ではなく別言語として認識すべきで、そもそもプログラミング言語ではなくマクロ言語だ。</p>
<p>C++ではCプリプロセッサーが広く使われており、今後もしばらくは使われるだろう。読者がC++で書かれた既存のコードを読むとき、Cプリプロセッサーは避けて通れない。Cプリプロセッサーはいずれ廃止したい機能ではあるが、C++はいまだに廃止できていない。</p>
<p>Cプリプロセッサーはプリプロセッシングディレクティブ(preprocessing directive)を認識し、トークン列を処理する。ディレクティブはソースファイルの文頭に文字<code>#</code>から始まり、改行文字で終わる。<code>#</code>とディレクティブの間に空白文字を入れてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define NOSPACE</span>
<span class="ot">#    define SPACE</span></code></pre></div>
<h2 id="includeディレクティブ">#includeディレクティブ</h2>
<p><code>#include</code>は指定したファイルの内容をその場に挿入する。本質的にはコピペだ。C++では<code>#include</code>はライブラリを利用するのに使われる。</p>
<p><code>#include</code>は以下のいずれかの文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;ヘッダーファイルパス&gt; 改行文字</span>
<span class="ot">#include &quot;ヘッダーファイルパス&quot; 改行文字</span></code></pre></div>
<p><code>#include</code>は指定したファイルパスのファイルの内容をその場所に挿入する。このファイルをヘッダーファイルという。<code>&lt;&gt;</code>によるファイルパスは、標準ライブラリやシステムのヘッダーファイルを格納したディレクトリーからヘッダーファイルを探す。<code>&quot;&quot;</code>によるファイルパスは、システム以外のディレクトリーからもヘッダーファイルを探す。例えばカレントディレクトリーなどだ。</p>
<p>例えば、以下のようなヘッダーファイル<code>foo.h</code>があり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// foo.h</span>
foo foo foo</code></pre></div>
<p>以下のようなソースファイル<code>bar.cpp</code>がある場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="ot">#include &quot;foo.h&quot;</span>

<span class="co">// end bar.cpp</span></code></pre></div>
<p><code>bar.cpp</code>をCプリプロセッサーにかけると、以下のようなソースファイルが出力される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// bar.cpp</span>

<span class="co">// foo.h</span>
foo foo foo

<span class="co">// end bar.h</span></code></pre></div>
<p>このソースファイルはC++のソースファイルとしてはエラーとなるが、Cプリプロセッサーは単純にトークン列で分割したテキストファイルとしてソースファイルを処理するため、Cプリプロセッサーとしてはエラーにはならない。</p>
<p>冒頭で述べたように、<code>#include</code>の本質はコンパイラーによるコピペである。あるテキストファイルの内容をその場に挿入するコピペ機能を提供する。</p>
<p><code>#include</code>は、ほかの言語でモジュール、importなどと呼ばれている機能を簡易的に提供する。C++の標準ライブラリを使うには、<code>&lt;iostream&gt;</code>や<code>&lt;string&gt;</code>や<code>&lt;vector&gt;</code>のようなヘッダーファイルを<code>#include</code>する必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// iostreamライブラリを使う</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="co">// stringライブラリを使う</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="dt">int</span> main()
{
    <span class="co">// &lt;string&gt;のライブラリ</span>
    std::string s(<span class="st">&quot;hello&quot;</span>) ;
    <span class="co">// iostreamのライブラリ</span>
    std::cout &lt;&lt; s ;
}</code></pre></div>
<p>すでに述べたように<code>#include</code>はファイルの内容をその場に挿入するだけであり、ほかの言語にあるモジュールのための高級な機能ではない。本書を執筆時点で規格策定中のC++20では、より高級なモジュール機能を追加する予定がある。</p>
<p>同じヘッダーファイルを複数回<code>#include</code>すると、当然複数回挿入される。</p>
<p>以下のような<code>val.h</code>を、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>以下のように複数回<code>#include</code>すると、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;val.h&quot;</span>
<span class="ot">#include &quot;val.h&quot;</span></code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;
<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;</code></pre></div>
<p>これは<code>val</code>の定義が重複しているためエラーとなる。</p>
<p>しかし、ヘッダーファイルを一度しか<code>#include</code>しないようにするのは困難だ。なぜならば、ヘッダーファイルはほかのヘッダーファイルから間接的に<code>#include</code>されることもあるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_f.h</span>

<span class="ot">#include &quot;val.h&quot;</span>

<span class="dt">int</span> f() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// lib_g.h</span>

<span class="ot">#include &quot;val.h&quot;</span>

<span class="dt">int</span> g() ;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="ot">#include &quot;lib_f.h&quot;</span>
<span class="ot">#include &quot;lib_g.h&quot;</span>

<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>この<code>main.cpp</code>をCプリプロセッサーにかけると以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>

<span class="co">// lib_f.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> f() ;

<span class="co">// lib_g.h</span>

<span class="co">// val.h</span>
<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="dt">int</span> g() ;


<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = f() + g() ;
}</code></pre></div>
<p>これは<code>val</code>の定義が重複しているためエラーとなる。</p>
<p>この問題に対処するためには、複数回<code>#include</code>されると困るヘッダーファイルでは、インクルードガード(include guard)と呼ばれている方法を使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// val.h</span>

<span class="ot">#ifndef INCLUDE_GUARD_HEADER_VAL_H</span>
<span class="ot">#define INCLUDE_GUARD_HEADER_VAL_H</span>

<span class="kw">inline</span> <span class="dt">int</span> val ;

<span class="ot">#endif</span></code></pre></div>
<p>このように記述した<code>val.h</code>を複数回<code>#include</code>しても、最初の<code>ifndef</code>のみがコンパイル対象になるため、問題は起こらない。</p>
<p>インクルードガードは以下の様式を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef 十分にユニークなマクロ名</span>
<span class="ot">#define 十分にユニークなマクロ名 </span>

<span class="co">// 重複してコンパイルされたくないコードをここに書く</span>

<span class="ot">#endif</span></code></pre></div>
<p><code>十分にユニークなマクロ名</code>は全ソースファイル中で衝突しないそのヘッダーに固有のマクロ名を使う。慣習的に推奨される方法としてはすべて大文字を使い、十分に長いマクロ名にすることだ。</p>
<h2 id="define">#define</h2>
<p><code>#define</code>はマクロ置換を行う。マクロにはオブジェクト風マクロ(object-like macro)と関数風マクロ(function-like macro)がある。風というのは、マクロはオブジェクトでも関数でもないからだ。ただ、文法上オブジェクトや関数の似ているだけで、実態はトークン列の愚直な置換だ。</p>
<h3 id="オブジェクト風マクロ">オブジェクト風マクロ</h3>
<p>オブジェクト風マクロの文法は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define マクロ名 置換リスト　改行文字</span></code></pre></div>
<p><code>#define</code>以降の行では、マクロ名が置換リストに置き換わる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define ONE             1</span>
<span class="ot">#define ONE_PLUS_ONE    ONE + ONE</span>
<span class="ot">#define GNU GNU&#39;s is NOT UNIX</span>

ONE
ONE_PLUS_ONE</code></pre></div>
<p>これをプリプロセスすると以下のソースコードになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span>
<span class="dv">1</span> + <span class="dv">1</span></code></pre></div>
<p>マクロ名<code>ONE</code>は<code>1</code>に置換される。</p>
<p>マクロ名<code>ONE_PLUS_ONE</code>は<code>ONE + ONE</code>に置換される。置換された結果に別のマクロ名があれば、そのマクロ名も置換される。</p>
<p>あるマクロ名を置換した結果、そのマクロ名が現れても再帰的に置換されることはない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define GNU GNU&#39;s NOT UNIX!</span>

GNU</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">GNU<span class="st">&#39;s NOT UNIX!</span></code></pre></div>
<p>マクロ名<code>GNU</code>を展開するとトークン`GNU'が現れるが、これは置換されたマクロ名と同じなので、再帰的に置換されることはない。</p>
<h3 id="関数風マクロ">関数風マクロ</h3>
<p>関数風マクロの文法は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define マクロ名( 識別子リスト ) 置換リスト 改行文字</span></code></pre></div>
<p>関数風マクロはあたかも関数のように記述できる。関数風マクロに実引数として渡したトークン列は、置換リスト内で仮引数としての識別子で参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define NO_ARGUMENT()           No argument</span>
<span class="ot">#define ONE_ARGUMENT( ARG )     begin ARG end</span>
<span class="ot">#define MAKE_IT_DOUBLE( ARG )   ONE_ARGUMENT( ARG ARG )</span>

NO_ARGUMENT()
ONE_ARGUMENT( foo bar )
MAKE_IT_DOUBLE( foo bar )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">No argument
begin foo bar end
begin foo bar foo bar end</code></pre></div>
<p>複数の引数を取るマクロへの実引数は、カンマで区切られたトークン列を渡す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define TWO( A, B ) A B</span>
<span class="ot">#define THREE( A, B, C ) C B A</span>

TWO( <span class="dv">1</span> <span class="dv">2</span>, <span class="dv">3</span> <span class="dv">4</span> )
THREE( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>
<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span></code></pre></div>
<p>ただし、括弧で囲まれたトークン列の中にあるカンマは、マクロの実引数の区切りとはみなされない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MACRO( A ) A</span>

MACRO( (a,b) )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">(a,b)</code></pre></div>
<h3 id="va_args__可変長引数マクロ"><code>__VA_ARGS__</code>(可変長引数マクロ)</h3>
<p><code>#define</code>の識別子リストを<code>...</code>だけにしたマクロは、可変長引数マクロになる。このときマクロの実引数のトークン列は、置換リストの中で<code>__VA_ARGS__</code>として参照できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MACRO(...) __VA_ARGS__</span>

MACRO( You can write , <span class="kw">and</span> ,, <span class="kw">or</span> even ,,,, )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">You can write , <span class="kw">and</span> ,, <span class="kw">or</span> even ,,,,</code></pre></div>
<p>カンマも含めてすべてのトークン列がそのまま<code>__VA_ARGS__</code>で参照できる。</p>
<p>可変長引数マクロの識別子リストに仮引数と<code>...</code>を書いたマクロの置換リストでは、仮引数の数だけの実引数は仮引数で参照され、残りが<code>__VA_ARGS__</code>で参照される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MACRO( X, Y, Z, ... ) X Y Z and __VA_ARGS__</span>

MACRO( <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span> )</code></pre></div>
<p>これは以下のように置換される</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="kw">and</span> <span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span></code></pre></div>
<p><code>X</code>, <code>Y</code>, <code>Z</code>にそれぞれ<code>1</code>, <code>2</code>, <code>3</code>が入り、<code>__VA_ARGS__</code>には<code>4</code>, <code>5</code>, <code>6</code>が入る。</p>
<h3 id="va_opt__"><code>__VA_OPT__</code></h3>
<p><code>__VA_OPT__</code>は可変長引数マクロで<code>__VA_ARGS__</code>にトークン列が渡されたかどうかで置換結果を変えることができる。</p>
<p><code>__VA_OPT__</code>は可変引数マクロの置換リストでのみ使える。<code>__VA_OPT__(content)</code>は<code>__VA_ARGS__</code>にトークンがない場合はトークンなしに置換され、トークンがある場合はトークン列<code>content</code>に置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define MACRO( X, ... ) f( X __VA_OPT__(,) __VA_ARGS__ )</span>

MACRO(<span class="dv">1</span>)
MACRO(<span class="dv">1</span>,<span class="dv">2</span>)</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f( <span class="dv">1</span> )
f( <span class="dv">1</span>, <span class="dv">2</span> )</code></pre></div>
<p><code>MACRO(1)</code>は<code>X</code>が<code>1</code>になり、<code>__VA_ARGS__</code>にはトークンがないので、<code>__VA_OPT__(,)</code>は空に置換される。結果として<code>f(1)</code>となる。</p>
<p><code>MACRO(1,2)</code>は、<code>X</code>が<code>1</code>になり、<code>__VA_ARGS__</code>にはトークン<code>2</code>が入るので、<code>__VA_OPT__(,)</code>は<code>,</code>に置換される。結果として<code>f(1,2)</code>となる。</p>
<p><code>__VA_OPT__</code>は<code>__VA_ARGS__</code>に実引数となるトークン列がなければ空に置換されるので、このようにトークン列の有無によってカンマなどの文法上必須のトークン列の有無を切り替えたい場合に使うことができる。</p>
<h3 id="演算子">#演算子</h3>
<p><code>#</code>はマクロ実引数を文字列リテラルにする。</p>
<p><code>#</code>は関数風マクロの置換リストの中のみで使うことができる。<code>#</code>は関数風マクロの仮引数の識別子の直前に書くことができる。<code>#</code>が直前に書かれた識別子は、マクロ実引数のトークン列の文字列リテラルになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define STRING( X ) # X</span>

STRING( hello )
STRING( hello world )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;hello&quot;</span>
<span class="st">&quot;hello world&quot;</span></code></pre></div>
<p>また、可変長マクロと組み合わせた場合、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define STRING( ... ) # __VA_ARGS__</span>

STRING()
STRING( hello,world )</code></pre></div>
<p>以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;&quot;</span>
<span class="st">&quot;hello,world&quot;</span></code></pre></div>
<h3 id="演算子-1">##演算子</h3>
<p><code>##</code>はマクロ実引数の結合を行う。</p>
<p><code>##</code>は関数風マクロの置換リストの中にしか書けない。<code>##</code>は両端にマクロの仮引数の識別子を書かなければならない。<code>##</code>は両端の識別子の参照するマクロ実引数のトークン列を結合した置換を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define CONCAT( A, B ) A ## B</span>

CONCAT( foo, bar )
CONCAT( aaa bbb, ccc ddd)</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">foobar
aaa bbbccc ddd</code></pre></div>
<p>結合した結果のトークンはさらにマクロ置換の対象となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define CONCAT( A, B ) A ## B</span>
<span class="ot">#define FOOBAR hello</span>

CONCAT( FOO, BAR )</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">hello</code></pre></div>
<p><code>CONCAT(FOO,BAR)</code>は<code>FOOBAR</code>に置換され、<code>FOOBAR</code>という名前のマクロ名があるためにさらに<code>hello</code>に置換される。</p>
<h3 id="複数行の置換リスト">複数行の置換リスト</h3>
<p><code>#define</code>ディレクティブの置換リストは複数行に渡って書くことができない。これは文法上の制約によるものだ。<code>#define</code>ディレクティブは改行文字で終端される。</p>
<p>しかし、関数やクラスを生成するような複雑なマクロは、複数行に分けて書きたい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="ot">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="ot">#define DEFINE_LIST( TYPE ) struct LIST_NAME(TYPE){TYPE value ;LIST_NAME(TYPE) * prev ;LIST_NAME(TYPE) * next ;} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>この場合、行末にバックスラッシュに続けて改行を書くと、バックスラッシュと改行がプリプロセッサーによって削除される。</p>
<p>上の例は以下のように、プリプロセッサーとしては比較的わかりやすく書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define LIST_NAME2( PREFIX, TYPE ) PREFIX ## TYPE</span>
<span class="ot">#define LIST_NAME( TYPE ) LIST_NAME2( list_, TYPE )</span>

<span class="ot">#define DEFINE_LIST( TYPE )</span>\
<span class="ot">struct LIST_NAME(TYPE)</span>\
<span class="ot">{</span>\
<span class="ot">    TYPE value ;</span>\
<span class="ot">    LIST_NAME(TYPE) * prev ;</span>\
<span class="ot">    LIST_NAME(TYPE) * next ;</span>\
<span class="ot">} ; </span>

DEFINE_LIST(<span class="dt">int</span>)
DEFINE_LIST(<span class="dt">double</span>)</code></pre></div>
<p>C++ではテンプレートがあるために、このようなマクロを書く必要はない。</p>
<h3 id="undefディレクティブ">#undefディレクティブ</h3>
<p><code>#undef</code>はそれ以前に定義されたマクロを削除する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define FOO BAR</span>
FOO
<span class="ot">#undef FOO</span>
FOO</code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">BAR
FOO</code></pre></div>
<h2 id="条件付きソースファイル選択">条件付きソースファイル選択</h2>
<p><code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, <code>#ifdef</code>, <code>#ifndef</code>は条件付きのソースファイルの選択(conditional inclusion)を行う。これは条件付きコンパイルに近い機能を提供する。</p>
<h3 id="プリプロセッサーの定数式">プリプロセッサーの定数式</h3>
<p>プリプロセッサーで使える条件式は、C++の条件式と比べてだいぶ制限がある。基本的には整数定数式で、<code>true</code>, <code>false</code>が使えるほか、<code>123</code>, <code>1+1</code>, <code>1 == 1</code>, <code>1 &lt; 1</code>のような式も使える。ただし、識別子はすべてマクロ名として置換できるものは置換され、置換できない識別子は、<code>true</code>, <code>false</code>以外はキーワードも含めてすべて<code>0</code>に置換される。</p>
<p>したがって、プリプロセッサーで以下のように書くと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#if UNDEFINED</span>
<span class="ot">#endif</span></code></pre></div>
<p>以下のように書いたものと同じになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#if 0</span>
<span class="ot">#endif</span></code></pre></div>
<p>プリプロセッサーであるので、C++としての<code>constexpr</code>変数や<code>constexpr</code>関数も使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> x = <span class="dv">1</span> ;

<span class="ot">#if x</span>
hello
<span class="ot">#endif</span></code></pre></div>
<p>これは以下のように置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> x = <span class="dv">1</span> ;</code></pre></div>
<p>プリプロセッサーはC++の文法と意味を理解しない。単にトークン列として処理する。</p>
<p>以下の例はエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f() { <span class="kw">return</span> <span class="dv">1</span> ; }

<span class="ot">#if f()</span>
<span class="ot">#endif</span></code></pre></div>
<p>なぜならば、<code>0()</code>は整数定数式として合法なコードではないからだ。何度も言うように、プリプロセッサーはC++の文法と意味を理解しない。</p>
<p>プリプロセッサーの定数式では、特殊なマクロ風の式を使うことができる。<code>defined</code>と<code>__has_include</code>だ。</p>
<p><code>defined</code>は以下の文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">defined 識別子
defined ( 識別子 )</code></pre></div>
<p><code>defined</code>は識別子がそれ以前の行で<code>#define</code>でマクロとして定義されていて<code>#undef</code>で取り消されていない場合<code>1</code>になり、それ以外の場合<code>0</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// #if 0</span>
<span class="ot">#if defined MACRO</span>
<span class="ot">#endif</span>

<span class="ot">#define MACRO</span>

<span class="co">// #if 1</span>
<span class="ot">#if defined MACRO</span>
<span class="ot">#endif</span>

<span class="ot">#undef MACRO</span>

<span class="co">// #if 0</span>
<span class="ot">#if defined MACRO</span>
<span class="ot">#endif</span></code></pre></div>
<p><code>__has_include</code>は以下の文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_include ( &lt; ヘッダーファイル名 &gt; )
__has_include ( <span class="st">&quot; ヘッダーファイル名 &quot;</span> )
__has_include ( 文字列リテラル )
__has_include ( &lt; マクロ &gt; )</code></pre></div>
<p>1番目と2番目は、指定されたヘッダーファイル名がシステムに存在する場合<code>1</code>に、そうでない場合<code>0</code>になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// &lt;filesystem&gt;の存在を確認してから#includeする</span>
<span class="ot">#if __has_include(&lt;filesystem&gt;)</span>
<span class="ot">#   include &lt;filesystem&gt;</span>
<span class="ot">#endif</span>

<span class="co">// &quot;mylibrary.h&quot;の存在を確認してから#includeする</span>
<span class="ot">#if __has_include(&quot;mylibrary.h&quot;)</span>
<span class="ot">#   include &quot;mylibrary.h&quot;</span>
<span class="ot">#endif</span></code></pre></div>
<p>3番目と4番目は、1番目と2番目が適用できない場合に初めて考慮される。その場合、まず通常通りにプリプロセッサーのマクロ置換が行われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define STDIO &quot;stdio.h&quot;</span>

<span class="ot">#if __has_include( STDIO )</span>
<span class="ot">#endif</span>

<span class="ot">#define STDLIB stdlib.h</span>

<span class="ot">#if __has_include( &lt;STDLIB&gt; )</span>
<span class="ot">#endif</span></code></pre></div>
<h3 id="ifディレクティブ">#ifディレクティブ</h3>
<p><code>#if</code>ディレクティブは以下の文法を持つ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#if 定数式 改行文字</span>

<span class="ot">#endif</span></code></pre></div>
<p>もし定数式がゼロの場合、<code>#if</code>と<code>#endif</code>で囲まれたトークン列は処理されない。定数式が非ゼロの場合、処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#if 0</span>
<span class="co">This line will be skipped.</span>
<span class="ot">#endif</span>

<span class="ot">#if 1</span>
This line will be processed.
<span class="ot">#endif</span></code></pre></div>
<p>これをプリプロセスすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">This line will be processed.</code></pre></div>
<p><code>#if 0</code>は処理されないので、<code>#endif</code>までのトークン列は消える。</p>
<h3 id="elifディレクティブ">#elifディレクティブ</h3>
<p><code>#elif</code>ディレクティブは、C++でいう<code>else if</code>に相当する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#elif 定数式 改行文字</span></code></pre></div>
<p><code>#elif</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に複数書くことができる。<code>#elif</code>のある<code>#if</code>が処理される場合、<code>#if</code>から<code>#elif</code>の間のトークン列が処理される、<code>#if</code>が処理されない場合、<code>#elif</code>が<code>#if</code>と同じように定数式を評価して処理されるかどうかが判断される。<code>#elif</code>が処理される場合、処理されるトークン列は次の<code>#elif</code>もしくは<code>#endif</code>までの間のトークン列になる。</p>
<p>以下の例は、すべて<code>YES</code>のトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#if 1</span>
YES
<span class="ot">#elif</span><span class="co"> 1</span>
<span class="co">NO</span>
<span class="ot">#endif</span>

<span class="ot">#if 0</span>
<span class="co">NO</span>
<span class="ot">#elif</span> <span class="dv">1</span>
YES
<span class="ot">#endif</span>

<span class="ot">#if 0</span>
<span class="co">NO</span>
<span class="ot">#elif</span> <span class="dv">1</span>
YES
<span class="ot">#elif 1</span>
NO
<span class="ot">#endif</span>

<span class="ot">#if 0</span>
<span class="co">NO</span>
<span class="ot">#elif</span> <span class="dv">0</span>
NO
<span class="ot">#elif 1</span>
YES
<span class="ot">#endif</span></code></pre></div>
<p>プリプロセスした結果は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">YES
YES
YES
YES</code></pre></div>
<h3 id="elseディレクティブ">#elseディレクティブ</h3>
<p><code>#else</code>ディレクティブはC++でいう<code>else</code>に相当する。</p>
<p><code>#else</code>ディレクティブは<code>#if</code>ディレクティブと<code>#endif</code>ディレクティブの間に書くことができる。もし<code>#if</code>と<code>#elif</code>ディレクティブが処理されない場合で<code>#else</code>ディレクティブがある場合、<code>#else</code>から<code>#endif</code>までのトークン列が処理される。</p>
<p>以下の例は、<code>YES</code>のトークンがある行のみ処理される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#if 1</span>
YES
<span class="ot">#else</span>
<span class="co">NO</span>
<span class="ot">#endif</span>

<span class="ot">#if 0</span>
<span class="co">NO</span>
<span class="ot">#else</span>
YES
<span class="ot">#endif</span>

<span class="ot">#if 0</span>
<span class="co">NO</span>
<span class="ot">#elif</span> <span class="dv">1</span>
YES
<span class="ot">#else</span>
NO
<span class="ot">#endif</span></code></pre></div>
<h3 id="ifdef-ifndefディレクティブ">#ifdef, #ifndefディレクティブ</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifdef 識別子</span>
<span class="ot">#ifndef 識別子</span></code></pre></div>
<p>は、それぞれ以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#if defined 識別子</span>
<span class="ot">#if !defined 識別子</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifdef MACRO</span>
<span class="ot">#endif</span>

<span class="co">// 上と同じ</span>
<span class="ot">#if defined MACRO</span>
<span class="ot">#endif</span>


<span class="ot">#ifndef MACRO</span>
<span class="ot">#endif</span>

<span class="co">// 上と同じ</span>
<span class="ot">#if !defined MACRO</span>
<span class="ot">#endif</span></code></pre></div>
<h2 id="lineディレクティブ">#lineディレクティブ</h2>
<p><code>#line</code>ディレクティブはディレクティブの次の行の行番号と、ソースファイル名を変更する。これは人間が使うのではなく、ツールによって生成されることを想定した機能だ。</p>
<p>以下の文法の<code>#line</code>ディレクティブは、<code>#line</code>ディレクティブの次の行の行番号をあたかも数値で指定した行番号であるかのように振る舞わせる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#line 数値 改行文字</span></code></pre></div>
<p>数値として0もしくは2147483647より大きい数を指定した場合の挙動は未定義となる。</p>
<p>以下の例はコンパイルエラーになるが、コンパイルエラーメッセージはあたかも102行目に問題があるかのように表示される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1行目</span>
<span class="co">// 2行目</span>
<span class="ot">#line 100 </span><span class="co">// 3行目</span>
<span class="co">// 100行目</span>
<span class="co">// 101行目</span>
ill-formed line <span class="co">// 102行目</span></code></pre></div>
<p>以下の例は<code>999</code>を出力するコードだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="dt">int</span> main()
{
<span class="ot">#line 999</span>
    std::cout &lt;&lt; <span class="ot">__LINE__</span> ;
}</code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、次の行の行番号を数値にした上で、ソースファイル名をソースファイル名にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#line 数値 &quot;ソースファイル名&quot; 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#line 42 &quot;answer.cpp&quot;</span></code></pre></div>
<p>以下の文法の<code>#line</code>ディレクティブは、プリプロセッサートークン列をプリプロセスし、上の2つの文法のいずれかに合致させる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#line プリプロセッサートークン列 改行文字</span></code></pre></div>
<p>例、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define LINE_NUMBER 123</span>
<span class="ot">#line LINE_NUMBER</span></code></pre></div>
<h2 id="errorディレクティブ">#errorディレクティブ</h2>
<p><code>#error</code>ディレクティブはコンパイルエラーを引き起こす。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#error 改行文字</span>
<span class="ot">#error トークン列 改行文字</span></code></pre></div>
<p><code>#error</code>によるコンパイラーのエラーメッセージには<code>#error</code>のトークン列を含む。</p>
<p><code>#error</code>の利用例としては、<code>#if</code>と組み合わせるものがある。以下の例は<code>CHAR_BIT</code>が8でなければコンパイルエラーになるソースファイルだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;climits&gt;</span>

<span class="ot">#if CHAR_BIT != 8</span>
<span class="ot">#error CHAR_BIT != 8 implementation is not supported.</span>
<span class="ot">#endif</span></code></pre></div>
<p><code>#if</code>が処理されなければ、その中にある<code>#error</code>も処理されないので、コンパイルエラーにはならない。</p>
<h2 id="pragma">#pragma</h2>
<p><code>#pragma</code>ディレクティブは実装依存の処理を行う。<code>#pragma</code>はコンパイラー独自の拡張機能を追加する文法として使われている。</p>
<p>文法は以下のとおり。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#pragma プリプロセッサートークン列 改行文字</span></code></pre></div>
<p>C++では属性が追加されたために、<code>#pragma</code>を使う必要はほとんどなくなっている。</p>
<h2 id="nullディレクティブ">Nullディレクティブ</h2>
<p><code>Null</code>ディレクティブとは何もしないプリプロセッサーディレクティブだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er"># 改行文字</span></code></pre></div>
<p>つまり、単に<code>#</code>とだけ書いた行はエラーにはならない。</p>
<h2 id="定義済みマクロ名">定義済みマクロ名</h2>
<p>いくつかのマクロ名がプリプロセッサーによってあらかじめ定義されている。</p>
<table>
<colgroup>
<col width="40%" />
<col width="17%" />
<col width="41%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">マクロ名</th>
<th align="center">値</th>
<th align="center">意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>__cplusplus</code></td>
<td align="center"><code>201703L</code></td>
<td align="center">C++17時点での値<br />
将来の規格で増やされる</td>
</tr>
<tr class="even">
<td align="left"><code>__DATE__</code></td>
<td align="center"><code>&quot;Mmm dd yyyy&quot;</code></td>
<td align="center">ソースファイルがプリプロセスされた日付 <code>Mmm</code>は月、<code>dd</code>は日、<code>yyyy</code>は年<br />
月の文字列は<code>asctime</code>が生成するものと同じ<br />
日が1桁の場合、<code>dd</code>の最初の文字は空白文字</td>
</tr>
<tr class="odd">
<td align="left"><code>__FILE__</code></td>
<td align="center">文字列リテラル</td>
<td align="center">ソースファイルの名前の文字列リテラル</td>
</tr>
<tr class="even">
<td align="left"><code>__LINE__</code></td>
<td align="center">整数リテラル</td>
<td align="center">ソースファイルの現在の行番号</td>
</tr>
<tr class="odd">
<td align="left"><code>__STDC_HOSTED__</code></td>
<td align="center">整数リテラル</td>
<td align="center">ホスト実装の場合1<br />
フリースタンディング実装の場合0</td>
</tr>
<tr class="even">
<td align="left"><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code></td>
<td align="center">整数リテラル</td>
<td align="center">アライメント</td>
</tr>
</tbody>
</table>
<h1 id="分割コンパイル">分割コンパイル</h1>
<p>これまで、プログラムは1つのソースファイルから作っていた。プログラムは複数のソースファイルから作ることもできる。ソースファイルを複数に分割することで、ソースファイルの管理がしやすくなったり、プログラムのビルド時間の短縮にもつながる。</p>
<h3 id="ソースファイルとコンパイル">ソースファイルとコンパイル</h3>
<p>ソースファイルを分割すると、C++の書き方にも注意が必要になる。だがその前に、複数のソースファイルをコンパイルして1つのプログラムにする方法を学ぶ。</p>
<h3 id="単一のソースファイルのコンパイル">単一のソースファイルのコンパイル</h3>
<p>C++のソースファイルをコンパイルして実行可能ファイルを作る方法をいま一度おさらいをしよう。</p>
<p><code>source.cpp</code>という名前のソースファイルがあるとき、ここから<code>program</code>という名前の実行可能ファイルを作るには、</p>
<pre><code>$ g++ -o program source.cpp</code></pre>
<p>としていた。毎回このコマンドを入力するのは面倒なので、<code>Makefile</code>を以下のように書いていた。</p>
<div class="sourceCode"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span class="dv">program:</span><span class="dt"> source.cpp</span>
    g++ <span class="ch">$&lt;</span> -o <span class="ch">$@</span></code></pre></div>
<h3 id="ヘッダーファイルはコピペ">ヘッダーファイルはコピペ</h3>
<p>すでに、ソースファイルのほかにヘッダーファイルというファイルも使っている。ヘッダーファイルはソースファイルではない。コンパイル前にソースファイルにコピペされるだけのものだ。</p>
<p>例えば以下のような内容の<code>header.h</code>というヘッダーファイルがあるとして、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// header.h</span>
++i ;</code></pre></div>
<p><code>source.cpp</code>が以下のようであるとき、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
<span class="ot">#include &quot;header.h&quot;</span>
<span class="ot">#include &quot;header.h&quot;</span>
<span class="ot">#include &quot;header.h&quot;</span>
    <span class="dt">int</span> result = i ;
}</code></pre></div>
<p><code>source.cpp</code>をコンパイルすると、まずヘッダーファイルが以下のように展開される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
<span class="co">// header.h</span>
++i ;
<span class="co">// header.h</span>
++i ;
<span class="co">// header.h</span>
++i ;
    <span class="dt">int</span> result = i ;
}</code></pre></div>
<p>ヘッダーファイルとはこれだけのものだ。コンパイラーが<code>#include</code>された場所に、ヘッダーファイルの中身を愚直にコピペするだけだ。</p>
<h3 id="複数のソースファイルのコンパイル">複数のソースファイルのコンパイル</h3>
<p>2つのソースファイル、<code>foo.cpp</code>と<code>bar.cpp</code>からなるプログラムをコンパイルするには、</p>
<pre><code>$ g++ -o program foo.cpp bar.cpp</code></pre>
<p>とする。</p>
<h2 id="オブジェクトファイル">オブジェクトファイル</h2>
<p>単にソースファイルを分割したいだけならば、GCCに分割したソースファイルをすべて指定すればよい。しかしその場合、複数あるソースファイルの1つだけを編集した場合でも、すべてのソースファイルをコンパイルしなければならない。</p>
<p>C++では伝統的に、ソースファイルを部分的にコンパイルしてオブジェクトファイルを生成し、オブジェクトファイルをリンクしてプログラムを生成する方法がある。</p>
<p>ソースファイルをオブジェクトファイルにコンパイルするのは<code>コンパイラー</code>、オブジェクトファイルをプログラムにリンクするのは<code>リンカー</code>の仕事だ。</p>
<div class="figure">
<img src="fig-kurema/fig300-01.svg" />

</div>
<p>GCCではC++コンパイラーの名前は<code>g++</code>で、リンカーの名前は<code>ld</code>だ。ただし、C++のオブジェクトファイルをリンクするのにリンカーを直接使うことはない。<code>g++</code>は<code>ld</code>を適切に呼び出してくれるからだ。</p>
<p>ソースファイル<code>source.cpp</code>をコンパイルしてオブジェクトファイルを生成するには、<code>-c</code>オプションを使う。</p>
<pre><code>$ g++ -c source.cpp</code></pre>
<p>生成されるオブジェクトファイルの名前はソースファイルの名前の拡張子を<code>.o</code>に置き換えたものになる。上のコマンドを実行した結果、オブジェクトファイル<code>source.o</code>が生成される。</p>
<p>生成したオブジェクトファイルは、<code>g++</code>の入力として使うことで、リンクしてプログラムにすることができる。<code>g++</code>は裏でリンカー<code>ld</code>を適切に呼び出してくれる。</p>
<pre><code>$ g++ -o program source.o</code></pre>
<p>オブジェクトファイル名を別の名前にしたい場合は、<code>-o object-file-name</code>オプションを使う。</p>
<pre><code>$ g++ -o object.o -c source.cpp</code></pre>
<p>複数のソースファイル、<code>foo.cpp</code>と<code>bar.cpp</code>からオブジェクトファイルを生成し、リンクして実行可能ファイル<code>program</code>を生成するには以下のようにする。</p>
<pre><code>$ ls
bar.cpp  foo.cpp
$ g++ -c foo.cpp
$ g++ -c bar.cpp
$ ls
bar.cpp  bar.o  foo.cpp  foo.o
$ g++ -o program foo.o bar.o
$ ls
bar.cpp  bar.o  foo.cpp  foo.o  program</code></pre>
<p>こうすることによって、1つのソースファイルを編集しただけで、すべてのソースファイルをコンパイルする必要がなくなる。</p>
<p>これを<code>Makefile</code>で書くには、出力するファイルと依存するファイルを考える。</p>
<ul>
<li><code>program</code>は<code>foo.o</code>と<code>bar.o</code>に依存する</li>
<li><code>foo.o</code>は<code>foo.cpp</code>に依存する</li>
<li><code>bar.o</code>は<code>bar.cpp</code>に依存する</li>
</ul>
<p>これを素直に書き出していけばよい。</p>
<pre><code># programはfoo.oとbar.oに依存する
program : foo.o bar.o
    g++ -o $@ $^
# foo.oはfoo.cppに依存する
foo.o : foo.cpp
    g++ -c $&lt;
# bar.oはbar.cppに依存する
bar.o : bar.cpp
    g++ -c $&lt;</code></pre>
<p><code>$^</code>はそのルールの依存するファイル名をすべて空白区切りで得る自動変数だ。この場合、<code>foo.o bar.o</code>に置換される。</p>
<h2 id="複数のソースファイルの書き方">複数のソースファイルの書き方</h2>
<p>C++の1つのソースファイルは、1つの<code>翻訳単位</code>(translation unit)として扱われる。別の翻訳単位の定義を使うには、さまざまな制約がある。具体的な例で学ぼう。</p>
<h3 id="関数">関数</h3>
<p>以下のコードを見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">void</span> print_int( <span class="dt">int</span> x )
{
    std::cout &lt;&lt; x ;    
}

<span class="dt">int</span> main()
{
    print_int( <span class="dv">123</span> ) ;
}</code></pre></div>
<p>このコードには2つの定義がある。<code>print_int</code>と<code>main</code>だ。</p>
<p>関数<code>print_int</code>を別のソースファイルである<code>print_int.cpp</code>に分割してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// print_int.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">void</span> print_int( <span class="dt">int</span> x )
{
    std::cout &lt;&lt; x ;    
}</code></pre></div>
<p>このコードは問題なくコンパイルできる。</p>
<pre><code>$ g++ -c print_int.cpp</code></pre>
<p>すると残りのソースファイルを<code>main.cpp</code>とすると以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>
<span class="dt">int</span> main()
{
    print_int( <span class="dv">123</span> ) ;
}</code></pre></div>
<p>このコードはコンパイルできない。なぜならば、C++では名前は使う前に宣言しなければならないからだ。</p>
<p>関数を宣言するには、関数の本体以外の部分を書き、セミコロンで終端する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// main.cpp</span>
<span class="dt">void</span> print_int( <span class="dt">int</span> ) ;

<span class="dt">int</span> main()
{
    print_int( <span class="dv">123</span> ) ;
}</code></pre></div>
<p>これでコンパイル、リンクができるようになった。</p>
<pre><code>$ g++ -c main.cpp
$ g++ -o program main.o print_int.o</code></pre>
<p>このとき、<code>main.cpp</code>で関数<code>print_int</code>を定義することはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー、print_int.cppでも定義されている</span>
<span class="dt">void</span> print_int( <span class="dt">int</span> ) { }

<span class="dt">int</span> main()
{
    print_int( <span class="dv">123</span> ) ;
}</code></pre></div>
<p>C++では定義は全翻訳単位に1つしか書くことができないルール、ODR(One Definition Rule、単一定義原則)があるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宣言</span>
<span class="dt">void</span> f() ;

<span class="co">// OK、再宣言</span>
<span class="dt">void</span> f() ;

<span class="co">// 定義</span>
<span class="dt">void</span> f() { }

<span class="co">// エラー、再定義</span>
<span class="co">// ODR違反</span>
<span class="dt">void</span> f() { }</code></pre></div>
<p>なぜODRがあるのか。なぜ定義は1つしか書けないのか。理由は簡単だ。もし定義が複数書けるならば、異なる定義を書くことができてしまうからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> f() { <span class="kw">return</span> <span class="kw">true</span> ; }
<span class="dt">bool</span> f() { <span class="kw">return</span> <span class="kw">false</span> ; }</code></pre></div>
<p>もし定義を複数書くことができる場合、この関数<code>f</code>は<code>true</code>を返すべきだろうか。それとも<code>false</code>を返すべきだろうか。</p>
<p>この問題を防ぐために、C++にはODRがある。</p>
<p>複数のソースファイル、つまり複数の翻訳単位からなるプログラムの場合でもODRは適用される。定義はすべての翻訳単位内で1つでなければならない。</p>
<p>引数リストが違う関数は別の関数で、別の定義になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 定義</span>
<span class="dt">void</span> f() { }

<span class="co">// OK、別の定義</span>
<span class="dt">void</span> f( <span class="dt">int</span> ) { }

<span class="co">// OK、別の定義</span>
<span class="dt">void</span> f( <span class="dt">double</span> ) { }</code></pre></div>
<p>名前は使う前に宣言が必要だが、肝心の定義は別のソースファイルに書いてある。宣言と定義を間違えてしまった場合はエラーになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// print_int.cpp</span>
<span class="co">// 失敗状態を返す</span>
<span class="dt">bool</span> print_int( <span class="dt">int</span> x )
{
    std::cout &lt;&lt; x ;
    <span class="kw">return</span> std::cout.fail() ;
}

<span class="co">// main.cpp</span>
<span class="dt">void</span> print_int( <span class="dt">int</span> ) ;

<span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    print_int( <span class="dv">123</span> ) ;
}</code></pre></div>
<p>このような間違いを防ぐためのお作法として、宣言はヘッダーファイルに書いて<code>#include</code>する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// print_int.h</span>
<span class="dt">bool</span> print_int( <span class="dt">int</span> x ) ;

<span class="co">// main.cpp</span>
<span class="ot">#include &quot;print_int.h&quot;</span>

<span class="dt">int</span> main()
{
    <span class="co">// 間違えない</span>
    <span class="dt">bool</span> result = print_int( <span class="dv">123</span> ) ;
}</code></pre></div>
<h3 id="変数-1">変数</h3>
<p>変数にも宣言と定義がある。通常、変数の宣言は定義を兼ねる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宣言かつ定義</span>
<span class="dt">int</span> variable ;</code></pre></div>
<p>そのため、別の翻訳単位の変数を使うために変数を書くと、定義が重複してしまい、ODR違反になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// global.cpp</span>
<span class="dt">int</span> variable ;

<span class="co">// main.cpp</span>
<span class="co">// エラー、ODR違反</span>
<span class="dt">int</span> variable ;

<span class="dt">int</span> main()
{
    variable = <span class="dv">0</span> ;
}</code></pre></div>
<p>変数を定義せずに宣言だけしたい場合は、<code>extern</code>キーワードを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// global.cpp</span>
<span class="dt">int</span> variable ;

<span class="co">// main.cpp</span>
<span class="co">// OK</span>
<span class="co">// 別の翻訳単位の定義を参照する</span>
<span class="dt">extern</span> <span class="dt">int</span> variable ;

<span class="dt">int</span> main()
{
    variable = <span class="dv">123</span> ;
}</code></pre></div>
<p><code>extern</code>キーワードを名前空間スコープで宣言された変数に使うと、定義せずに別の翻訳単位の定義を参照する意味になる。</p>
<p>変数の場合も、間違いを防ぐためにヘッダーファイルに書いて<code>#include</code>するとよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// global.h</span>
<span class="dt">extern</span> <span class="dt">int</span> variable ;

<span class="co">// main.cpp</span>
<span class="ot">#include &quot;global.h&quot;</span>

<span class="dt">int</span> main()
{
    variable = <span class="dv">123</span> ;
}</code></pre></div>
<h3 id="インライン関数インライン変数">インライン関数/インライン変数</h3>
<p>変数や関数の定義はODRにより重複できない。ということはヘッダーファイルに書いて複数の翻訳単位で<code>#include</code>できないということだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// library.h</span>
std::string delimiter{<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>} ;

<span class="dt">void</span> print_int( <span class="dt">int</span> x )
{ std::cout &lt;&lt; x &lt;&lt; delimiter ; }

<span class="co">// foo.cpp</span>
<span class="co">// エラー、ODR違反</span>
<span class="ot">#include &quot;library.h&quot;</span>

<span class="co">// bar.cpp</span>
<span class="co">// エラー、ODR違反</span>
<span class="ot">#include &quot;library.h&quot;</span></code></pre></div>
<p><code>library.h</code>には宣言だけを書いて、別途翻訳単位となるソースファイル、例えば<code>library.cpp</code>を用意しなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// library.h</span>
<span class="dt">void</span> print_int( <span class="dt">int</span> x ) ;

<span class="co">// library.cpp</span>
std::string delimiter{<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>} ;

<span class="dt">void</span> print_int( <span class="dt">int</span> x )
{ std::cout &lt;&lt; x &lt;&lt; delimiter ; }</code></pre></div>
<p>小さなライブラリの場合、この制約は煩わしい。できればヘッダーファイルだけで済ませてしまいたい。このためにC++には特別なODRを例外的に回避する方法がある。</p>
<p>キーワード<code>inline</code>を付けて定義した関数と変数は、インライン関数、インライン変数となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// library.h</span>
<span class="co">// インライン変数</span>
<span class="kw">inline</span> std::string delimiter{<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>} ;
<span class="co">// インライン関数</span>
<span class="kw">inline</span> <span class="dt">void</span> print_int( <span class="dt">int</span> x )
{ std::cout &lt;&lt; x &lt;&lt; delimiter ; }</code></pre></div>
<p>インライン関数とインライン変数は、複数の翻訳単位で重複して定義できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// foo.cpp</span>
<span class="ot">#include &quot;library.h&quot;</span>

<span class="co">// bar.cpp</span>
<span class="ot">#include &quot;library.h&quot;</span></code></pre></div>
<p><code>inline</code>はODRを例外的に回避できるとはいえ、強い制約がある。</p>
<ol style="list-style-type: decimal">
<li>異なる翻訳単位に限る</li>
</ol>
<p>同じ翻訳単位の中で重複することはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 1つの翻訳単位</span>
<span class="kw">inline</span> <span class="dt">int</span> variable ;
<span class="co">// エラー、再定義</span>
<span class="kw">inline</span> <span class="dt">int</span> variable ;</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>同じトークン列である</li>
</ol>
<p>インライン関数、インライン変数の定義のトークン列、つまりソースコードの文字列は完全に同じでなければならない。</p>
<p>たとえば以下はトークン列が違う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">int</span> f( <span class="dt">int</span> x ) { <span class="kw">return</span> x ; }
<span class="kw">inline</span> <span class="dt">int</span> f( <span class="dt">int</span> y ) { <span class="kw">return</span> y ; }</code></pre></div>
<p>インライン関数と変数のトークン列を同じにするには、ヘッダーファイルに書いて<code>#include</code>で取り込むことを徹底する。</p>
<ol start="3" style="list-style-type: decimal">
<li>意味が同じである</li>
</ol>
<p>同じトークン列でも意味が異なることがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// foo.cpp</span>
<span class="dt">void</span> f( <span class="dt">int</span> ) {  }
<span class="kw">inline</span> <span class="dt">bool</span> g( )
{
    <span class="kw">return</span> f( <span class="dv">0</span> ) ;
}

<span class="co">// bar.cpp</span>
<span class="dt">void</span> f( <span class="dt">double</span> ) {  }
<span class="kw">inline</span> <span class="dt">bool</span> g()
{
    <span class="kw">return</span> f( <span class="dv">0</span> ) ;
}</code></pre></div>
<p><code>foo.cpp</code>のインライン関数<code>g</code>は<code>f(int)</code>を呼び出すが、<code>bar.cpp</code>のインライン関数<code>g</code>は<code>f(double)</code>を呼び出す。インライン関数<code>g</code>のトークン列はどちらも同じだが、意味が異なる。</p>
<p>ODRの例外的な回避の怖いところは、間違えてしまってもコンパイラーがエラーメッセージを出してくれる保証がないところだ。上の同じトークン列で違う意味のような関数は、そのままコンパイルが通ってリンクされ、実行可能なプログラムが生成されてしまうかもしれない。そのようなプログラムの挙動がどうなるかはわからない。この理由は、ODR違反を完全に発見するコンパイラーの実装が技術的に困難だからだ。ODR違反をしないのはユーザーの責任だ。</p>
<p>インライン変数とインライン関数はわざわざ翻訳単位を分けて分割コンパイルするまでもないライブラリに使うとよい。</p>
<h3 id="クラス">クラス</h3>
<p>クラスにも宣言と定義がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 宣言</span>
<span class="kw">struct</span> Foo ;

<span class="co">// 定義</span>
<span class="kw">struct</span> Foo
{
    <span class="dt">int</span> data_member ;
    <span class="dt">int</span> member_function() ;
} ;</code></pre></div>
<p>クラスを複数の翻訳単位で使うには、関数と同じように宣言と定義に分ければよいと考えるかもしれないが、残念ながらクラスの宣言だけでできることは少ない。</p>
<p>クラスの宣言だけでできることは、クラス名を型名として使うとか、クラスのポインター型を作るぐらいのものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Foo ;
<span class="kw">using</span> Bar = Foo ;
Foo * ptr = <span class="kw">nullptr</span> ;</code></pre></div>
<p>宣言だけされたクラスのオブジェクトを作ることはできないし、ポインターの演算もできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Foo ;

<span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    Foo foo ;

    Foo * ptr = <span class="kw">nullptr</span> ;
    <span class="co">// エラー</span>
    ++ptr ;
}</code></pre></div>
<p>この理由は、宣言だけされたクラスは<code>不完全型</code>(Incomplete type)という特別な扱いの型になるからだ。クラスのオブジェクトを作ったりポインター演算をするには、クラスのオブジェクトのサイズを決定する必要があるが、そのための情報はまだコンパイラーが得ていないために起こる制約だ。</p>
<p>クラスの定義では、インライン変数やインライン関数と同じく、ODRの例外的な回避が認められている。条件も同じで、1. 異なる翻訳単位で、2. 同じトークン列で、3. 意味も同じ場合だ。</p>
<p>ODR違反を起こさないために、クラス定義はインクルードファイルに書いて<code>#include</code>するのがお作法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Foo.h</span>
<span class="co">// クラス定義</span>
<span class="kw">struct</span> Foo
{
    <span class="dt">int</span> data_member ;
    <span class="co">// メンバー関数の宣言</span>
    <span class="dt">int</span> member_function() <span class="dt">const</span> <span class="kw">noexcept</span>;
} ;

<span class="co">// Foo.cpp</span>
<span class="ot">#include &quot;Foo.h&quot;</span>
<span class="co">// メンバー関数の定義</span>
<span class="dt">int</span> Foo::member_function() <span class="dt">const</span> <span class="kw">noexcept</span>
{
    <span class="kw">return</span> data_member ;
} 

<span class="co">// main.cpp</span>
<span class="ot">#include &quot;Foo.h&quot;</span>

<span class="dt">int</span> main()
{
    Foo foo ;
    foo.data_member = <span class="dv">42</span> ;
    <span class="dt">int</span> value = foo.member_function() ;
}</code></pre></div>
<p>クラス定義の中で定義されたメンバー関数は、自動的にインライン関数になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Foo.h</span>
<span class="kw">struct</span> Foo
{
    <span class="dt">int</span> data_member ;
    <span class="co">// インライン関数</span>
    <span class="dt">int</span> member_function() <span class="dt">const</span> <span class="kw">noexcept</span>
    {
        <span class="kw">return</span> data_member ;
    }
} ;</code></pre></div>
<p>このように書くと、ヘッダーファイル<code>Foo.h</code>を<code>#include</code>するだけでどこでもクラス<code>Foo</code>が使えるようになる。メンバー関数を定義するための<code>Foo.cpp</code>は必要がなくなる。</p>
<p>クラスのデータメンバーは具体的なオブジェクトではないので、インライン変数ではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// これはオブジェクトではない</span>
    <span class="dt">int</span> data_member ;
} ;

<span class="dt">void</span> main()
{
    <span class="co">// オブジェクト</span>
    S s ;
    <span class="co">// サブオブジェクト</span>
    s.data_member ; 
}</code></pre></div>
<h5 id="staticメンバー">staticメンバー</h5>
<p>クラスのメンバーは非<code>static</code>メンバーと<code>static</code>メンバーに分けることができる。<code>static</code>メンバーは<code>static</code>キーワードを付けて宣言する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// 非staticメンバー</span>
    <span class="dt">int</span> data_member ;
    <span class="dt">void</span> member_function() ;

    <span class="co">// staticメンバー</span>
    <span class="kw">inline</span> <span class="dt">static</span> <span class="dt">int</span> static_data_member ;
    <span class="dt">static</span> <span class="dt">void</span> static_member_function() ;
} ;</code></pre></div>
<p><code>static</code>メンバー関数はクラスのオブジェクトには依存していない。そのため、クラスのオブジェクトなしで呼び出すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// 非staticメンバー</span>
    <span class="dt">void</span> member_function() { }

    <span class="co">// staticメンバー</span>
    <span class="dt">static</span> <span class="dt">void</span> static_member_function() { }
} ;

<span class="dt">int</span> main()
{
    S s ;
    <span class="co">// オブジェクトが必要</span>
    s.member_function() ;

    <span class="co">// オブジェクトは不要</span>
    S::static_member_function() ;
    <span class="co">// このように呼び出すこともできる</span>
    s.static_member_function() ;
}</code></pre></div>
<p><code>static</code>メンバー関数の呼び出しにクラスのオブジェクトを必要としない。そのため、<code>this</code>も使うことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> data_member() ;

    <span class="dt">void</span> f()
    {<span class="co">// thisが使える</span>
        <span class="kw">this</span>-&gt;data_member ;
    }

    <span class="dt">static</span> <span class="dt">void</span> g()
    {<span class="co">// thisは使えない</span>
    }
} ;</code></pre></div>
<p><code>static</code>データメンバーはクラスのオブジェクトの外の独立したオブジェクトだ。<code>static</code>データメンバーのクラス定義内での宣言は定義ではないので、クラスの定義外で定義する必要がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// 宣言</span>
    <span class="dt">static</span> <span class="dt">int</span> static_data_member ;
} ;
<span class="co">// 定義</span>
<span class="dt">int</span> S::static_data_member ;

<span class="dt">int</span> main()
{
    S::static_data_member = <span class="dv">123</span> ;
}</code></pre></div>
<p>複数の翻訳単位からなるプログラムの場合、ODRにより定義は1つしか書けないので、どこか1つのソースファイルだけに定義を書くことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>
<span class="kw">struct</span> S
{
    <span class="co">// 宣言</span>
    <span class="dt">static</span> <span class="dt">int</span> static_data_member ;
} ;

<span class="co">// S.cpp</span>
<span class="ot">#include &quot;S.h&quot;</span>
<span class="co">// 定義</span>
<span class="dt">int</span> S::static_data_member ;</code></pre></div>
<p>これは面倒なので、通常は<code>static</code>変数はインライン変数にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>
<span class="kw">struct</span> S
{
    <span class="co">// インライン変数かつstatic変数</span>
    <span class="kw">inline</span> <span class="dt">static</span> <span class="dt">int</span> static_data_member ;
} ;</code></pre></div>
<p>これで<code>static</code>変数を定義するだけのソースファイルを用意する必要はない。ただしインライン変数はC++17以降の機能なので、読者が昔のC++で書かれたコードを読む際には、まだ昔ながらの<code>static</code>データメンバーの定義に出くわすだろうから、覚えておこう。</p>
<p><code>static</code>メンバーはクラススコープの下に関数と変数というだけで、その実態は名前空間スコープ内の関数と変数と同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 名前空間</span>
<span class="kw">namespace</span> A {
    <span class="dt">int</span> variable ;
    <span class="dt">void</span> function() { }
}
<span class="co">// クラス</span>
<span class="kw">struct</span> B {
    <span class="kw">inline</span> <span class="dt">static</span> <span class="dt">int</span> variable ;
    <span class="dt">static</span> <span class="dt">void</span> function() { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// 名前空間</span>
    A::variable = <span class="dv">1</span> ;
    A::function() ;
    <span class="co">// クラス</span>
    B::variable = <span class="dv">1</span> ;
    B::function() ;
}</code></pre></div>
<h3 id="テンプレート-2">テンプレート</h3>
<p>テンプレートにもODRの例外が認められている。</p>
<p>テンプレートは具体的なテンプレート引数が与えられて実体化する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> holder
{
    T value ;
} ;

holder&lt;<span class="dt">int</span>&gt; a ;
holder&lt;<span class="dt">double</span>&gt; b ;</code></pre></div>
<p>このため、翻訳単位ごとに、同じトークン列で同じ意味のテンプレートコードが必要だ。インクルードファイルに書いて<code>#include</code>するお作法も同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// holder.h</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> holder
{
    T value ;
} ;

holder&lt;<span class="dt">int</span>&gt; a ;
holder&lt;<span class="dt">double</span>&gt; b ;</code></pre></div>
<p>C++に将来的に追加される予定のモジュールが入るまでは、テンプレートコードはすべてをインクルードファイルに書いて<code>#include</code>して使う慣習が続くだろう。</p>
<h1 id="デバッガー">デバッガー</h1>
<p>読者は複雑なコードを書く際に間違ったコードを書くことだろう。間違ったコードは直せばよい。問題はどこが間違っているのかわからない場合だ。</p>
<p>例えば以下のコードは<code>1</code>から<code>10</code>までの整数を標準出力するはずのプログラムだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt; <span class="dv">10</span> ; ++i )
        std::cout &lt;&lt; i ;
}</code></pre></div>
<p>しかし実際に実行してみると、<code>1</code>から<code>9</code>までの整数しか標準出力しない。なぜだろうか。</p>
<p>読者の中にはコード中の問題のある箇所に気が付いた人もいるだろう。これはたったの5行のコードで、問題の箇所も1箇所だ。これが数百行、数千行になり、関数やクラスを複雑に使い、問題の原因は複数の箇所のコードの実行が組み合わさった結果で、しかも自分で書いたコードなので正しく書いたはずだという先入観がある場合、たとえコードとしてはささいな間違いであったとしても、発見は難しい。</p>
<p>こういうとき、実際にコードを1行ずつ実行したり、ある時点でプログラムの実行を停止させて変数の値を見たりしたいものだ。</p>
<p>そんな夢を実現するのがデバッガーだ。この章ではデバッガーとしてGDB(GNUプロジェクトデバッガー)の使い方を学ぶ。</p>
<p>GDBで快適にデバッグするには、プログラムをコンパイルするときにデバッグ情報を出力する必要がある。そのためには、GCCに<code>-g</code>オプションを付けてプログラムをコンパイルする。</p>
<pre><code>$ g++ -g -o program program.cpp</code></pre>
<p>本書の始めに作った入門用の<code>Makefile</code>を使う場合は、<code>$gcc_options</code>に<code>-g</code>を加えることになる。</p>
<pre><code>gcc_options = -std=c++17 -Wall --pedantic-error -g</code></pre>
<p>コンパイラーのオプションを変更したあとは、<code>make clean</code>を実行してコンパイル済みヘッダーファイルを生成し直す必要がある。</p>
<pre><code>$ make clean</code></pre>
<h2 id="gdbのチュートリアル">GDBのチュートリアル</h2>
<p>では具体的にデバッガーを使ってみよう。以下のようなソースファイルを用意する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> val = <span class="dv">0</span> ;
    val = <span class="dv">10</span> ;
    val += <span class="dv">1</span> ;
    val *= <span class="dv">2</span> ;
    val *= <span class="dv">2</span> ;
    val /= <span class="dv">4</span> ;
}</code></pre></div>
<p>このプログラムをコンパイルする。</p>
<pre><code>$ g++ -g program.cpp -o program</code></pre>
<p>GDBを使ってプログラムのデバッグを始めるには、GDBのオプションとして<code>-g</code>オプション付きでコンパイルしたプログラムのファイル名を指定する。</p>
<pre><code>$ gdb program</code></pre>
<p>すると以下のように出力される。</p>
<pre><code>GNU gdb (Ubuntu 8.2-0ubuntu1) 8.2
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
Reading symbols from program...done.
(gdb) </code></pre>
<p>大量のメッセージに戸惑うかもしれないが、最後の行以外はGDBのライセンス表記やドキュメントだ。細部は環境ごとに異なる。</p>
<p>ここで重要なのは最後の行だ。</p>
<pre><code>(gdb)</code></pre>
<p>ここにGDBのコマンドを入力する。ヘルプを表示するコマンド<code>help</code>と入力してみよう。</p>
<pre><code>(gdb) help</code></pre>
<p>ヘルプメッセージが表示される。あるコマンドのヘルプを見たい場合は<code>help コマンド</code>と入力する。いまから使う予定のコマンドである<code>list</code>のヘルプを見てみよう。</p>
<pre><code>(gdb) help list</code></pre>
<p><code>list</code>コマンドは現在のソースファイルの前後10行を表示する。</p>
<pre><code>(gdb) list
1   int main()
2   {
3       int val = 0 ;
4       val = 10 ;
5       val += 1 ;
6       val *= 2 ;
7       val *= 2 ;
8       val /= 4 ;
9   }</code></pre>
<p>さっそく実行してみよう。実行するコマンドは<code>run</code>だ。</p>
<pre><code>(gdb) run
Starting program: 実行可能ファイルへのパス
[Inferior 1 (process PID) exited normally]</code></pre>
<p><code>run</code>コマンドを使うとデバッガーはプログラムを実行する。</p>
<p>プログラムの実行を特定の場所で止めるには<code>break</code>コマンドを使ってブレイクポイントを設定する。</p>
<pre><code>(gdb) help break</code></pre>
<p><code>break</code>コマンドには関数や行番号を指定できる。</p>
<pre><code>(gdb) break main
(gdb) break 4
(gdb) break 5</code></pre>
<p>これで、<code>main</code>関数、4行目、5行目にブレイクポイントを設定した。さっそくもう一度最初から実行してみよう。</p>
<pre><code>(gdb) run
Starting program: プログラムへのファイルパス

Breakpoint 1, main () at main.cpp:3
3       int val = 0 ;</code></pre>
<p><code>main</code>関数にブレイクポイントを設定したので、プログラムは<code>main</code>関数が呼ばれたところ、最初のコードである3行目を実行する手前で止まる。</p>
<p>プログラムの実行を再開するには<code>continue</code>コマンドを使う。</p>
<pre><code>(gdb) continue
Continuing.

Breakpoint 2, main () at main.cpp:4
4       val = 10 ;</code></pre>
<p>4行目にブレイクポイントを設定したので、4行目を実行する手前で止まる。</p>
<p>この時点で、変数<code>val</code>が初期化され、その値は0になっているはずだ。確かめてみよう。変数の値を調べるには<code>print</code>コマンドを使う。</p>
<pre><code>(gdb) print val
$1 = 0</code></pre>
<p>値が<code>0</code>になっていることが確認できた。実行を再開しよう。</p>
<pre><code>(gdb) continue
Continuing.

Breakpoint 3, main () at main.cpp:5
5       val += 1 ;</code></pre>
<p>4行目を実行し、5行目のブレイクポイントで止まる。4行目を実行したということは、変数<code>val</code>の値は<code>10</code>になっているはずだ。もう一度<code>print</code>コマンドで調べてみよう。</p>
<pre><code>(gdb) print val
$2 = 10</code></pre>
<p>値は<code>10</code>だ。GDBは<code>print</code>の結果の履歴を記録している。<code>$1</code>や<code>$2</code>というのはその記録を参照するための名前だ。その値は<code>print</code>コマンドで確認できる。</p>
<pre><code>(gdb) print $1
$3 = 0
(gdb) print $2
$4 = 10</code></pre>
<p>現在、プログラムは5行目を実行する手前で止まっている。このまま<code>continue</code>コマンドを使うとプログラムの終了まで実行されてしまう。もう一度1行だけ実行するには<code>break 6</code>で6行目にブレイクポイントを設定すればよいのだが、次の1行だけ実行したいときにいちいちブレイクポイントを設定するのは面倒だ。</p>
<p>そこで使うのが<code>step</code>だ。次の5行目を実行すると、変数<code>val</code>の値は<code>11</code>になっているはずだ。</p>
<pre><code>(gdb) step
6       val *= 2 ;
(gdb) print val
$5 = 11</code></pre>
<p>さて、残りの行も<code>step</code>して実行を1行ずつ確かめてみよう。</p>
<p>GDBの基本的な使い方を覚えたので、これから詳細な使い方を学んでいく。</p>
<h2 id="プログラムの実行">プログラムの実行</h2>
<p>GDBでプログラムをデバッグするには、GDBの起動時にプログラムのオプションとしてプログラムのファイル名を指定する。プログラムのファイル名が<code>program</code>の場合、以下のようにする。</p>
<pre><code>$ ls
program
$ gdb program</code></pre>
<p>起動したGDBでプログラムを実行するには、<code>run</code>コマンドを使う。</p>
<pre><code>(gdb) run</code></pre>
<p>このとき、プログラムにオプションを指定したい場合は<code>run</code>に続けて記述する。例えばプログラムの標準出力を<code>out.txt</code>にリダイレクトしたいときは以下のようにする。</p>
<pre><code>(gdb) run &gt; out.txt</code></pre>
<h2 id="プログラムの停止方法">プログラムの停止方法</h2>
<p>デバッガーの機能として一番わかりやすいのが、実行中のプログラムを一時停止させる機能だ。</p>
<h3 id="ブレイクポイント">ブレイクポイント</h3>
<p>コマンド<code>break</code>はブレイクポイントを設定する。プログラムの実行がブレイクポイントに達した場合、GDBはブレイクポイントの直前でプログラムの実行を中断する。</p>
<p>ブレイクポイントを設定する場所は<code>break</code>コマンドへの引数で指定する。省略して<code>b</code>だけでもよい。</p>
<pre><code>(gdb) break 場所
(gdb) b 場所</code></pre>
<p>場所として使えるのは行番号と関数名だ。</p>
<h4 id="行番号へのブレイクポイント">行番号へのブレイクポイント</h4>
<p>現在のソースファイルの123行目にブレイクポイントを設定する場合は以下のように書く。</p>
<pre><code>(gdb) break 123</code></pre>
<p>ソースファイルが複数ある場合は、</p>
<pre><code>(gdb) break ファイル名:行番号</code></pre>
<p>と書く。例えば<code>foo.cpp</code>の8行目にブレイクポイントを仕掛ける場合は、</p>
<pre><code>(gdb) break foo.cpp:8</code></pre>
<p>と書く。</p>
<h4 id="ブレイクポイントの確認">ブレイクポイントの確認</h4>
<p>設定したブレイクポイントの一覧は、<code>info breakpoints</code>コマンドで確認できる。</p>
<pre><code>(gdb) break 5
Breakpoint 1 at 0x1150: file main.cpp, line 5.
(gdb) break 6
Breakpoint 2 at 0x1157: file main.cpp, line 6.
(gdb) break 7
Breakpoint 3 at 0x115b: file main.cpp, line 7.
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001150 in main() at main.cpp:5
2       breakpoint     keep y   0x0000000000001157 in main() at main.cpp:6
3       breakpoint     keep y   0x000000000000115b in main() at main.cpp:7</code></pre>
<p>これは5,6,7行目にそれぞれブレイクポイントを設定したあとの<code>info breakpoints</code>の結果だ。</p>
<p>この表の意味は、左から番号(Num, Number)、種類(Type)、中断後の処理(Disposition), 有効/無効(Enb, Enable/Disable)、アドレス(Address), 内容(What)となっている。</p>
<p>ブレイクポイントには作成された順番に番号が振られる。ブレイクポイントの設定を変えるには、この番号でブレイクポイントを参照する。</p>
<p>ブレイクポイントには3種類ある。普通のブレイクポイントである<code>breakpoint</code>のほかに、特殊なブレイクポイントであるウォッチポイント(watchpoint)、キャッチポイント(catchpoint)がある。</p>
<p>中断後の処理と有効/無効の切り替えはあとで説明する。</p>
<p>アドレスというのはブレイクポイントを設定した場所に該当するプログラムのコード部分であり、本書では解説しない。</p>
<p>内容はブレイクポイントを設定した場所の情報だ。</p>
<h4 id="ブレイクポイントの削除">ブレイクポイントの削除</h4>
<p>ブレイクポイントを削除するには<code>delete</code>コマンドを使う。削除するブレイクポイントは番号で指定する。</p>
<pre><code>(gdb) delete 1</code></pre>
<p>番号を指定しないとすべてのブレイクポイントを削除することができる。</p>
<pre><code>(gdb) delete
Delete all breakpoints? (y or n) y
(gdb) info breakpoints
No breakpoints or watchpoints.</code></pre>
<h4 id="ブレイクポイントの有効無効">ブレイクポイントの有効/無効</h4>
<p>ブレイクポイントは有効/無効を切り替えることができる。</p>
<p>ブレイクポイントを無効化するには<code>disable</code>コマンドを使う。</p>
<pre><code>(gdb) disable 1</code></pre>
<p>ブレイクポイントを有効化するには<code>enable</code>コマンドを使う。</p>
<pre><code>(gdb) enable 1</code></pre>
<p>ブレイクポイントは発動したあとに自動で無効化させることができる。</p>
<p><code>enable [breakpoints] once</code>コマンドで、ブレイクポイントが一度発動すると自動的に無効化されるブレイクポイントを設定できる。</p>
<pre><code>(gdb) enable 1 once</code></pre>
<p>このコマンドは、ブレイクポイント番号1が一度発動したら自動的に無効化する設定をする。</p>
<p>ブレイクポイントは<span class="math inline">\(n\)</span>回発動したあとに自動的に無効化することもできる。そのためのコマンドは<code>enable [breakpoints] count n</code>だ。</p>
<pre><code>(gdb) enable 1 count 10</code></pre>
<p>上のコマンドは、ブレイクポイント番号1が10回発動したら自動的に無効化されるよう設定している。</p>
<h4 id="関数名へのブレイクポイント">関数名へのブレイクポイント</h4>
<p>ブレイクポイントの場所として関数名を書くと、その関数名が呼び出されたあと、関数の本体の1行目が実行されるところにブレイクポイントが設定される。</p>
<p>現在のソースファイルの関数<code>main</code>にブレイクポイントを設定する場合は以下のように書く。</p>
<pre><code>(gdb) break main</code></pre>
<p>ソースファイルが複数ある場合は、</p>
<pre><code>(gdb) ファイル名:関数名</code></pre>
<p>と書く。</p>
<p>C++では異なる引数で同じ名前の関数が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }
<span class="dt">void</span> f(<span class="dt">int</span>) { }
<span class="dt">void</span> f(<span class="dt">double</span>) { }

<span class="dt">int</span> main()
{
    f() ;
    f(<span class="dv">0</span>) ;
    f(<span class="fl">0.0</span>) ;
}</code></pre></div>
<p>このようなプログラムで関数<code>f</code>にブレイクポイントを設定すると、<code>f</code>という名前の関数すべてにブレイクポイントが設定される。</p>
<p>ブレイクポイントの一覧を表示する<code>info breakpoints</code>コマンドで確かめてみよう。</p>
<pre><code>(gdb) break f
Breakpoint 1 at 0x1149: f. (3 locations)
(gdb) info breakpoints 
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   &lt;MULTIPLE&gt;         
1.1                         y     0x0000000000001149 in f() at main.cpp:1
1.2                         y     0x0000000000001153 in f(int) at main.cpp:2
1.3                         y     0x000000000000115f in f(double) at main.cpp:3</code></pre>
<p>関数名<code>f</code>に該当するすべての関数に、ブレイクポイント番号1としてブレイクポイントが設定される。関数にはそれぞれサブの番号が振られる。</p>
<p>この状態でブレイクポイント番号1を削除すると、1.1, 1.2, 1.3はすべて削除される。</p>
<pre><code>(gdb) delete 1
(gdb) info breakpoints
No breakpoints or watchpoints.</code></pre>
<p>もし、オーバーロードされた同名の関数のうちの一部だけにブレイクポイントを仕掛けたい場合、曖昧性を解決するメニューを表示する設定にすることで、一部の関数だけを選ぶことができる。メニューを表示する設定にするには、</p>
<pre><code>(gdb) set multiple-symbols ask</code></pre>
<p>というコマンドを使う。これ以降の<code>break</code>コマンドが名前が曖昧であることを検出した場合、以下のようなメニューを表示する。</p>
<pre><code>(gdb) break f
[0] cancel
[1] all
[2] run.cpp:f()
[3] run.cpp:f(double)
[4] run.cpp:f(int)
&gt;</code></pre>
<p>ここで<code>0</code>を入力するとキャンセル。<code>1</code>を入力するとすべての関数にブレイクポイントを設定する。</p>
<p>特定の関数だけにブレイクポイントを設定したい場合、その関数に対応する番号を入力する。例えば、<code>f()</code>と<code>f(int)</code>だけにブレイクポイントを設定したい場合は、</p>
<pre><code>&gt; 2 4</code></pre>
<p>と入力する。</p>
<h3 id="条件付きブレイクポイント">条件付きブレイクポイント</h3>
<pre><code>(gdb) break ... if 条件</code></pre>
<p>と入力すると、<code>条件</code>が<code>true</code>となるときのみブレイクポイントが発動する。</p>
<p>例えば以下のようなコードで、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i { } ;
    <span class="kw">while</span> ( i != <span class="dv">1000</span> )
    {
        ++i ;
        std::cout &lt;&lt; i ;
    }
}</code></pre></div>
<p>以下のように7行目に変数<code>i</code>が<code>500</code>に等しい条件を設定すると</p>
<pre><code>(gdb) break 7 if i == 500</code></pre>
<p>変数<code>i</code>が<code>500</code>でありかつ7行目が実行される直前でブレイクポイントが発動する。</p>
<h2 id="プログラムの実行再開とステップ実行">プログラムの実行再開とステップ実行</h2>
<p>以下のようなプログラムがあるとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x )
{
    <span class="kw">return</span> x + <span class="dv">1</span> ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
    i = f(i) ;
    i = f(i) ;
    i = f(i) ;
}</code></pre></div>
<p>このプログラムを<code>main</code>関数から1行ずつ実行してその挙動を確かめたい。その場合に、すべての行にブレイクポイントを設定するのは面倒だ。GDBではこのような場合に、現在中断している場所から1行だけ実行する方法がある。</p>
<h3 id="実行再開continue">実行再開(continue)</h3>
<p><code>continue</code>コマンドは実行を再開する。省略して<code>c</code>でもよい</p>
<pre><code>(gdb) continue
(gdb) c</code></pre>
<p>実行を再開すると、次のブレイクポイントが発動するか、プログラムが終了するまで実行が続く。</p>
<h3 id="ステップ実行step">ステップ実行(step)</h3>
<p><code>step</code>コマンドは現在実行が中断している場所から、ソースファイルで1行分の実行をして中断する。</p>
<pre><code>(gdb) step
(gdb) s</code></pre>
<p><code>step</code>コマンドは省略して<code>s</code>でもよい。</p>
<p>先ほどのソースファイルで、まず<code>main</code>関数にブレイクポイントを設定して実行すると、</p>
<pre><code>(gdb) break main
(gdb) run</code></pre>
<p><code>main</code>関数に入った直後で実行が中断する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
&gt;&gt;  <span class="dt">int</span> i = <span class="dv">0</span> ;
    i = f(i) ;
    i = f(i) ;
...</code></pre></div>
<p>この状態で<code>step</code>コマンドを使うと</p>
<pre><code>(gdb) step</code></pre>
<p>1行分にあたる実行が行われ、また中断される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
&gt;&gt;  i = f(i) ;
    i = f(i) ;
...</code></pre></div>
<p>もう一度<code>step</code>コマンドを使うと、今度は関数<code>f</code>の中で実行が中断する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x )
{
&gt;&gt;  <span class="kw">return</span> x + <span class="dv">1</span> ;
}

<span class="dt">int</span> main()
...</code></pre></div>
<p>このまま<code>step</code>コマンドを続けていくと、また<code>main</code>関数に戻り、また次の行が実行され、また関数<code>f</code>が実行される。</p>
<p>1行ずつ実行するのではなく<span class="math inline">\(n\)</span>行実行したい場合は、<code>step</code>コマンドに<span class="math inline">\(n\)</span>を指定する。</p>
<pre><code>(gdb) step n</code></pre>
<p>するとソースファイルの<span class="math inline">\(n\)</span>行分実行される。例えば以下のように書くと、</p>
<pre><code>(gdb) step 3</code></pre>
<p>3行分実行される。</p>
<h3 id="ネクスト実行next">ネクスト実行(next)</h3>
<p><code>step</code>コマンドはソースファイルの1行分を実行してくれるが、途中に関数呼び出しが入る場合、その関数のソースファイルがある場合はその関数の中も1行とカウントする。<code>next</code>コマンドは現在実行が中断しているソースファイルの次の行を1行として扱い、次の行まで実行して中断する。</p>
<p>例えばプログラムが以下の状態で中断しているとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
&gt;&gt;  i = f(i) ;
    i = f(i) ;
...</code></pre></div>
<p>このまま<code>step</code>コマンドを実行すると、関数<code>f</code>の中の1行で実行が中断する。一方<code>next</code>コマンドを使うと、</p>
<pre><code>(gdb) next</code></pre>
<p>現在止まっているソースファイルの次の1行の手前まで実行して中断する。途中の関数呼び出しはすべて実行される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> i = <span class="dv">0</span> ;
    i = f(i) ;
&gt;&gt;  i = f(i) ;
...</code></pre></div>
<p><code>step</code>コマンドと同じく、<code>next</code>コマンドも<span class="math inline">\(n\)</span>行分一度に実行することができる。</p>
<pre><code>(gdb) next n</code></pre>
<h3 id="関数から抜けるまで実行finish">関数から抜けるまで実行(finish)</h3>
<p><code>finish</code>コマンドは現在の関数から<code>return</code>するまで実行する。</p>
<h2 id="バックトレース">バックトレース</h2>
<p>バックトレースは中断しているプログラムの情報を得るとても強力なコマンドだ。</p>
<pre><code>(gdb) backtrace
(gdb) bt</code></pre>
<p>バックトレースを表示するには<code>backtrace</code>もしくは<code>bt</code>というコマンドを使う。</p>
<p>例えば以下のようなソースファイルがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() { }

<span class="dt">void</span> apple() { f() ; } 
<span class="dt">void</span> banana() { f() ; } 
<span class="dt">void</span> cherry() { apple() ; } 

<span class="dt">int</span> main()
{
    f() ;
    apple() ;
    banana() ;
    cherry() ;
}</code></pre></div>
<p>ここで関数<code>f</code>に注目してみよう。関数<code>f</code>はさまざまな関数から呼ばれる。関数<code>main</code>から呼ばれるし、関数<code>apple</code>や<code>banana</code>からも呼ばれる。特に、関数<code>cherry</code>は関数<code>apple</code>を呼び出すので、間接的に関数<code>f</code>を呼ぶ。</p>
<p>関数<code>f</code>にブレイクポイントを仕掛けて実行してみよう。</p>
<pre><code>(gdb) break f
(gdb) run
(gdb) continue
(gdb) continue
(gdb) continue
(gdb) continue</code></pre>
<p>関数<code>f</code>が呼ばれるたびに実行が中断するが、関数<code>f</code>がどこから呼ばれたのかがわからない。</p>
<p>こういうときにバックトレースが役に立つ。</p>
<p>上のコマンドを実行しながら、関数<code>f</code>のブレイクポイントが発動するたびに、<code>backtrace</code>コマンドを入力してみよう。</p>
<pre><code>(gdb) break f
(gdb) run
(gdb) backtrace
#0  f () at main.cpp:2
#1  0x0000555555556310 in main () at main.cpp:10</code></pre>
<p><code>#0</code>がバックトレースの最も深い現在のスタックフレームだ。これは関数<code>f</code>でソースファイル<code>main.cpp</code>の2行目だ。<code>#1</code>が<code>#0</code>の上のスタックフレームで、これは関数<code>main</code>で10行目にある。</p>
<p>実行を再開して、次の関数<code>f</code>のバックトレースを見よう。</p>
<pre><code>(gdb) continue
(gdb) backtrace
#0  f () at main.cpp:2
#1  0x00005555555562ec in apple () at main.cpp:4
#2  0x0000555555556315 in main () at main.cpp:11</code></pre>
<p>今回はスタックフレームが3つある。最も外側のスタックフレームは関数<code>main</code>で、そこから関数<code>apple</code>が呼び出され、そして関数<code>f</code>が呼び出される。</p>
<p>さらに進めよう。</p>
<pre><code>(gdb) continue
(gdb) backtrace
#0  f () at main.cpp:2
#1  0x00005555555562f8 in banana () at main.cpp:5
#2  0x000055555555631a in main () at main.cpp:12</code></pre>
<p>今度は<code>main</code>→<code>banana</code>→<code>f</code>になった。次はどうだろうか。</p>
<pre><code>(gdb) continue
(gdb) backtrace
#0  f () at main.cpp:2
#1  0x00005555555562ec in apple () at main.cpp:4
#2  0x0000555555556304 in cherry () at main.cpp:6
#3  0x000055555555631f in main () at main.cpp:13</code></pre>
<p>最後は<code>main</code>→<code>cherry</code>→<code>apple</code>→<code>f</code>だ。</p>
<p>このようにバックトレースを使うことでプログラムの状態を調べることができる。</p>
<h2 id="変数の値を確認">変数の値を確認</h2>
<p>変数の値を確認するには<code>print</code>コマンドを使う。</p>
<pre><code>(gdb) print 式</code></pre>
<p><code>print</code>コマンドは式を評価した結果を出力する。</p>
<p>例えば以下のようなソースファイルがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    x += <span class="dv">1</span> ;
    x *= <span class="dv">2</span> ;
}</code></pre></div>
<p>この変数<code>x</code>の値を見ていこう。</p>
<p>まず変数<code>x</code>が初期化されるところまで実行する。</p>
<pre><code>(gdb) break main
(gdb) run
(gdb) step
(gdb) print x
$1 = 1</code></pre>
<p>1行ずつ実行して値を見ていこう。</p>
<pre><code>(gdb) step
(gdb) print x
$2 = 2
(gdb) step
(gdb) print x
$3 = 4</code></pre>
<p><code>print 式</code>コマンドで注意すべき点としては、<code>式</code>の副作用もプログラムに反映されるということだ。例えば以下のように変数<code>x</code>を変更する式も使えるし、変数<code>x</code>は実際に変更されてしまう。</p>
<pre><code>(gdb) print ++x
(gdb) print x = 0</code></pre>
<p>式では関数まで呼べてしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> hello()
{
    std::cout &lt;&lt; <span class="st">&quot;hello&quot;</span>
}

<span class="dt">int</span> main() { }</code></pre></div>
<p>このプログラムは関数<code>hello</code>を呼ばないし標準出力には何も出力しない。しかしこのプログラムをGDBでロードし、<code>main</code>関数にブレイクポイントを設定してから実行し、ブレイクポイントが発動したら<code>print hello()</code>コマンドを使ってみると、</p>
<pre><code>(gdb) break main
(gdb) run
(gdb) print hello()</code></pre>
<p>なんと関数<code>hello</code>が呼び出され、標準出力に<code>hello</code>と出力されるではないか。</p>
<p><code>print</code>コマンドの式のもたらす副作用には注意しよう。</p>
<h2 id="シグナルによるプログラムの中断">シグナルによるプログラムの中断</h2>
<p>プログラムはさまざまな理由によりシグナルを出して実行を強制的に終了する。このシグナルはGDBによってトラップされ、ブレイクポイントと同じくプログラムの中断として扱われる。</p>
<p>プログラムが実行を終了するようなシグナルは、プログラムの不具合によって生じる。具体的な不具合は実行環境に依存するが、たいていの環境で動く不具合は、nullポインターを経由した間接アクセスと、ゼロ除算だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// nullポインターを経由した間接アクセス</span>
<span class="dt">int</span> * ptr = <span class="kw">nullptr</span> ;
*ptr = <span class="dv">0</span> ;
<span class="co">// ゼロ除算</span>
<span class="dv">1</span> / <span class="dv">0</span> ;</code></pre></div>
<p>実際にそのようなプログラムを作ってGDBで実行し、プログラムが中断されることを確認してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x { } ;
    std::cin &gt;&gt; x ;
    std::cout &lt;&lt; <span class="dv">1</span> / x ;
}</code></pre></div>
<p>このプログラムはユーザーが標準入力から<code>0</code>を入力するとゼロ除算となり強制的に終了する。GDBで実行してみよう。</p>
<pre><code>$ gdb program
(gdb) run
Starting program:
0

Program received signal SIGFPE, Arithmetic exception.
0x0000555555556336 in main () at main.cpp:5
5       std::cout &lt;&lt; 1 / x ;</code></pre>
<p>ちょうどゼロ除算を起こした箇所でプログラムの実行が中断する。</p>
<p>このとき中断した状態でプログラムのさまざまな状態を観測できる。例えばバックトレースを表示したり、変数の値を確認したりできる。</p>
<h2 id="コアダンプを使ったプログラムの状態の確認">コアダンプを使ったプログラムの状態の確認</h2>
<p>プログラムがシグナルによって強制的に終了したときに、たまたまデバッガーで動かしていたならばプログラムの状態を調べられる。しかし都合よくデバッガーで実行していない場合はどうすればいいのか。</p>
<p>まずプログラムを普通に実行してみよう。</p>
<pre><code>$ program
0
Floating point exception (core dumped)</code></pre>
<p><code>core dumped</code>という文字が気になる。プログラムはシグナルで強制的に実行を終了するときコアファイルをダンプする。このファイル名は通常<code>core</code>だ。通常はカレントディレクトリーに<code>core</code>という名前のファイルが生成されているはずだ。</p>
<p>もしカレントディレクトリーに<code>core</code>という名前のファイルがない場合、以下のコマンドを実行する。</p>
<pre><code>$ ulimit -c unlimited</code></pre>
<p>これにより<code>core</code>ファイルが生成されるようになる。</p>
<p>すでにコアファイルが存在する場合に上書きされるかどうかは環境により異なる。昔のコアファイルがいらないのであれば消しておこう。</p>
<pre><code>$ rm ./core
$ ./program
0
Floating point exception (core dumped)
$ find core
core</code></pre>
<p>このコアファイルはデバッガーに読み込ませることで、プログラムが強制的に終了するに至った瞬間のプログラムの状態を調べるのに使える。</p>
<p>使い方はGDBにプログラムファイルと一緒に指定するだけだ。</p>
<pre><code>$ gdb program core
...
Core was generated by `./program&#39;.
Program terminated with signal SIGFPE, Arithmetic exception.
#0  0x000055dcbfd3d336 in main () at main.cpp:5
5       std::cout &lt;&lt; 1 / x ;
(gdb) backtrace
#0  0x000055dcbfd3d336 in main () at main.cpp:5
(gdb) print x
$1 = 0</code></pre>
<p>デバッガーはとても役に立つ。本書では少しだけしか解説しなかったが、このほかにも強力な機能がたくさんある。</p>
</body>
</html>
